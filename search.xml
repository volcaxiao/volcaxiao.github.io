<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>welcome</title>
    <url>/2022/09/06/welcome/</url>
    <content><![CDATA[<p>欢迎来到volca’s blog_world，在这里大家可以讨论学习，侃侃大山，<del>发一发电</del>。初临blog，一定要看完这篇welcome，要有正确的打开方式喔。<br><strong>更新时间：2022-09-16</strong></p>
<span id="more"></span>
<h1 id="let’s-start"><a href="#let’s-start" class="headerlink" title="let’s start"></a>let’s start</h1><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><h3 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h3><ul>
<li>这里是大家合法<del>发电</del>的地方，不过也得请<strong>合理合法</strong>哈！</li>
<li>评论区用的是<a href="https://livere.com/">来必力</a>，大家用QQ，微信等<strong>登录后</strong>就可以评论啦。</li>
<li>对文章内容有什么问题指正，或者对此类问题还有什么疑问的话，欢迎评论区留言（反正我不会，总有dalao会），我会尽量去回答你的问题！</li>
<li>博主尽可能在<strong>每一个界面</strong>都放了评论区，有任何问题请批评指正。</li>
<li>有问题也可以通过头像下的<strong>email</strong>私聊联系我。</li>
<li>水平有限，敬请谅解~</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul>
<li>搜索功能在侧边栏最后一个</li>
<li>博主用的是最便宜的搜索（hexo自带滴），所以功能可能有点简陋，但是应该也够用了。</li>
</ul>
<h3 id="分享功能（待上线。。。）"><a href="#分享功能（待上线。。。）" class="headerlink" title="分享功能（待上线。。。）"></a>分享功能（待上线。。。）</h3><ul>
<li>可以对于每一篇文章进行分享</li>
<li>但由于博主能力有限且胆小（怕配崩咯），此功能 <strong><em>暂时没有上线</em></strong> ，博主俺呀努力点早日搞出来叭~</li>
<li>但是俺灵机一动，弄出来个东西——<strong>本文链接</strong>，放在<strong>文章的最后</strong>的红框框里啦，可以暂时充当一下文章分享功能，大家见谅~</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>这一点可以结合着后面的<a href="#内容简介">内容简介</a>一起食用喔~</li>
<li>在这里<a href="http://volcaxiao.top/categories/">分类</a></li>
<li>分类的应该还是合理的，按需选取喔</li>
</ul>
<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><blockquote>
<p>这里主要就是一些内容分类以及具体的打开方式</p>
</blockquote>
<h3 id="北航信息类大一资料"><a href="#北航信息类大一资料" class="headerlink" title="北航信息类大一资料"></a>北航信息类大一资料</h3><ul>
<li>博主建博客时已是大二，没法对大一的知识再进行系统的梳理，所以把大一的时候<strong>整理的资料</strong>上传上来，学弟学妹们按需自取。</li>
<li>资料包括但不限于往年题的题与解析（想当年一个一个抠出来的）、课件、期末复习的总结资料。</li>
<li>内容应该还是挺全面的，个人认为。</li>
<li>形式是通过北航云盘链接上传（温知识，北航校园网用北航云盘不跑流量）。</li>
<li>在传资料的博客里还会有学长亲身经验分享，大家也可以辩证看待，多多思考。</li>
</ul>
<h2 id="工科高等代数"><a href="#工科高等代数" class="headerlink" title="工科高等代数"></a>工科高等代数</h2><ul>
<li>但是事情有所变化，博主今年有幸应聘上了学支中心的<strong>朋辈辅导师</strong>，并负责<strong>工科高等代数</strong>的课程。将会在第3，6，9，12，15周周末为大家带来<strong>微博直播课程</strong>，并会在期中期末烤漆给大家<strong>串讲</strong>，所以我会把每次上课的<strong>备课</strong>本作为博客上传，大家感兴趣的话可以康康。</li>
<li>不过，博主开通了一个 <strong><a href="http://volcaxiao.top/AA-column/">工科高等代数专栏</a></strong></li>
<li>在这个专栏里，会放我上面说的所有内容。</li>
<li>另外这个专栏最下方有<strong>评论区</strong>，大家可以多多水水，我也会在评论区答疑哒~</li>
</ul>
<h3 id="四六级资料"><a href="#四六级资料" class="headerlink" title="四六级资料"></a>四六级资料</h3><ul>
<li>形式内容大致<strong>同上</strong>。</li>
</ul>
<h3 id="工科大学物理-amp-离散数学2笔记"><a href="#工科大学物理-amp-离散数学2笔记" class="headerlink" title="工科大学物理&amp;离散数学2笔记"></a>工科大学物理&amp;离散数学2笔记</h3><ul>
<li>博主俺呀，大一下懒惰啦，不太喜欢做笔记，但是笔记是挺重要的，这里会实时更新俺的<strong>大物总结笔记</strong>、<strong>离散总结笔记</strong>（有效push）。</li>
<li>欢迎大火留言指正与讨论。</li>
</ul>
<h3 id="CO-something"><a href="#CO-something" class="headerlink" title="CO something"></a>CO something</h3><ul>
<li>秋季，是祭祖的时节~</li>
<li>博主俺会把学习CO的一些<strong>小心得小总结</strong>放在这</li>
<li>欢迎大家来一起学习。</li>
</ul>
<h3 id="学习心得总结记录"><a href="#学习心得总结记录" class="headerlink" title="学习心得总结记录"></a>学习心得总结记录</h3><ul>
<li>博主喜欢在这方面进行一些思考与学习，也分享给大家。</li>
<li>大家有什么想法也欢迎交流</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>这里会有其他一些零零散散的知识点</li>
<li>或者是杂事</li>
<li>积少成多后可能会<strong>单独new一个分类</strong>出来，大家可以多注意<strong>welcome的更新</strong>！</li>
</ul>
<h2 id="约法三章"><a href="#约法三章" class="headerlink" title="约法三章"></a>约法三章</h2><ul>
<li>评论区文明发言。</li>
<li>都不容易，请任何事情都就事论事。</li>
<li>一般小事请不要通过邮件通知，因为可能判为垃圾邮件。</li>
</ul>
<blockquote>
<p>未完待续。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>welcome</category>
      </categories>
      <tags>
        <tag>welcome</tag>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学（二）图论总结</title>
    <url>/2023/02/08/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>离散数学自然数归纳法与基数</title>
    <url>/2023/02/08/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>蒟蒻博主缓考了离散，于是开始芝士总结与复习，进度（4/5）</p>
<span id="more"></span>
<h1 id="自然数归纳法与基数"><a href="#自然数归纳法与基数" class="headerlink" title="自然数归纳法与基数"></a>自然数归纳法与基数</h1><h2 id="自然数"><a href="#自然数" class="headerlink" title="自然数"></a>自然数</h2><h3 id="自然数构造"><a href="#自然数构造" class="headerlink" title="自然数构造"></a>自然数构造</h3><ul>
<li><p>自然数依托于用集合论构造，各种性质用Peano公理推导，所以构造出的自然数需要满足Peano公理</p>
</li>
<li><p>集合的后继：$对于集合A，其后继集合定义为A^+ = A \cup \{A\}(所以每个集合的后继是唯一的) $</p>
<ul>
<li>所以我们知道后继集合的几点性质：<ul>
<li>$A \subseteq A^+(A的元素在A^+里)；A \in A^+ (A本身也在A^+里) $</li>
<li>$A^+ \neq \phi $</li>
</ul>
</li>
<li>例：<ul>
<li>$\phi^+ = \{\phi \} $</li>
<li>$\{\phi\}^+ = \{\phi, \{ \phi \} \} $</li>
</ul>
</li>
</ul>
</li>
<li><p>所以由上述性质：冯·诺依曼(Von Neumann)给出了他构造自然数系统&lt; N,+,·&gt;的方案</p>
<ul>
<li><script type="math/tex; mode=display">
    \begin{align*}
        &0 = \phi    \\
        &1 = 0^+ = \phi^+ = \{ 0 \}     \\
        &2 = 1^+ = \{\phi \}^+ = \{0,1\}     \\
        &3 = 2^+ = 2 \cup \{2\} = \{0,1,2 \}     \\
        &...     \\
        &n+1 = n^+ = \{0,1,2,...,n \}
    \end{align*}</script></li>
<li>我们可以采用集合论中学到的归纳定义法来定义自然数：<ul>
<li>$0 \in N (基础项) $</li>
<li>$若 n \in N , 则 n^+ \in N (归纳项) $</li>
<li>$只有有限次应用1与2得到的元素才是自然数 $</li>
</ul>
</li>
</ul>
</li>
<li><p>引理：$若n \in N, 则\cup n^+ = n $</p>
</li>
</ul>
<h3 id="Peano公理及运算性质"><a href="#Peano公理及运算性质" class="headerlink" title="Peano公理及运算性质"></a>Peano公理及运算性质</h3><ul>
<li>我们前面说构造的自然数需要满足Peano公理，Peano公理的内容如下：<ul>
<li>P1: $0 \in N $(归纳基础项)</li>
<li>P2: $若n \in N, 则n^+ \in N $(归纳项)</li>
<li>P3: $若n \in N, 则 n^+ \neq 0 $(没有以0为后继的项，0是初始项)</li>
<li>P4: $若n,m \in N \wedge n^+ = m^+, 则n = m $(后继的唯一性,可由上述引理得到)</li>
<li>P5: $满足P1与P2的极小化 $</li>
</ul>
</li>
<li><p>由Peano公理以及后继的性质我们可以知道作为集合的自然数的几点性质：</p>
<ul>
<li>传递性: $若n_1 \in n_2, n_2 \in n_3, 则 n_1 \in n_3 $</li>
<li>三岐性: $对于任意两个n_1, n_2 \in N, 满足(n_1 \in n_2) \vee (n_1 = n_2) \vee (n_2 \in n_1) $</li>
<li>良基性: $不存在一个自然数的无穷递降序列n_{1\sim}，使得n_{i+1} \in n_i $</li>
</ul>
</li>
<li><p>所以我们由Peano公理的三大性质可以知道，我们可以定义出自然数元素之间的关系，以及自然数的运算，我们称之为大/小于，加法，乘法。</p>
<ul>
<li>小于: $若m,n \in N 且 m \in n, 则我们称m小于n，记作m&lt;n $(很明显，小于关系是一个逆序关系)</li>
<li>由此我们也可以类推出小于等于关系，它是一个（全）偏序关系，由于良基性，它也会是一个良序关系。</li>
<li>加法: $m+0 = 0; m + n^+ = (m + n)^+ $</li>
<li>乘法: $m \cdot 0 = 0; m \cdot n^+ = m \cdot n + m $   (自己拿两个数加一加乘一乘就能理会其中的归纳意味)</li>
</ul>
</li>
</ul>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><ul>
<li>上文中Peano公理的极小化有几种表述的方法，详细见集合论一章的描述，其中有一种极小化方法如下：<ul>
<li>$若S \subseteq N 满足0 \in S且n \in S \rightarrow n^+ \in S(1/2条)，则S = N $</li>
</ul>
</li>
<li>这个极小化方法是数学归纳法的基础，下面是数学归纳法的叙述（第一归纳法）<ul>
<li>$设P(n)是自然数论域上的性质(或谓词)，若能证明1与2，则对所有n\in N,P(n)为真 $<ol>
<li>$P(0)为真 $</li>
<li>$对任何n \in N, P(n) \Rightarrow P(n^+) $</li>
</ol>
</li>
<li>可表述为：$P(0) \wedge (\forall n)(P(n) \rightarrow P(n+1)) \Rightarrow \forall n P(n) $</li>
<li>基础项也可从非0数k开始：<ul>
<li>$P(k) \wedge (\forall n)(n \geq k \wedge P(n) \rightarrow P(n+1)) \Rightarrow \forall n(n \geq k \rightarrow P(n)) $</li>
</ul>
</li>
</ul>
</li>
<li>我们可以从第一归纳法推出第二归纳法：<ul>
<li>$\forall n(\forall k(k&lt;n \rightarrow P(k)) \rightarrow P(n)) \Rightarrow \forall nP(n) $</li>
<li>上述归纳不需要单独列出P(0)条件，因为任取到n=0时，条件等价于P(0)<blockquote>
<p>…证明过程</p>
</blockquote>
</li>
</ul>
</li>
<li>二维归纳原理：暂略</li>
</ul>
<h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><h3 id="集合大小的度量与比较"><a href="#集合大小的度量与比较" class="headerlink" title="集合大小的度量与比较"></a>集合大小的度量与比较</h3><ul>
<li>比较两个集合的大小有两个方法：<ul>
<li>计数法：数出元素的个数，谁大谁多。</li>
<li>愚人比宝：每次各取其一，看谁先取完。</li>
<li>对于一个无限集，计数法失效，但我们怎么用第二个方法？可以在该集合与某个自然数之间建立一个双射。</li>
</ul>
</li>
<li>等势：若在两个集合之间存在一个双射，则称集合对等（或等势），记作 $A \sim B $<ul>
<li>我们易知等势关系具有自反对称传递性，是等价关系</li>
</ul>
</li>
<li>集合是有穷集 当且仅当 它与一个自然数等势，且唯一（由三岐性反证法证明），这个自然数被称为有穷集合的<span id="jishu"><strong>基数</strong></span>，记作 $\sharp A $<ul>
<li>而若集合是无穷极，就不能与一个自然数等势</li>
</ul>
</li>
<li>定义了有穷集合的基数，我们就可以定义出对应关系与基数大小了<ul>
<li>$显然，A \sim B \Rightarrow \sharp A = \sharp B $</li>
<li>$若存在A到B的单射，则也就是A等势的自然数与B的自然数之间存在单射，所以\sharp A \leq \sharp B $</li>
<li>$若\sharp A \leq \sharp B且\sharp A \neq \sharp B，则记为\sharp A &lt; \sharp B $</li>
<li>由自然数的三岐性可知，任何两个基数之间可以比较大小</li>
<li>基数相等是等价关系，小于等于是偏序关系</li>
</ul>
</li>
<li>小技巧：我们可以通过tan函数建立任何一个连续的开区间与实数R的双射等势关系<ul>
<li>正是如此，我们发现无穷集合可以与它本身的真子集等势（这是无穷集合的一固有性质）</li>
</ul>
</li>
</ul>
<h3 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h3><ul>
<li>由上述表述，我们可发现无穷集合与有限集合的一点根本差别：<ul>
<li>任何与自身真子集等势的集合都是无穷集合</li>
<li>所以任何有限集都不能与自身的真子集对等</li>
</ul>
</li>
<li>上述对于有限集的叙述叫做抽屉原理（鸽笼原理），通俗的说：<ul>
<li>你有n+1本书，但是只有个抽屉，你就建立不了一个n+1与n的双射，一定会有一个抽屉放了不止一本书。</li>
<li>形式抽象化的表示为：<ul>
<li>$把s(s\geq 1)个元素分成t组，必有一个组至少有\lceil s/t \rceil 个元素(\lceil \rceil 为向上取整的记号) $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="无穷集"><a href="#无穷集" class="headerlink" title="无穷集"></a>无穷集</h3><ul>
<li>上文中提到了<a href="#jishu">有穷集合的基数</a>的概念，我们拓展它，让它不再局限在元素个数这一个概念，对于无限集，我们也定义它的基数，只是规定特殊的记号。<ul>
<li>$我们令\sharp N = \aleph_0 $</li>
<li>对于上文中关于有穷集合基数的大小的性质，都可以推广到基数上</li>
</ul>
</li>
<li>基数的定义：$F是集合组，\sim 是F上的等势关系，关系\sim在F上的等价类称为基数 $<ul>
<li>$对于A \in F 我们本应将基数记为[A]_\sim ，但我们沿用上面的记号以达到统一概念的目的，记为\sharp A$</li>
</ul>
</li>
<li>可数无穷集合：与自然数等势的集合我们称为可数无穷集合，基数为  $\aleph _0 $<ul>
<li>可数集合 = 有穷集合 + 无穷可数集合，其余均是不可数集合</li>
</ul>
</li>
<li>定理：无穷集的三个等价条件<ul>
<li>A是无穷集</li>
<li>A有可数无穷的子集（证明：可以从出去已选元素的A中选择元素，因为A是无穷的，所以取之不尽，这样就构造出了一个可数无穷的子集）</li>
<li>A有真子集与它等势</li>
</ul>
</li>
<li>上文中我们提到了<a href="#jishu">单射</a>可以确定两个集合基数的大小，满射也同样可以<ul>
<li>$存在A到B的满射 \iff \sharp B \leq \sharp A $</li>
<li>证明：</li>
<li><script type="math/tex; mode=display">
    \begin{align*}
        \Rightarrow \\
        &若从A \rightarrow B有满射f，则f右可逆\\
        &存在g:B \rightarrow A，使得f \cdot g = I_B\\
        &I_B是双射，所以g是单射\\
        &\therefore \sharp B \leq \sharp A \\
        \Leftarrow \\
        &若\sharp B \leq \sharp A,则有单射g:B \rightarrow A\\
        &g左可逆，存在f:A \rightarrow B使得f \cdot g = I_B\\
        &I_B是双射,所以f是满射
    \end{align*}</script></li>
</ul>
</li>
<li>还有几个有趣的问题：<ul>
<li>$N\times N \sim N $</li>
<li>$N \sim Q $</li>
<li>$N \sim Z $<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
<li>实数集合不可数(证明：在(0,1)上构造一个无穷序列，然后利用规则，找出一个数不属于这个序列，推出矛盾，实数集合不可数)，下面我们讨论它的基数<ul>
<li>引理：对于每个集合A，皆有 $\sharp A &lt; \sharp \rho(A) $<ul>
<li>$首先，我们可以定义g(a) = \{a\}使得A\rightarrow \rho(A),显然g是单射，所以\sharp A \leq \sharp \rho(A) $</li>
<li>$然后通过反证法来证明\sharp A \neq \sharp \rho (A) $</li>
</ul>
</li>
<li>因为不可数，所以 $\sharp N \neq \sharp R $，我们定义 $\sharp R = \aleph $</li>
<li>我们可以证明：$\sharp \rho(N) = \sharp R $<ul>
<li>证明非常的精彩，利用集合的特征函数，与实数的二进制编码</li>
<li>任意给定一个实数，写出实数的二进制编码，对于编码上的每一位，为1则表示在对应的集合中</li>
<li>这样我们就得到了一个实数到一个自然数集合的双射</li>
</ul>
</li>
<li>所以 $\sharp R = \sharp \rho(N) &gt; \sharp N $，即 $\aleph &gt; \aleph_0 $</li>
</ul>
</li>
<li>有意思的问题：<ul>
<li>$\sharp (R \times R) = \aleph $  (思路：找一个特定的值域为R的二元连续函数)</li>
</ul>
</li>
</ul>
<blockquote>
<p>待完善。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>自然数</tag>
        <tag>数学归纳法</tag>
        <tag>基数</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学函数</title>
    <url>/2023/02/08/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>蒟蒻博主缓考了离散，于是开始芝士总结与复习，进度（3/5）</p>
<span id="more"></span>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>函数是一种特殊的关系，这种关系满足单值性，即从X到Y，元素x不能劈叉<ul>
<li>$即二元关系f满足：若&lt; x, y_1&gt; \in f 且 &lt; x, y_2&gt; \in f 则y_1 = y_2 $</li>
<li>这样的f我们称为X到Y的<strong>部分函数</strong></li>
<li>x叫源像点，y是像点，可记为$y=f(x) $</li>
</ul>
</li>
<li>函数的定义域与值域的定义完全照搬关系的<ul>
<li>$若x \in dom(f), 则称f在x处有定义，记为：“f(x) \downarrow” $</li>
<li>$无定义记为：“f(x) \uparrow” $</li>
</ul>
</li>
<li>注意我们上述说的都是<strong>部分函数</strong>。<ul>
<li>我们把$dom(f) = X $的函数称为<strong>全函数</strong>，简称<strong>函数</strong></li>
<li>$dom(f) \subset X的函数称为严格部分函数 $</li>
<li>$ran(f) = Y $ ，称f为X到Y<strong>上</strong>的部分函数。</li>
<li>$ran(f) \subset Y $ ，称f为X到Y<strong>内</strong>的部分函数。</li>
<li>1-1部分函数：$当f(x_1)=f(x_2)时，都有x_1=x_2 $</li>
</ul>
</li>
<li>函数的限制：<ul>
<li>$若A \subseteq X，则f\cap(A\times X)是从A到Y的函数，称为f在A上的限制，记作f|_A$</li>
<li>$又称f为f|_A到X上的延拓 $</li>
</ul>
</li>
<li>部分函数f的像与源像（f是X到Y的部分函数，$A \subseteq X 且 B \subseteq Y $）：<ul>
<li>$f[A] = \{f(x)|x \in A \wedge f(x)\downarrow \} $</li>
<li>$f^{-1}[B] = \{x \in X | f(x) \in B \wedge f(x)\downarrow \} $</li>
<li>$ dom( f ) = f ^ { -1 } [Y] ; ran(f) = f[ X ] $<ul>
<li>实际上这里的f和我们上文中的f:X-&gt;Y已经发生了变化，变成了集合到集合的关系，但不影响理解。</li>
</ul>
</li>
</ul>
</li>
<li>常用定理（不太重要，但可以看看，熟悉函数的性质）：<ul>
<li>$A_1 \subseteq A_2 \subseteq X，则f[A_1] \subseteq f[A_2] \subseteq ran(f) (f^{-1}同理)$</li>
<li>缩放定理：<ul>
<li>$A \subseteq dom(f)，则A \subseteq f^{-1}[f[A] ] $</li>
<li>$B \subseteq ran(f)，则B = f[f^{-1}[B]] $</li>
<li>(有点不对称，原因是 $\sharp dom &gt; \sharp ran $)</li>
</ul>
</li>
<li>$若A \subseteq \rho (X), B \subseteq \rho (Y) $<ul>
<li>$f[\cup A] = \cup \{f[\alpha] | \alpha \in A \} $</li>
<li>$f[\cap A] \subseteq \cap \{f[\alpha] | \alpha \in A \}(A \neq \phi) $</li>
<li>$f^{-1}[\cup B] = \cup \{f^{-1}[\beta] | \beta \in B \} $</li>
<li>$f^{-1}[\cap B] = \cap \{f^{-1}[\beta] | \beta \in B \}(B \neq \phi) $(与第2条不对称)</li>
</ul>
</li>
<li>限制定理：<ul>
<li>$dom(f|_A) = A \cap domf $</li>
<li>$ran(f|_A) = f[A] $</li>
<li>$若A \subseteq domf，则f|_A是A的全函数 $</li>
</ul>
</li>
</ul>
</li>
<li>全函数集合：<ul>
<li>$Y^X = \{f | f: X \rightarrow Y\} $</li>
<li>$每个X中的元素都可以任意选择一个Y中的元素，所以\sharp(Y^X) = (\sharp Y)^{(\sharp X)} $</li>
</ul>
</li>
</ul>
<h2 id="函数的复合"><a href="#函数的复合" class="headerlink" title="函数的复合"></a>函数的复合</h2><ul>
<li>函数是一种特殊的关系，所以函数的复合与关系的复合是一样的，我们定义$f \cdot g $为X到Z的关系<ul>
<li>但是由于我们常用f(x)的方式来表示函数，所以我们把$f \cdot g $的复合关系表示为复合函数的话，写法为$g(f(x)) = (g \cdot f)(x) $</li>
</ul>
</li>
<li>定义域与值域讨论：f是X到Y的部分函数，g是Y到z的部分函数<ul>
<li>$dom(g \cdot f) = f^-1[dom g] (ran类似)$（关系怎么证这就怎么证）</li>
<li>$f与g都是全函数，则g \cdot f也是全函数 $（由上得）</li>
</ul>
</li>
<li>结合律照样满足（关系一样）</li>
<li>$若f:X\rightarrow X, 则我们可以定义f的n次幂，f^n$(关系可以由矩阵表示，联系方阵与矩阵的n次幂定义)</li>
</ul>
<h2 id="函数的性质"><a href="#函数的性质" class="headerlink" title="函数的性质"></a>函数的性质</h2><ul>
<li>三大性质：（注意前提是全函数）<ul>
<li>满射：$f是满射 \iff \forall y(y \in Y \rightarrow \exists x(x \in X \wedge y = f(x) ) ) $</li>
<li>单射：$f是单射 \iff \forall x_1 \forall x_2(x_1 \in X \wedge x_2 \in X \wedge f(x_1) = f(x_2) \rightarrow x_1 = x_2) $</li>
<li>满射 + 单射 = 双射</li>
</ul>
</li>
<li>$若f和g都是满/单/双射时，g\cdot f也是满/单/双射 $（按定义证）</li>
<li>左满右单定理：<ul>
<li>$若g\cdot f是满射，则g是满射 $</li>
<li>$若g\cdot f是单射，则f是单射 $（反证法）</li>
<li>$若g\cdot f是双射，则\dots $</li>
<li>可以意象化的理解</li>
</ul>
</li>
</ul>
<h2 id="逆函数"><a href="#逆函数" class="headerlink" title="逆函数"></a>逆函数</h2><ul>
<li><p>还是那句话，函数是一种特殊的关系，所以函数的复合和关系的复合内容基本一致，但是函数有他的特殊性，就是单值性。所以我们如果沿用关系的逆的定义，会很麻烦，因为这样一个函数反过来不一定满足单值性，所以我们这里函数的逆明显不同于关系的逆，而更加的相像与矩阵的逆，而且复合是矩阵乘，所以在接触函数的逆的时候我们可以时刻联系矩阵运算</p>
</li>
<li><p>我们定义了左逆右逆： $若f:X \rightarrow Y $</p>
<ul>
<li>$若有g:Y \rightarrow X，使得g \cdot f = I_x，则f左可逆，g为f的左逆 $（右逆同理）</li>
<li>若有g同时为左逆和右逆，则f可逆，g为f的逆</li>
<li>左逆右逆不一定存在，也不一定唯一</li>
</ul>
</li>
<li>左右可逆的条件：<ul>
<li>$左可逆 \iff 单射 $</li>
<li>$右可逆 \iff 满射 $</li>
<li>$可逆 \iff 双射 $</li>
<li>可以用左满右单定理证出一边，用单射满射的性质构造出g来证另一边</li>
<li>而我有一种新的理解，上文说到，我们可以时刻联系矩阵运算，满射的话X范围会比Y大，单射的话Y的范围会比X要大，对应的正是行数大于列数及列数大于行数的长条形矩阵（或说行满秩与列满秩），我们也可以构造出左边的逆与右边的逆（这里的逆矩阵也是长条形，当然只是类似），注意函数的左右是反过来的，所以矩阵的左乘和右乘的最后要在名称上称为右逆和左逆。（我这里不再细说，感兴趣欢迎来讨论）</li>
</ul>
</li>
<li>$若f可逆，则f的逆唯一，且f的逆关系f^{-1}即为f的逆函数 $<ul>
<li>唯一性证明：$g_1 = g_1 \cdot I_Y = g_1 \cdot (f \cdot g_2) = I_X \cdot g_2 = g_2 $</li>
<li>关于 $f^{-1} $是f的逆函数：证明不难，但是我们注意到，$f^{-1} $的矩阵表示为f的矩阵的转置，而不是矩阵的逆，这里主要是由于关系复合的乘法与真正的矩阵乘是有差别的，但是我们可以类比单位阵的意味，这里的矩阵可逆是正交的。</li>
</ul>
</li>
<li>可逆与复合的交换：$f可逆，g可逆，则g \cdot f可逆，且(g \cdot f )^{-1} = f^{-1} \cdot g^{-1} $<ul>
<li>证：$(g \cdot f) \cdot (f^{-1} \cdot g^{-1}) = I_X(左乘同理) $</li>
</ul>
</li>
</ul>
<h2 id="集合的特征函数"><a href="#集合的特征函数" class="headerlink" title="集合的特征函数"></a>集合的特征函数</h2><ul>
<li>特征函数全集映射到{0,1}上，原理很简单，但是可以简化很多逻辑表达式的计算问题，但是要真正派上大用场得等到下一节-基数。</li>
<li>定义：设U是全集，A是U的子集<ul>
<li>$定义A的特征函数\Psi_A:U\rightarrow \{0,1\} $<script type="math/tex; mode=display">
\Psi_A(x)=
\begin{cases}
1 \quad 若x \in A \\\\
0 \quad 若x \notin A
\end{cases}</script></li>
</ul>
</li>
<li>性质：<ul>
<li>$\forall x(\Psi_A(x) = 0) \iff A = \phi $</li>
<li>$A = U \iff \dots $</li>
<li>$\forall x(\Psi_A(x) \leq \Psi_B) \iff A \subseteq B $</li>
<li>$A = B \iff \dots $</li>
<li>$\Psi_{A \cap B} = \Psi_A \cdot \Psi_B $</li>
<li>$\Psi_{A \cup B} = \Psi_A + \Psi_B - \Psi_{A \cap B} $</li>
<li>$\Psi_{\sim A} = 1 - \Psi_A $</li>
<li>$\Psi_{A - B} = \Psi_{A \cap \sim B} = \dots $</li>
</ul>
</li>
<li>证明俩逻辑表达式相等可以转化为证明特征函数相等</li>
</ul>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学关系</title>
    <url>/2023/02/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>蒟蒻博主缓考了离散，于是开始芝士总结与复习，进度（2/5）</p>
<span id="more"></span>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><h3 id="关系定义"><a href="#关系定义" class="headerlink" title="关系定义"></a>关系定义</h3><ul>
<li>关系：我们知道关系就是两个事物之间的联系，抽象一下，具体是啥关系不重要，哪两个东西在一起很重要。所以我们定义如下：<ul>
<li>$若集合R \subseteq X\times Y ，则称R是X到Y的二元关系，简称关系。$</li>
<li>若R是X到X的关系，也称R是X上的二元关系。</li>
<li>$我们可以把&lt; x , y &gt;\in R 记作xRy $</li>
<li>$&lt; x , y &gt;\notin R记作x\bar Ry $</li>
</ul>
</li>
<li>特殊情况：<ul>
<li>$R = \phi，称为空关系 $</li>
<li>$R = U_X(U_X = X\times X)，称为全域关系 $</li>
<li>$R = I_X(I_X = \{&lt; x , x &gt;| x \in X \})，称为恒等关系 $</li>
</ul>
</li>
<li>定义域(domain)/值域(range)：<ul>
<li>$dom(R) = \{x \in X | \exists y \in Y : &lt; x , y &gt; \in R \}, dom(R) \subseteq X $</li>
<li>$ran(R) = \{y \in Y | \exists x \in X : &lt; x,y&gt; \in R \}, ran(R) \subseteq Y $</li>
<li>后面这种类似的东西我都只写一个，另一个类比</li>
</ul>
</li>
<li>矩阵/关系图表示：<ul>
<li>用矩阵和图的方式来表示一个关系（DS课学过图和矩阵表示方法，很像）<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="关系性质"><a href="#关系性质" class="headerlink" title="关系性质"></a>关系性质</h3><ul>
<li>五个性质：记住他们的定义、矩阵的特征、图的特征</li>
<li>这些性质的前提是R为非空集合X上的关系</li>
<li>定义<ul>
<li>自反：$R满足 \forall x (x \in X \rightarrow &lt; x,x&gt; \in R) $</li>
<li>反自反：$R满足 \forall x (x \in X \rightarrow &lt; x,x&gt; \notin R) $</li>
<li>对称：$R满足 \forall x \forall y (x \in X \wedge y \in X \wedge xRy \rightarrow yRx) $</li>
<li>反对称：$R满足 \forall x \forall y (x \in X \wedge y \in X \wedge xRy \wedge x \neq y \rightarrow y \bar Rx)  $</li>
<li>传递：$R满足 \forall x \forall y \forall z(x \in X \wedge y \in X \wedge z \in X \wedge xRy \wedge yRz \rightarrow xRz) $</li>
<li>例：恒等关系是自反、对称、传递的；“&lt;”关系是反自反、反对称、传递的。</li>
</ul>
</li>
<li>矩阵与图的特征<ul>
<li>见图：<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li>关于$\cup、\cap、-、\sim、\oplus $等运算，关系就是二元序偶集的一种，可以照搬运算。</li>
<li>有三大新运算：复合、逆（注意与取反区分）、闭包</li>
</ul>
<h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><ul>
<li>定义：R为X到Y的关系，S是Y到Z的关系<ul>
<li>$则R\cdot S = \{&lt; x,z&gt; | \exists y \in Y: xRy \wedge ySz \} $</li>
<li>运算不满足交换律，但满足结合律。</li>
</ul>
</li>
<li>复合的矩阵表示就是俩矩阵相乘（），细想一下逻辑完全符合</li>
<li>性质：<ul>
<li><script type="math/tex; mode=display">
> ...</script></li>
</ul>
</li>
<li>复合运算的定义域与值域讨论：<ul>
<li>我们把关系作用于集合，定义为：<ul>
<li>$R是X到Y的集合，R[A] = \{y \in Y | \exists x \in A: &lt; x,y&gt; \in R \}, R^{-1}同理 $</li>
</ul>
</li>
<li>所以我们易证：<ul>
<li>$dom(R \cdot S) = R^{-1}[domS], ran(R \cdot S) = R[ranR] $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逆关系"><a href="#逆关系" class="headerlink" title="逆关系"></a>逆关系</h3><ul>
<li>定义：记作$R^{-1} $<ul>
<li>关系中的每个有序偶的第一元与第二元对换</li>
<li>在矩阵上表现为原矩阵的转置$M_R^T $</li>
<li>关系图上表示为每一条边反向</li>
</ul>
</li>
<li>注意与$\sim R $区分</li>
</ul>
<h3 id="关系五大性质对应的判断条件"><a href="#关系五大性质对应的判断条件" class="headerlink" title="关系五大性质对应的判断条件"></a>关系五大性质对应的判断条件</h3><ul>
<li>R是A上的二元关系<ul>
<li>$R是自反的 \iff I_A \subseteq R $</li>
<li>$R是反自反的 \iff I_A \nsubseteq R (I_A \cap R = \phi) $</li>
<li>$R是对称的 \iff R^{-1} = R $</li>
<li>$R是反对称的 \iff R^{-1} \cap R \subseteq I_A $</li>
<li>$R是传递的 \iff R \cdot R \subseteq R $</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>自反，对称，传递关系都是极大的条件，也就是说，任何一个关系，我都可以通过增加元素，使得其满足这三个性质。而反自反与反对称不行，所以诞生了闭包的运算，也就是通过添加元素，使得关系满足这三个性质形成的最小关系。</li>
<li>定义：关系R’为R的自反（对称、传递）闭包(它们都为A上的关系)，当且仅当满足：<ul>
<li>$R’是自反的 $</li>
<li>$R \subseteq R’ $</li>
<li>$对于A上的任何一个自反（对称、传递）的关系R’’，R \subseteq R’’ \rightarrow R’ \subseteq R’’(可以看作是一种极小化,这一条称为闭包的最小性) $</li>
<li>R的自反、对称、传递闭包分别记作：r(R),s(R),t(R)</li>
</ul>
</li>
<li>由定义可知：<ul>
<li>R是自反（对称、传递）的，当且仅当R = r/s/t(R)</li>
</ul>
</li>
<li>R的三大闭包的存在性与唯一性证明：<ul>
<li>$r(R) = R \cup I_A $</li>
<li>$s(R) = R \cup R^{-1} $</li>
<li>$t(R) = \cup_{n=1}^\infty R^n $</li>
<li>证明都非常的有意思，s(R)的证明直接通过定义，r/t的证明可以证明等式两边相互包含。</li>
</ul>
</li>
<li>传递闭包缩小定理：对于有限集A，A中有n个元素，则 $t(R) = \cup_{i=0}^n R^i $<ul>
<li>可证：$对于任意k &gt; 0 都有R^{n+k} \subseteq \cup_{i=0}^n R^i $</li>
</ul>
</li>
<li>性质：<ul>
<li>闭包运算不破坏包含序关系，即：$若R_1 \subseteq R_2 ，则r/s/t(R_1) \subseteq r/s/t(R_2) $</li>
<li>闭包运算也基本不破坏R本身的三大性质，除s(R)会破坏R的传递性（即R传递，s(R)不一定传递，这是一大不对称因素）</li>
<li>所以性质2导致s与t运算不可逆 $（st(R) 不一定= ts(R) 但 st(R) \subseteq ts(R) ） $</li>
<li>尝试证明<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="序关系"><a href="#序关系" class="headerlink" title="序关系"></a>序关系</h2><ul>
<li>序关系有偏序关系，严格偏序关系（拟序关系），全序关系，良序关系</li>
</ul>
<h3 id="序关系定义"><a href="#序关系定义" class="headerlink" title="序关系定义"></a>序关系定义</h3><ul>
<li>偏序：R满足自反，反对称，传递三个性质，则R是A上的偏序关系，用&lt; A , &lt;= &gt;表示偏序结构</li>
<li>严格偏序：是自反改为反自反的偏序，就是说一定要比出个高低。<ul>
<li>但我们发现由反自反与传递可以推出反对称（可以使用反证法，假设关系不是反对称，则一定能推出&lt; x , x &gt;的元素），所以我们定义只需反自反、传递就行。</li>
<li>严格偏序和偏序有如下关系：$&lt; = \leq - I_A $</li>
</ul>
</li>
<li>全序：若&lt; A , &lt;= &gt;是偏序结构<ul>
<li>$\forall x,y \in A \rightarrow x &lt;= y \vee y &lt;= x ,则称&lt; A , &lt;= &gt;全序结构或者链$（也就是说任意两元素都是可比的）</li>
</ul>
</li>
</ul>
<h3 id="覆盖与哈斯图"><a href="#覆盖与哈斯图" class="headerlink" title="覆盖与哈斯图"></a>覆盖与哈斯图</h3><ul>
<li>由于序关系是传递的，所以我们能够简化关系图，即若x &lt; y, y &lt; z, 则我再图中只画出这两条线，因为x，z之间的关系显而易见，然后偏序关系中的自反关系在图中省略，即不画自圈，就得到了哈斯图。而我们要描述两个元素之间的关系，就需要看它们之间是否夹着不上不下的元素，没有的话这两个元素看上去在我们的序关系中是相邻的，我们称之为覆盖。</li>
<li>覆盖：$y覆盖x \Leftrightarrow x &lt; y \wedge \neg \exists z(z \in A \wedge x &lt; z \wedge z &lt; y) $</li>
</ul>
<h3 id="偏序结构中的特殊元素"><a href="#偏序结构中的特殊元素" class="headerlink" title="偏序结构中的特殊元素"></a>偏序结构中的特殊元素</h3><ul>
<li>前提：$<A, \leq>是偏序结构，B \subseteq A $<ul>
<li>极大元：$b是B的极大元 \Leftrightarrow b \in B \wedge \forall x(x \in B \rightarrow x \leq b) $</li>
<li>最大元：$b是B的最大元 \Leftrightarrow b \in B \wedge \neg \exists x(x \in B \wedge x \leq b) $</li>
</ul>
</A,></li>
<li>极大与最大的区别：极大是没比我大，最大是比啥都大，根源在于不是所有的元素之间都可比。</li>
<li>极小与最小同理。</li>
</ul>
<hr>
<ul>
<li>上界：$b是B的上界 \Leftrightarrow b \in A \wedge \forall x(x \in B \rightarrow x \leq b) $</li>
<li>最小上界：$b是B的最小上界 \Leftrightarrow b是B的上界 \wedge \forall x(x是B的上界 \rightarrow b \leq x) $</li>
<li>下界与最大下界同理。</li>
<li>一定要注意并不是所有元素之间都可以比较，所以可能上下界和最大最小元不存在</li>
</ul>
<h3 id="良序结构"><a href="#良序结构" class="headerlink" title="良序结构"></a>良序结构</h3><ul>
<li>定义：若一个偏序结构的每个非空子集都有<strong>最小元</strong>，则该结构为良序结构。</li>
<li>所以良序一定是全序，因为对于任意两个元素，我们都可以当作非空子集拎出来，然后它们俩必有一个最小元。<ul>
<li>但是全序并不一定是良序，因为可能存在一个无穷递降的序列，使得没有最小元。</li>
<li>所以我们可证：良序 $\Leftrightarrow $ 没有无穷递降序列的全序。</li>
</ul>
</li>
<li>又：全序关系中，任何非空子集的极小元与最小元等价，所以也可以表述上互换。</li>
</ul>
<h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><ul>
<li>等价关系满足：自反，对称，传递（模m同余的关系就是典型的等价关系）</li>
<li>由于传递性，我能用等价关系确定一个集合，叫等价类。<ul>
<li>A中与x有等价关系R的元素的集合，为x关于R的等价类，记作：$[x]_R $</li>
<li>$[x]_R = \{y | y \in A \wedge xRy \}$</li>
</ul>
</li>
<li>性质：等价关系与等价类满足下列性质<ul>
<li>$[x]_R = [y]_R \Leftrightarrow xRy $(传递性证)</li>
<li>$x,y \in A\wedge x\bar Ry \rightarrow [x]_R \cap [y]_R = \phi $（反证法）</li>
<li>$\cup_{x \in A}[x]_R = A $(全覆盖定理，$x \in [x]_R $可证)</li>
</ul>
</li>
<li>商集：A上关于R的所有等价类的集合，记作A/R</li>
<li>划分: $对于A，若有\pi \subseteq \rho(A), 且\pi 满足三个条件，则称\pi 为A的划分 $<ul>
<li>$\forall S \in \pi, S \neq \phi $</li>
<li>$\forall B,C \in \pi, 若B \neq C 则B \cap C = \phi $</li>
<li>$\cup \pi = A $</li>
<li>$\pi 中元素为划分块， \sharp \pi 称作$ <strong>秩</strong></li>
</ul>
</li>
<li>由上我们可以知道A上的每个等价关系唯一确定的商集就是一个划分</li>
<li>$由A上的划分\pi 我们令R_\pi = \{&lt; x,y&gt; | \exists S \in \pi (x,y \in S) \},我们可以唯一确定一个等价关系R_\pi，且A/R_\pi = \pi $</li>
</ul>
<blockquote>
<p>待完善。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>关系</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p7流水线CPU-Ultra</title>
    <url>/2022/12/03/BUAA-CO-p7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU-Ultra/</url>
    <content><![CDATA[<p>BUAA-CO课程p7，将之前完成的CPU封装，完成一个MIPS的微系统，能够实现异常与中断。</p>
<span id="more"></span>
<h1 id="p7-log"><a href="#p7-log" class="headerlink" title="p7_log"></a>p7_log</h1><blockquote>
<p>p7需要我们把p6设计的流水线CPU封装，并连接上一系列的外设，完成一个MIPS的微系统，能够实现异常和中断<br>所以我们要实现以下工作：<br>p6流水线的设计见p6文档，在这我们，把CPU留下接口后可以忽略他的内部的实现细节。<br>实现CP0协寄存器，异常和中断<br>实现系统桥，连接DM，Timer等外设</p>
</blockquote>
<h2 id="设计思路-纲领"><a href="#设计思路-纲领" class="headerlink" title="设计思路-纲领"></a>设计思路-纲领</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>实现计时器</li>
<li>实现系统桥</li>
<li>实现CP0</li>
<li>改进CPU的内部结构，使其拥有检测内部异常，响应外部中断，实现异常指令</li>
<li>通过Mars编写异常处理程序</li>
<li>测试</li>
</ul>
<h3 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h3><ul>
<li>对于指令的分类很重要</li>
<li>下面是所需要是实现的指令类和指令</li>
<li>寄存器寄存器计算：add, sub, and, or, slt, sltu,  xor</li>
<li>寄存器立即数计算：addi, andi, ori, slti, xori</li>
<li>位移类： sll, srl, sra, sllv, srlv, srav</li>
<li>B类：beq, bne</li>
<li>store：sw, sh, sb</li>
<li><p>load：lw, lh, lhu, lb, lbu</p>
</li>
<li><p>跳转并链接：jal, jalr, j</p>
</li>
<li>跳转寄存器：jr, jalr</li>
<li>加载高位：lui</li>
<li>空指令：nop</li>
<li>读乘除法寄存器：mfhi, mflo</li>
<li><p>写乘除法寄存器：mult, multu, div, divu, mthi, mtlo</p>
</li>
<li><p>p5要求实现的基础指令有：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</p>
</li>
<li>p7在p6的基础上新增的指令：mfc0, mtc0, eret, syscall</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>在控制信号连线名末尾加上_阶段字母，如：NPCOp_D，用以区分所属阶段</li>
<li>在寄存器输出信号前加上阶段字母_, 如：D_A1,用以区分所属阶段</li>
<li>功能部件输出信号前加上功能部件.，（实际打码时舍弃）</li>
<li>MUX命名采取X_输入端口名_选择数</li>
<li>转发MUX命名采用F_输入端口名_选择数，级数越大优先级越高</li>
<li>内部异常信号，用EXC_异常类型_阶段</li>
<li>接口名清晰易懂</li>
</ul>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="Timer1-Timer2"><a href="#Timer1-Timer2" class="headerlink" title="Timer1/Timer2"></a>Timer1/Timer2</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">addr[31:2]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer写入地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer写使能</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Din[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer写入数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Dout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">Timer读取的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">IRQ</td>
<td style="text-align:center">O</td>
<td style="text-align:left">interupte require</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A_cpu[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读取or写入外设的地址</td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">WD_cpu[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入外设的数据</td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">ByteEn[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写外设的字节使能</td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">DM_RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM读取值</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">T0_RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">T0读取值</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">T1_RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">T1读取值</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">A_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">WD_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">RD_in[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">外设读入至CPU</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">DMWE[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM写使能</td>
<td style="text-align:left">由byteen与地址决定</td>
</tr>
<tr>
<td style="text-align:center">T0WE</td>
<td style="text-align:center">O</td>
<td style="text-align:left">T0写使能</td>
<td style="text-align:left">同上</td>
</tr>
<tr>
<td style="text-align:center">T1WE</td>
<td style="text-align:center">O</td>
<td style="text-align:left">T1写使能</td>
<td style="text-align:left">同上</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CP0协寄存器"><a href="#CP0协寄存器" class="headerlink" title="CP0协寄存器"></a>CP0协寄存器</h3><ul>
<li>内置在CPU M级中，用于获取外部中断和内部异常的信息，并发送异常/中断请求。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">addr_R[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mfc0读CP0的编号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">CPWE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mtc0写使能</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">addr_W[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mtc0写CP0的编号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mtc0写CP0的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">M_PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">中断异常产生时的M_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ExcCode[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">产生中断异常的类型</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">BD_M</td>
<td style="text-align:center">I</td>
<td style="text-align:left">branch delay分支延迟槽</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">HWInt[7:2]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">六个设备的中断标志</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">EXL_clr</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Eret_M用于将SR的EXL置零</td>
<td style="text-align:left">表示退出中断异常</td>
</tr>
<tr>
<td style="text-align:center">EIrequire</td>
<td style="text-align:center">O</td>
<td style="text-align:left">异常/中断请求</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">EPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出EPC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">mfc0读CP0的数据</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">i_inst_rdata[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">从IM读取的指令</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_rdata[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">从DM读取的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Int_put</td>
<td style="text-align:center">I</td>
<td style="text-align:left">外部中断的信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Int_T0</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer0输入的中断信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Int_T1</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer1输入的中断信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">i_inst_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">F_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_inst_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">M_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM的读取or写入地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_wdata[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DMWD</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_byteen[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM的字节使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_inst_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">W_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_grf_we</td>
<td style="text-align:center">O</td>
<td style="text-align:left">RFWE_W</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_grf_addr[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">W_A3</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_grf_wdata[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">RFWD/Wout</td>
</tr>
</tbody>
</table>
</div>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="内部异常"><a href="#内部异常" class="headerlink" title="内部异常"></a>内部异常</h3><ul>
<li>每一级的异常进流水，已有异常的话按原异常流水（优先级）</li>
<li>在ExcCode_fixE的时候给overflow+上RFWE的判别</li>
<li>响应异常时需要做下面几件事：<ul>
<li>清空：EMW寄存器响应Req，清空寄存器(注意处理PC，同stall情况)</li>
</ul>
</li>
</ul>
<h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><ul>
<li>外部中断的优先级大于内部异常</li>
</ul>
<h3 id="Mars异常程序"><a href="#Mars异常程序" class="headerlink" title="Mars异常程序"></a>Mars异常程序</h3><ul>
<li><code>.ktext 4180</code>将异常处理程序写在4180处</li>
<li>注意处理中断时需要<code>sb $27,0x7f20($0)</code>响应异常</li>
</ul>
<h2 id="测试数据及自动化测试"><a href="#测试数据及自动化测试" class="headerlink" title="测试数据及自动化测试"></a>测试数据及自动化测试</h2><ul>
<li>测试要将各种异常覆盖到</li>
<li>同时注意尽可能多的中断情况</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><ul>
<li>自动化测试上我实现了机器码的生成（不足1120行补零）</li>
<li>实现了格式的统一，去掉时间输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">command = <span class="string">&quot;java -jar Mars.jar db nc mc CompactDataAtZero a dump .text HexText testcode/testcode.txt testcode/test.asm&quot;</span></span><br><span class="line">os.system(command=command)</span><br><span class="line">command = <span class="string">&quot;java -jar Mars.jar db nc mc CompactDataAtZero a dump 0x4180-0x6ffc HexText testcode/handlerCode.txt testcode/test.asm&quot;</span></span><br><span class="line">os.system(command=command)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&quot;testcode/testcode.txt&quot;</span>) <span class="keyword">as</span> testcode:</span><br><span class="line">    test = testcode.read()</span><br><span class="line">    line = test.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&quot;testcode/handlerCode.txt&quot;</span>) <span class="keyword">as</span> handlerCode:</span><br><span class="line">    handler = handlerCode.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&quot;testcode/code.txt&quot;</span>, mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> code:</span><br><span class="line">    code.write(test)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1120</span>-line):</span><br><span class="line">        code.write(<span class="string">&quot;00000000\n&quot;</span>)</span><br><span class="line">    code.write(handler)</span><br></pre></td></tr></table></figure>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p>
<ul>
<li>鼠标和键盘产生中断信号，进入中断处理程序，在中断处理程序中，鼠标和键盘输入信号</li>
</ul>
<p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p>
<ul>
<li>若自定义入口地址，则很多软件将会不兼容，在程序员视角设计软件的时候，中断处理的入口地址是不重要的，也就是说这是软件和硬件之间的协议。</li>
</ul>
<p>3、为何与外设通信需要 Bridge？</p>
<ul>
<li>外设的种类是繁多，我们通过bridge并且约定某段内存地址对应于某个外设，这样我们就只需要通过访存去实现与外设的联系，指令集会比较的简洁。添加外设时，外设也只需要体现在入口地址的不同而不需要改变CPU的内部结构，让CPU访问外设只需通过地址，这样也是体现了”高内聚，低耦合”的原则。</li>
</ul>
<p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p>
<ul>
<li>两种中断，模式0为定时中断，模式1为周期性中断。区别在于倒计时达到0之后的状态。</li>
<li><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p7/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.jpg" alt="状态转移"></li>
</ul>
<p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p>
<ul>
<li>写入EPC会出错，延迟槽标记信号也会出错。</li>
<li>如果是中断或者异常而清空流水线，应该保持原有的PC值，以保证宏观PC的正确。</li>
<li>如果是阻塞而清空流水线，应该要保持原有的PC并且保持原有的BD标志信号。</li>
</ul>
<p>6、为什么 jalr 指令为什么不能写成 jalr $31, $31？</p>
<ul>
<li>这种操作具有二义性，不知道先跳转还是先链接</li>
<li>指令集要求。寄存器说明符 rs 和 rd 不得相等，因为此类指令在重新执行时不具有相同的效果。执行此类指令的结果是不可预测的。此限制允许异常处理程序在分支延迟槽中发生异常时通过重新执行分支来恢复执行。</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P7</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p6流水线CPU-pro</title>
    <url>/2022/11/24/BUAA-CO-p6%E6%B5%81%E6%B0%B4%E7%BA%BFCPU-pro/</url>
    <content><![CDATA[<p>BUAA-CO课程p6，在p5的基础上，增加一些基础指令，IM、DM外置，增加乘除模块等</p>
<span id="more"></span>
<h1 id="p6-log"><a href="#p6-log" class="headerlink" title="p6_log"></a>p6_log</h1><blockquote>
<p>p6在p5的基础上进行改进，除了加指令外，有几点改动<br>通过output传出相应信号不再使用$display<br>IM，DM外置只留下相应接口<br>但需要实现单独的乘除法模块和数据拓展模块</p>
</blockquote>
<h2 id="设计思路-纲领"><a href="#设计思路-纲领" class="headerlink" title="设计思路-纲领"></a>设计思路-纲领</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>我们先通过对于RTL构造出无需转发的数据通路表</li>
<li>在考虑转发的情况构造出转发的数据通路</li>
<li><p>搭建电路（图文结合）</p>
</li>
<li><p>然后逐条指令分析主控制器控制信号</p>
</li>
<li>逐条指令分析 $T_{use}, T_{new} $</li>
<li>构造策略矩阵</li>
<li><p>写控制表达式</p>
</li>
<li><p>这是一个自下而上的过程</p>
</li>
<li>可以先实现p5所需的基础指令</li>
<li><p>然后对于MIPS-C3架构指令集增量开发</p>
</li>
<li><p>最后构建自动化测试与样例生成器</p>
</li>
</ul>
<h3 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h3><ul>
<li>对于指令的分类很重要</li>
<li>下面是所需要是实现的指令类和指令</li>
<li>寄存器寄存器计算：add, sub, and, or, slt, sltu,  xor</li>
<li>寄存器立即数计算：addi, andi, ori, slti, xori</li>
<li>位移类： sll, srl, sra, sllv, srlv, srav</li>
<li>B类：beq, bne</li>
<li>store：sw, sh, sb</li>
<li><p>load：lw, lh, lhu, lb, lbu</p>
</li>
<li><p>跳转并链接：jal, jalr, j</p>
</li>
<li>跳转寄存器：jr, jalr</li>
<li>加载高位：lui</li>
<li>空指令：nop</li>
<li>读乘除法寄存器：mfhi, mflo</li>
<li><p>写乘除法寄存器：mult, multu, div, divu, mthi, mtlo</p>
</li>
<li><p>p5要求实现的基础指令有：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</p>
</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>在控制信号连线名末尾加上_阶段字母，如：NPCOp_D，用以区分所属阶段</li>
<li>在寄存器输出信号前加上阶段字母_, 如：D_A1,用以区分所属阶段</li>
<li>功能部件输出信号前加上功能部件.，（实际打码时舍弃）</li>
<li>MUX命名采取X_输入端口名_选择数</li>
<li>转发MUX命名采用F_输入端口名_选择数，级数越大优先级越高</li>
</ul>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><h4 id="数据通路表"><a href="#数据通路表" class="headerlink" title="数据通路表"></a>数据通路表</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%A1%A8.jpg" alt="数据通路表"></p>
<h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><h5 id="IFU-PC-IM"><a href="#IFU-PC-IM" class="headerlink" title="IFU(PC\IM)"></a>IFU(PC\IM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能</td>
<td style="text-align:left">暂停时使用</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">由NPC返回，下一条指令的PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前执行的指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h5><ul>
<li>内部转发</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A1地址寄存器中的值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A2地址寄存器中的值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D1[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D2[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">CMPOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">CMP功能选择：&lt;/br&gt; 000: beq &lt;/br&gt; 001: bne &lt;/br&gt; 010: blez &lt;/br&gt; 011: bgtz</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">O</td>
<td style="text-align:left">结果为1则分支跳转，为0不跳转</td>
</tr>
</tbody>
</table>
</div>
<h5 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前指令地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Simm26[25:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">地址偏移</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">返回地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">CmpOut</td>
<td style="text-align:center">I</td>
<td style="text-align:left">B类指令的比较结果</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：&lt;/br&gt; 000: 顺序+4 &lt;/br&gt; 001: B类跳转 &lt;/br&gt;010: jal/j &lt;/br&gt; 011:jr/jalr</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">下一条指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">imm16[15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">16位立即数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">EXTOp</td>
<td style="text-align:center">I</td>
<td style="text-align:left">EXT功能选择：&lt;/br&gt; 0: 0拓展 &lt;/br&gt; 1: 符号位拓展</td>
<td style="text-align:left">lui指令的高位拓展在ALU里执行</td>
</tr>
<tr>
<td style="text-align:center">S0imm32</td>
<td style="text-align:center">O</td>
<td style="text-align:left">拓展后的32位立即数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">ALU功能选择</td>
<td style="text-align:left">具体对于功能后有附录</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">位移值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ALUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">计算结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="MDU-乘除模块"><a href="#MDU-乘除模块" class="headerlink" title="MDU(乘除模块)"></a>MDU(乘除模块)</h5><ul>
<li>给M，W级的out中加上MDUout</li>
<li>busy阻塞实现：将busy和start_E，MDUOP_D接入HCU</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">start</td>
<td style="text-align:center">I</td>
<td style="text-align:left">开始运算信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">MDUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">乘除模块功能选择信号</td>
<td style="text-align:left">见附录</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Busy</td>
<td style="text-align:center">O</td>
<td style="text-align:left">乘除法延迟符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">HI[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">HI寄存器输出值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">LO[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">LO寄存器输出值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">MDUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">MDU输出(HI \</td>
<td style="text-align:left">LO)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>功能选择信号定义</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">MDUOp[3:0]</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0000</td>
<td style="text-align:center">nop(相当于不使能)</td>
</tr>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">mult</td>
</tr>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">multu</td>
</tr>
<tr>
<td style="text-align:center">0011</td>
<td style="text-align:center">div</td>
</tr>
<tr>
<td style="text-align:center">0100</td>
<td style="text-align:center">divu</td>
</tr>
<tr>
<td style="text-align:center">0101</td>
<td style="text-align:center">mfhi</td>
</tr>
<tr>
<td style="text-align:center">0110</td>
<td style="text-align:center">mflo</td>
</tr>
<tr>
<td style="text-align:center">0111</td>
<td style="text-align:center">mthi</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">mtlo</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待操作数据的地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待写入的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">DMout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出的32位数据</td>
</tr>
</tbody>
</table>
</div>
<h5 id="BE"><a href="#BE" class="headerlink" title="BE"></a>BE</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM写入地址</td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">原始待写入数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ByteEn[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">字节使能</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">处理后写入数据</td>
<td style="text-align:left">移动到相应的位置上，比如存入字节则8位以上全置位0</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DE"><a href="#DE" class="headerlink" title="DE"></a>DE</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM读出地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待处理DM读出数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位1表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">RD_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">处理后DM读出数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h4><ul>
<li>每个流水线寄存器都保存着一条指令完成后续操作所需要的的全部信息。</li>
<li>对于每一个流水线的产生结果的级次，我需要用一个MUX来确定哪个是当前指令的用于转发的有效数据，PC+8， ALUout，DMout，所以我们增加outSel的选择信号，此选择信号可以代替RFWDSel的功能</li>
</ul>
<h5 id="D-IF-ID"><a href="#D-IF-ID" class="headerlink" title="D(IF/ID)"></a>D(IF/ID)</h5><ul>
<li>可以在D级内置Splitter</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">暂停时置位0</td>
</tr>
<tr>
<td style="text-align:center">F_instr[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级取出的指令</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">F_PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级输出的指令PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_opcode[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前D级的opcode</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_rs[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rs</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_rt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_rd[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rd</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_shamt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">偏移量，位移指令使用</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_funct[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">funtion码</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_imm16[15:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">16位立即数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_address[25:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">26位地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D级当前指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="E-ID-EX"><a href="#E-ID-EX" class="headerlink" title="E(ID/EX)"></a>E(ID/EX)</h5><ul>
<li>从E级开始流水控制信号</li>
<li>T_new-1</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
<td style="text-align:left">暂停时置为1</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A1</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_shamt</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_S0imm32</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_shamt</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_S0imm32</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_E[3:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">BSel_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="M-EX-MEM"><a href="#M-EX-MEM" class="headerlink" title="M(EX/MEM)"></a>M(EX/MEM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_M[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="W-MEM-WB"><a href="#W-MEM-WB" class="headerlink" title="W(MEM/WB)"></a>W(MEM/WB)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_DR</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[4:0] W_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_DR</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_W</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h3 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h3><ul>
<li>此CPU采用集中译码的方式，在D级译码，控制信号进入流水，使用过的就不用进入了</li>
<li>T_new产生后随着流水线递减</li>
<li>分为MCU，HCU</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E8%A1%A8.jpg" alt="控制信号表"></p>
<h4 id="主控制器（MCU）"><a href="#主控制器（MCU）" class="headerlink" title="主控制器（MCU）"></a>主控制器（MCU）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">opcode[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_opcode</td>
</tr>
<tr>
<td style="text-align:center">funct[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_funct</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">NPCOp_D[2:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DEXTOp_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">imm26Sel_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DA3Sel_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left">E_ALU_B信号选择：{}</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">outSel_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">有效转发数据Sel</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MDUOp_D[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">start_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令用到rs寄存器所剩下的时间</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令产生结果所需的时间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>MUX控制信号的具体含义可以看数据通路表</li>
</ul>
<h4 id="冒险控制器（HCU）"><a href="#冒险控制器（HCU）" class="headerlink" title="冒险控制器（HCU）"></a>冒险控制器（HCU）</h4><ul>
<li>空行表示逻辑与功能上的分割</li>
<li>我这里只需要D级输出T_use因为我只有stall需要用到T_use，而stall应只在D级就决定，转发只需判断Tnew==0</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D_A1[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">D_A2[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A1[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">E_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">W_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Busy</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">MDUOp[3:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">start_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFRD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">NPC读入RA的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD1的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD2的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_A的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_B的转发</td>
</tr>
<tr>
<td style="text-align:center">DMV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM_WD的转发</td>
</tr>
<tr>
<td style="text-align:center">stall</td>
<td style="text-align:center">O</td>
<td style="text-align:left">暂停信号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Sel结尾代表常规MUX信号，Fwd结尾代表转发MUX信号</li>
<li>转发MUX的Sel的含义大致是数字越大优先级越高，优先级是E、M、W</li>
</ul>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><ul>
<li>写好对应的BE、DE</li>
</ul>
<h3 id="跳转分支指令"><a href="#跳转分支指令" class="headerlink" title="跳转分支指令"></a>跳转分支指令</h3><ul>
<li>要特别注意PC+8的转发问题，当检测到jal时转发</li>
<li>因为我是统一NPC模块，提供npc接口，所以NPC模块的pc输入得是F级的pc</li>
<li>所以要注意beq生效的时候接入的是下一条的pc，所以应该是<code>PC+Simm32</code>而不用+4。</li>
</ul>
<h3 id="乘除指令"><a href="#乘除指令" class="headerlink" title="乘除指令"></a>乘除指令</h3><ul>
<li>MDU的AB端口都接入F_ALUV1，F_ALUV2(与ALU一致)</li>
<li>传入MDUOp判断指令</li>
<li>实现方法是在cnt结束之前一直用64位的tmp寄存器保存结果</li>
<li>除cnt—，和BusyReg置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li>
</ul>
<h3 id="冒险处理"><a href="#冒险处理" class="headerlink" title="冒险处理"></a>冒险处理</h3><ul>
<li>先根据每一条指令，整理其Tuse，Tnew</li>
<li><p>整理出指令的时间表<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%8C%87%E4%BB%A4%E6%97%B6%E9%97%B4%E8%A1%A8.jpg" alt="指令时间表"></p>
</li>
<li><p>再根据每条指令的时间列出转发暂停控制信号表<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E5%86%B2%E7%AA%81%E6%8E%A7%E5%88%B6%E8%A1%A8.jpg" alt="冲突控制表"></p>
</li>
</ul>
<h4 id="转发策略"><a href="#转发策略" class="headerlink" title="转发策略"></a>转发策略</h4><ul>
<li>遵循暴力转发策略，在打好常规的数据通路表后，观察哪些端口需要用到寄存器值（需求者），再把所有的供给者的情况遍历出来</li>
<li>可以适当增加转发条件，如T_new = 0</li>
<li>AT法: 需求者是需要用这个值来运算的，找到所有与V，RD相关的端口；供给者是需要这个值来存入的，考虑它啥时候能够算出来。</li>
<li>我们把RFWE放入HCU用以保证写使能信号有效（有效数据）</li>
<li>判断A3!=0</li>
<li>转发要素：<ul>
<li>(A1(2) = A3)?</li>
<li>$T_{new} = 0 $ ?</li>
<li>RFWE = 1 ?</li>
<li>A3 != 0 ?</li>
</ul>
</li>
<li>转发机制：结果出来后都转发，只需改变控制信号。</li>
<li>代码如下：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> CMPD1Fwd = ((D_A1 == E_A3) &amp; (T_new_E == <span class="number">0</span>) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>)? `Eout :</span><br><span class="line">                  ((D_A1 == M_A3) &amp; (T_new_M == <span class="number">0</span>) &amp; RFWE_M &amp; M_A3!=<span class="number">0</span>)? `Mout :</span><br><span class="line">                  ((D_A1 == W_A3) &amp; (T_new_W == <span class="number">0</span>) &amp; RFWE_W &amp; W_A3!=<span class="number">0</span>)? `Wout :</span><br><span class="line">                  `origin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> CMPD2Fwd = ((D_A2 == E_A3) &amp; (T_new_E == <span class="number">0</span>) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>)? `Eout :</span><br><span class="line">                  ((D_A2 == M_A3) &amp; (T_new_M == <span class="number">0</span>) &amp; RFWE_M &amp; M_A3!=<span class="number">0</span>)? `Mout :</span><br><span class="line">                  ((D_A2 == W_A3) &amp; (T_new_W == <span class="number">0</span>) &amp; RFWE_W &amp; W_A3!=<span class="number">0</span>)? `Wout :</span><br><span class="line">                  `origin;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="暂停策略"><a href="#暂停策略" class="headerlink" title="暂停策略"></a>暂停策略</h4><ul>
<li>注意对于不要用的rt，rs要把T_use置位2（防止在i型指令的时候多暂停）</li>
<li>所以常规寄存器的暂停要素： <ul>
<li>$T_{use} &lt; T_{new}$ 这在图表上对应了四种暂停情况，咱们枚举出来</li>
<li>A1(2) = A3 ?</li>
<li>RFWE = 1 ?</li>
<li>A3 != 0 ?</li>
</ul>
</li>
<li>代码如下：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> stall_rs0_E1 = (T_rsUse == <span class="number">0</span>) &amp; (T_new_E == <span class="number">2&#x27;b01</span>) &amp; (D_A1 == E_A3) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs0_E2 = (T_rsUse == <span class="number">0</span>) &amp; (T_new_E == <span class="number">2&#x27;b10</span>) &amp; (D_A1 == E_A3) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs0_M1 = (T_rsUse == <span class="number">0</span>) &amp; (T_new_M == <span class="number">2&#x27;b01</span>) &amp; (D_A1 == M_A3) &amp; RFWE_M &amp; M_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs1_E2 = (T_rsUse == <span class="number">1</span>) &amp; (T_new_E == <span class="number">2&#x27;b10</span>) &amp; (D_A1 == E_A3) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs = stall_rs0_E1 | stall_rs0_E2 | stall_rs0_M1 | stall_rs1_E2;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于乘除指令：<ul>
<li>将Busy，start_E，MDUOp_D传入HCU</li>
<li>然后md暂停信号为<code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li>
</ul>
</li>
<li>暂停的机制：暂停D级，清空E级，暂停IF</li>
</ul>
<h2 id="测试数据及自动化测试"><a href="#测试数据及自动化测试" class="headerlink" title="测试数据及自动化测试"></a>测试数据及自动化测试</h2><h3 id="常规测试"><a href="#常规测试" class="headerlink" title="常规测试"></a>常规测试</h3><ul>
<li>基础指令的测试同p4</li>
</ul>
<h3 id="冒险测试"><a href="#冒险测试" class="headerlink" title="冒险测试"></a>冒险测试</h3><ul>
<li>对于冲突进行覆盖性分析，需要我们根据冲突表，45种情况每一种都设计相应的冒险测试数据（建立在基础测试通过的情况下）</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p>
<ul>
<li>乘除法都有较高的延迟，若整合进ALU，则进行乘除法的时候，所有的运算类指令都只能阻塞在D级，造成了极大的性能损失。单独设置MDU的话，无关的指令还能正常的在ALU运行，效率较高。</li>
<li>HI，LO寄存器并不是通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于GRF中，内置在MDU中即可。</li>
</ul>
<p>2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p>
<ul>
<li>真实的流水线CPU采用的乘法是有加法器和移位器循环，具体实现过程为：<blockquote>
<p>首先CPU会初始化三个通用寄存器用来存放被乘数，乘数，部分积。<br>部分积寄存器初始化为0。<br>判断乘数寄存器的低位是0|1，如果为0则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。<br>在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。<br>同时部分积寄存器高位补0。如果为1则将部分积寄存器加上被乘数寄存器，再进行移位操作。<br>当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。</p>
</blockquote>
</li>
<li>还有另一种乘法的方式：<blockquote>
<p>只需两个寄存器，A[31:0],B[63:0]，A初始化为被乘数，B初始化为乘数。<br>每一次取B的最低位，为1则将A[31:0]+B[63:32] -&gt; B[63:32]，为0则不操作。<br>每次将B &gt;&gt; 1，然后高位补0。</p>
</blockquote>
</li>
<li>除法实现：<blockquote>
<p>与乘法的操作基本相反，首先CPU会初始化三个寄存器,用来存放被除数，除数，部分商。余数(被除数与除数比较的结果)放到被除数的有效高位上。CPU做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先CPU会把被除数bit位与除数bit位对齐，然后再让对齐的被除数与除数比较(双符号位判断)。比如01-10=11(前面的1是符号位) 1-2=-1 计算机通过符号位和后一位的bit位来判断大于和小于，那么01-10=11 就说明01小于10，如果得数为01就代表大于，如果得数为00代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位(上商就是将商的最低位左移1位腾出商寄存器最低位上新的商)如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。</p>
</blockquote>
</li>
</ul>
<p>3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p>
<ul>
<li>除cnt—，和BusyReg置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li>
<li>对于乘除指令：<ul>
<li>将Busy，start_E，MDUOp_D传入HCU</li>
<li>然后md暂停信号为<code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li>
</ul>
</li>
</ul>
<p>4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p>
<ul>
<li>对于需要写入的位置更加的直观，相当于将DMWE、DMOP写入的A[1:0]用四位字节使能信号表示，十分的统一。</li>
</ul>
<p>5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p>
<ul>
<li>按字节读写的时候，我们获得的是一字节，但是我们如果要lw或lh的话我们就需要拼接。如果是sw或sh的话我们需要多次存入。</li>
<li>若用lb，sb，lh，sh这种非取字的读写时，按字节读可以省去，取位，拼接的步骤，效率要优于按字读写。</li>
</ul>
<p>6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p>
<ul>
<li>NPC统一，NPC统一模块，具体可见<a href="#跳转分支指令">跳转分支指令实现</a></li>
<li>指令分类，MCU指令括号分类防止译码指令过长<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/MCU%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB.png" alt="MCU指令分类"></li>
<li>每一级设置outMUX，只需在MCU中控制outSel即可决定转发值及写入寄存器的值</li>
<li>多用注释来对代码段进行分割，代码对齐（保持好的代码风格）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%B3%A8%E9%87%8A%E5%88%86%E5%89%B2.png" alt="注释分割"></li>
</ul>
<p>7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p>
<ul>
<li>实现过程见<a href="#冒险处理">实现方法-冒险处理</a></li>
<li>在常规测试通过后，我们可以将T_rsUse和T_rtUse相同的指令归类为同一需求指令，把T_new相同的指令归类为同一供给指令。<ul>
<li>所以可以在new方面有下列指令：add，lw，jal，mfhi</li>
<li>在rsUse方面有下面情况：add，sll，lw，beq，jr，mult，mthi</li>
</ul>
</li>
<li>然后对着转发的时间表，设计测试数据：</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rs0_E1</span></span><br><span class="line"><span class="keyword">add </span>  $<span class="built_in">t0</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span></span><br><span class="line"><span class="keyword">beq </span>  $<span class="built_in">t0</span>, $<span class="built_in">t3</span>, label1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment"># rs0_E2</span></span><br><span class="line"><span class="keyword">lw </span>   $<span class="built_in">t0</span>, <span class="number">0</span>($<span class="built_in">t1</span>)</span><br><span class="line"><span class="keyword">beq </span>  $<span class="built_in">t0</span>, $<span class="built_in">t3</span>, label1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">#rs0_E0</span></span><br><span class="line"><span class="keyword">jal </span>  label1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">ori </span>  $<span class="built_in">t0</span>, $<span class="number">0</span>, <span class="number">0x1234</span></span><br><span class="line"><span class="symbol">label1:</span> <span class="keyword">jr </span>$<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>....</span><br></pre></td></tr></table></figure>
<p>8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</p>
<ul>
<li>手动构造策略见上</li>
<li>完全随机生成有几大不足之处，如无法保证内存对齐，无法保证延迟槽中没有跳转分支，无法避免一定几率的死循环等等</li>
<li>但可以加入策略：<ul>
<li>比如只用t0-t6寄存器以保证产生足够多的冲突</li>
<li>在检测到生成跳转后禁用跳转指令</li>
<li>检测到内存不对齐可以不生成等等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P6</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p5流水线CPU-lite</title>
    <url>/2022/11/24/BUAA-CO-p5%E6%B5%81%E6%B0%B4%E7%BA%BFCPU-lite/</url>
    <content><![CDATA[<p>BUAA-CO课程p5，用verilog实现五级流水线的CPU，首次操作难度较大</p>
<span id="more"></span>
<h1 id="p5-log"><a href="#p5-log" class="headerlink" title="p5_log"></a>p5_log</h1><h2 id="设计思路-纲领"><a href="#设计思路-纲领" class="headerlink" title="设计思路-纲领"></a>设计思路-纲领</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>我们先通过对于RTL构造出无需转发的数据通路表</li>
<li>在考虑转发的情况构造出转发的数据通路</li>
<li><p>搭建电路（图文结合）</p>
</li>
<li><p>然后逐条指令分析主控制器控制信号</p>
</li>
<li>逐条指令分析$T_{use}, T_{new} $</li>
<li>构造策略矩阵</li>
<li><p>写控制表达式</p>
</li>
<li><p>这是一个自下而上的过程</p>
</li>
<li>可以先实现p5所需的基础指令</li>
<li><p>然后对于MIPS-C3架构指令集增量开发</p>
</li>
<li><p>最后构建自动化测试与样例生成器</p>
</li>
</ul>
<h3 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h3><ul>
<li>对于指令的分类很重要</li>
<li>下面是所需要是实现的指令类和指令</li>
<li>寄存器寄存器计算：add, sub, slt, sltu, and, or, xor</li>
<li>寄存器立即数计算：addi, slti, andi, ori, xori</li>
<li>位移类： sll, srl, sra, sllv, srlv, srav</li>
<li>B类：beq, bne</li>
<li>store：sw, sh, sb</li>
<li><p>load：lw, lh, lhu, lb, lbu</p>
</li>
<li><p>跳转并链接：jal, jalr, j</p>
</li>
<li>跳转寄存器：jr, jalr</li>
<li>加载高位：lui</li>
<li>空指令：nop</li>
<li>读乘除法寄存器：mfhi, mflo</li>
<li><p>写乘除法寄存器：mult, multu, div, divu, mthi, mtlo</p>
</li>
<li><p>p5要求实现的基础指令有：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</p>
</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>在控制信号连线名末尾加上_阶段字母，如：NPCOp_D，用以区分所属阶段</li>
<li>在寄存器输出信号前加上阶段字母_, 如：D_A1,用以区分所属阶段</li>
<li>功能部件输出信号前加上功能部件.，（实际打码时舍弃）</li>
<li>MUX命名采取X_输入端口名_选择数</li>
<li>转发MUX命名采用F_输入端口名_选择数，级数越大优先级越高</li>
</ul>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><h4 id="数据通路表"><a href="#数据通路表" class="headerlink" title="数据通路表"></a>数据通路表</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" alt="数据通路表"></p>
<h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><h5 id="IFU-PC-IM"><a href="#IFU-PC-IM" class="headerlink" title="IFU(PC\IM)"></a>IFU(PC\IM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能</td>
<td style="text-align:left">暂停时使用</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">由NPC返回，下一条指令的PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前执行的指令地址</td>
</tr>
<tr>
<td style="text-align:center">instr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前执行的指令</td>
</tr>
</tbody>
</table>
</div>
<h5 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h5><ul>
<li>内部转发</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址2</td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入的数据</td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A1地址寄存器中的值</td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A2地址寄存器中的值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D1[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据1</td>
</tr>
<tr>
<td style="text-align:center">D2[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据2</td>
</tr>
<tr>
<td style="text-align:center">CMPOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">CMP功能选择：&lt;/br&gt; 000: beq &lt;/br&gt; 001: bne &lt;/br&gt; 010: blez &lt;/br&gt; 011: bgtz</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">O</td>
<td style="text-align:left">结果为1则分支跳转，为0不跳转</td>
</tr>
</tbody>
</table>
</div>
<h5 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前指令地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Simm26[25:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">地址偏移</td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">返回地址</td>
</tr>
<tr>
<td style="text-align:center">CmpOut</td>
<td style="text-align:center">I</td>
<td style="text-align:left">B类指令的比较结果</td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：&lt;/br&gt; 000: 顺序+4 &lt;/br&gt; 001: B类跳转 &lt;/br&gt;010: jal/j &lt;/br&gt; 011:jr/jalr</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">下一条指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">imm16[15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">16位立即数</td>
</tr>
<tr>
<td style="text-align:center">EXTOp</td>
<td style="text-align:center">I</td>
<td style="text-align:left">EXT功能选择：&lt;/br&gt; 0: 0拓展 &lt;/br&gt; 1: 符号位拓展</td>
<td style="text-align:left">lui指令的高位拓展在ALU里执行</td>
</tr>
<tr>
<td style="text-align:center">S0imm32</td>
<td style="text-align:center">O</td>
<td style="text-align:left">拓展后的32位立即数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">ALU功能选择</td>
<td style="text-align:left">具体对于功能后有附录</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">位移值</td>
</tr>
<tr>
<td style="text-align:center">ALUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">计算结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="MDU-乘除模块"><a href="#MDU-乘除模块" class="headerlink" title="MDU(乘除模块)"></a>MDU(乘除模块)</h5><h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待操作数据的地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待写入的数据</td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">DMout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出的32位数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h4><ul>
<li>每个流水线寄存器都保存着一条指令完成后续操作所需要的的全部信息。</li>
<li>对于每一个流水线的产生结果的级次，我需要用一个MUX来确定哪个是当前指令的用于转发的有效数据，PC+8， ALUout，DMout，所以我们增加outSel的选择信号，此选择信号可以代替RFWDSel的功能</li>
</ul>
<h5 id="D-IF-ID"><a href="#D-IF-ID" class="headerlink" title="D(IF/ID)"></a>D(IF/ID)</h5><ul>
<li>可以在D级内置Splitter</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">暂停时置位0</td>
</tr>
<tr>
<td style="text-align:center">F_instr[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级取出的指令</td>
</tr>
<tr>
<td style="text-align:center">F_PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级输出的指令PC</td>
</tr>
<tr>
<td style="text-align:center">D_opcode[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前D级的opcode</td>
</tr>
<tr>
<td style="text-align:center">D_rs[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rs</td>
</tr>
<tr>
<td style="text-align:center">D_rt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
</tr>
<tr>
<td style="text-align:center">D_rd[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rd</td>
</tr>
<tr>
<td style="text-align:center">D_shamt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">偏移量，位移指令使用</td>
</tr>
<tr>
<td style="text-align:center">D_funct[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">funtion码</td>
</tr>
<tr>
<td style="text-align:center">D_imm16[15:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">16位立即数</td>
</tr>
<tr>
<td style="text-align:center">D_address[25:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">26位地址</td>
</tr>
<tr>
<td style="text-align:center">D_PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D级当前指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="E-ID-EX"><a href="#E-ID-EX" class="headerlink" title="E(ID/EX)"></a>E(ID/EX)</h5><ul>
<li>从E级开始流水控制信号</li>
<li>T_new-1</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
<td style="text-align:left">暂停时置为1</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A1</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_shamt</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_S0imm32</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_shamt</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_S0imm32</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_E[3:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">BSel_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="M-EX-MEM"><a href="#M-EX-MEM" class="headerlink" title="M(EX/MEM)"></a>M(EX/MEM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_M[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="W-MEM-WB"><a href="#W-MEM-WB" class="headerlink" title="W(MEM/WB)"></a>W(MEM/WB)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_DR</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[4:0] W_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_DR</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_W</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h3 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h3><ul>
<li>此CPU采用集中译码的方式，在D级译码，控制信号进入流水，使用过的就不用进入了</li>
<li>T_new产生后随着流水线递减</li>
<li>分为MCU，HCU</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" alt="控制信号表"></p>
<h4 id="主控制器（MCU）"><a href="#主控制器（MCU）" class="headerlink" title="主控制器（MCU）"></a>主控制器（MCU）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">opcode[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_opcode</td>
</tr>
<tr>
<td style="text-align:center">funct[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_funct</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NPCOp_D[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DEXTOp_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm26Sel_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DA3Sel_D[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left">E_ALU_B信号选择：{}</td>
</tr>
<tr>
<td style="text-align:center">outSel[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">有效转发数据Sel</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令用到rs寄存器所剩下的时间</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令产生结果所需的时间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>MUX控制信号的具体含义可以看数据通路表</li>
</ul>
<h4 id="冒险控制器（HCU）"><a href="#冒险控制器（HCU）" class="headerlink" title="冒险控制器（HCU）"></a>冒险控制器（HCU）</h4><ul>
<li>空行表示逻辑与功能上的分割</li>
<li>我这里只需要D级输出T_use因为我只有stall需要用到T_use，而stall应只在D级就决定，转发只需判断Tnew==0</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D_A1[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">D_A2[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A1[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">E_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">W_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFRD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">NPC读入RA的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD1的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD2的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_A的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_B的转发</td>
</tr>
<tr>
<td style="text-align:center">DMV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM_WD的转发</td>
</tr>
<tr>
<td style="text-align:center">stall</td>
<td style="text-align:center">O</td>
<td style="text-align:left">暂停信号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Sel结尾代表常规MUX信号，Fwd结尾代表转发MUX信号</li>
<li>转发MUX的Sel的含义大致是数字越大优先级越高，优先级是E、M、W</li>
</ul>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><ul>
<li>特别注意在M_V2存入F_ALU_V2</li>
</ul>
<h3 id="跳转分支指令"><a href="#跳转分支指令" class="headerlink" title="跳转分支指令"></a>跳转分支指令</h3><ul>
<li>要特别注意PC+8的转发问题，当检测到jal时转发</li>
</ul>
<h3 id="冒险处理"><a href="#冒险处理" class="headerlink" title="冒险处理"></a>冒险处理</h3><ul>
<li>遵循暴力转发策略，在打好常规的数据通路表后，观察哪些端口需要用到寄存器值（需求者），再把所有的供给者的情况遍历出来</li>
<li>AT法: 需求者是需要用这个值来运算的，找到所有与V，RD相关的端口；供给者是需要这个值来存入的，考虑它啥时候能够算出来。</li>
<li>因此对于 $T_{use} $ 我们只需要考虑被需求所以只可能在DEM级</li>
<li>对于</li>
<li>$T_{use} = 0$: beq, jr</li>
<li>$T_{use} = 1$: add, sub, ori, lw, sw</li>
<li>$T_{use} = 2$: lw, sw</li>
<li>表出来后，尽量转发</li>
<li>暂停的机制：暂停IF,暂停D级，清空E级，</li>
<li>转发机制：结果出来后都转发，只需改变控制信号。</li>
<li>我们把RFWE放入HCU用以保证写使能信号有效（有效数据）</li>
<li>判断A3!=0</li>
<li>注意对于不要用的rt，rs置位2</li>
</ul>
<h4 id="冒险控制表"><a href="#冒险控制表" class="headerlink" title="冒险控制表"></a>冒险控制表</h4><ul>
<li>先根据每一条指令，整理其Tuse，Tnew</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/指令时间表.jpg" alt="指令时间表"></p>
<ul>
<li>再根据每条指令的时间列出转发暂停控制信号表</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/冲突控制表.jpg" alt="冲突控制表"></p>
<h2 id="测试数据及自动化测试"><a href="#测试数据及自动化测试" class="headerlink" title="测试数据及自动化测试"></a>测试数据及自动化测试</h2><h3 id="常规测试"><a href="#常规测试" class="headerlink" title="常规测试"></a>常规测试</h3><ul>
<li>这里同p4的测试</li>
</ul>
<h3 id="冒险测试"><a href="#冒险测试" class="headerlink" title="冒险测试"></a>冒险测试</h3><ul>
<li>对于冲突进行覆盖性分析，需要我们根据冲突表，45种情况每一种都设计相应的冒险测试数据（建立在基础测试通过的情况下）</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><ul>
<li>我实现了一个半自动化的测试程序具体见上交的材料</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。<ul>
<li>我们使用两个寄存器值的时间最早来到了D级，所以很可能会引发暂停.</li>
<li>如下面这种情况，若beq的结果在E级产生，则不需要暂停，可以转发，但是现在beq在D级的时候lw还在M级，没有产生结果，需要暂停。</li>
</ul>
</li>
</ol>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span>   $<span class="built_in">t0</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beq </span>  $<span class="built_in">t0</span>, $<span class="built_in">t0</span>, label</span><br></pre></td></tr></table></figure>
<ol>
<li>因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？<ul>
<li>因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把PC+8写入寄存器，不然jr时延迟槽内的指令会再执行一次</li>
</ul>
</li>
<li>我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？<ul>
<li>来自寄存器的值是当前这一级的值，而功能部件输出的值是要写入下一级的，有一定的延迟，不能统一时间，转发的值就不稳定</li>
</ul>
</li>
<li>我们为什么要使用 GPR 内部转发？该如何实现？<ul>
<li>为了保持W级的写入和此时D级的读出是同一个值，规避数据冒险。实现方法就是在RF模块里加上一个MUX，判断当冲突条件满足时，转发。</li>
</ul>
</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> RD1 = (A3 == A1) &amp; (A3 != <span class="number">0</span>) &amp; (en == <span class="number">1</span>)? WD : greg[A1];</span><br><span class="line"><span class="keyword">assign</span> RD2 = (A3 == A2) &amp; (A3 != <span class="number">0</span>) &amp; (en == <span class="number">1</span>)? WD : greg[A2];</span><br></pre></td></tr></table></figure>
<ul>
<li>当然不使用内部转发的话也不是不行，可以把Wout接入RD出口的转发多路选择器。</li>
</ul>
<ol>
<li>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？<ul>
<li>需求者有：NPC.RA, CMP.D1|D2, ALU.V1|V2, DM.WD</li>
<li>供给者：PC+8, ALU, DM</li>
<li>转发数据通路：每一级上加上一个outMUX，用于选择转发回去的结果，选择信号每条指令不同；在每个需求者端口前加上转发MUX，用于接收来自E, M, W三级的转发。</li>
</ul>
</li>
<li>在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。<ul>
<li>增加了sll，sb|lb|lbu指令，所以课上的拓展大多数能覆盖到</li>
<li>高内聚低耦合原理：大多数只需要改变控制信号以及相应的功能模块增加功能，但不排除某些需要修改数据通路</li>
<li>对于计算类：首先改变MCU，注意每个指令的控制信号的对应，再改ALU的结构，增加输出选择</li>
<li>对于访存类：改变MCU+修改DM增加相应的功能</li>
<li>对于跳转类：修改MCU+NPC相应功能修改</li>
<li>小技巧：寻找已有的指令中与新增的指令相似的指令（可能不止一条），然后顺着这几条指令改。</li>
</ul>
</li>
<li>简要描述你的译码器架构，并思考该架构的优势以及不足。<ul>
<li>我当前是集中式译码</li>
<li>优势：不需要编写多个译码器</li>
<li>不足：流水线寄存器会变得十分的臃肿</li>
</ul>
</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">0</span>] = _beq | _jal ;</span><br><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">1</span>] = _j | _jal;</span><br><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">2</span>] = _jr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DEXTOp = _lw | _sw | _lb | _lbu | _sb ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">0</span>] = _sub | _slt | _sll;</span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">1</span>] = _ori | _slt ;</span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">2</span>] = _lui | _sll ;</span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> CMPOp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> CMPOp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> CMPOp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DMOp[<span class="number">0</span>] = _lbu | _lb | _sb;</span><br><span class="line"><span class="keyword">assign</span> DMOp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> DMOp[<span class="number">2</span>] = _lbu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> RFWE = _add | _sub | _ori | _slt | _lw | _jal | _lui | _lb | _lbu | _sll;</span><br><span class="line"><span class="keyword">assign</span> DMWE = _sw | _sb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> imm26Sel = _j | _jal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DA3Sel[<span class="number">0</span>] = _ori | _lw | _lui | _lb | _lbu;</span><br><span class="line"><span class="keyword">assign</span> DA3Sel[<span class="number">1</span>] = _jal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> BSel = _ori | _lw | _sw | _lui | _lb | _lbu | _sb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> outSel[<span class="number">0</span>] = _add | _sub | _ori | _slt | _lui | _sll;</span><br><span class="line"><span class="keyword">assign</span> outSel[<span class="number">1</span>] = _lw | _lb | _lbu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> T_rsUse[<span class="number">0</span>] = _add | _sub | _ori | _lw | _sw | _lui | _lb | _lbu | _sb;</span><br><span class="line"><span class="keyword">assign</span> T_rsUse[<span class="number">1</span>] = (_jal | _sll);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> T_rtUse[<span class="number">0</span>] = _add | _sub | _sll;</span><br><span class="line"><span class="keyword">assign</span> T_rtUse[<span class="number">1</span>] = _sw | _sb | (_ori | _lw | _lui | _jal | _jr | _lb | _lbu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> T_new_D[<span class="number">0</span>] = _lw | _lb | _lbu;</span><br><span class="line"><span class="keyword">assign</span> T_new_D[<span class="number">1</span>] = _lw | _add | _sub | _ori | _lui | _lb | _lbu | _sll;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P5</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p4单周期CPU-verilog实现</title>
    <url>/2022/11/24/BUAA-CO-p4%E5%8D%95%E5%91%A8%E6%9C%9FCPU-verilog%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>BUAA-CO课程p4，用verilog实现单周期的CPU</p>
<span id="more"></span>
<h1 id="p4-log"><a href="#p4-log" class="headerlink" title="p4_log"></a>p4_log</h1><h2 id="模块化层次化"><a href="#模块化层次化" class="headerlink" title="模块化层次化"></a>模块化层次化</h2><ul>
<li>整体结构与p3中logisim的分层一致，顶层端口定义为mips.v</li>
<li>不同：<ul>
<li>需要增加同步复位信号reset</li>
<li>clk留端口，而不是内置</li>
</ul>
</li>
<li>需要支持的指令集为：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</li>
<li>后期添加的指令为：slt,sll,lh,sh,lbu</li>
</ul>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><ul>
<li>模块化、端口定义等等大致和p3一致</li>
<li>连线的时候的命名：推荐使用模块+输出端口命名法，小写字母表示，每一个模块的线放一块，这样输入的时候一目了然<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/连线命名方式.jpg" alt="连线命名"></li>
<li>注意存储器地址访问的/4细节，思考题中的[11:2]应该就是出于这个考虑</li>
</ul>
<h3 id="datapath"><a href="#datapath" class="headerlink" title="datapath"></a>datapath</h3><ul>
<li>所有的MUX放在同一个MUX.v的文件中，命名为：MUX_SelNum_bit(默认为32位), 如MUX_4,MUX_4_26,MUX_2_5;</li>
</ul>
<h4 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">异步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址2</td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入的数据</td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A1地址寄存器中的值</td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A2地址寄存器中的值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前指令地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Simm26[25:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">地址偏移</td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">返回地址</td>
</tr>
<tr>
<td style="text-align:center">CmpOut</td>
<td style="text-align:center">I</td>
<td style="text-align:left">B类指令的比较结果</td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：&lt;/br&gt; 000: 顺序+4 &lt;/br&gt; 001: B类跳转 &lt;/br&gt;010: jal/j &lt;/br&gt; 011:jr/jalr</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">下一条指令地址</td>
</tr>
</tbody>
</table>
</div>
<h4 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h4><p>信号名|IO|描述|备注|<br>|:-:|:-:|:-|:-|<br>|imm16[15:0]|I|16位立即数|<br>|EXTOp|I|EXT功能选择：&lt;/br&gt; 0: 0拓展 &lt;/br&gt; 1: 符号位拓展|lui指令的高位拓展在ALU里执行|<br>|S0imm32|O|拓展后的32位立即数|</p>
<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">ALU功能选择</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">位移值</td>
</tr>
<tr>
<td style="text-align:center">ALUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">计算结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">异步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待操作数据的地址</td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">DMout[31:0]</td>
<td style="text-align:center">输出的32位数据</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" alt="数据通路表"></p>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul>
<li>对于控制器，我采用先用操作码识别出不同的指令，再去记录下每个控制信号所对应的指令，因为这样更加符合电路的直观（或运算），也更符合我对未来的想象（）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" alt="控制信号表"></li>
</ul>
<h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><ul>
<li>还是用p3时候的测试数据，但是需要多多注意的是这个东西肉眼debug其实还好一点，但更加适合自动化评测，开始手搓！</li>
</ul>
<h2 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h2><h3 id="slt"><a href="#slt" class="headerlink" title="slt"></a>slt</h3><ul>
<li>处理ctrl，ALU，先填表再连线</li>
</ul>
<h3 id="sll"><a href="#sll" class="headerlink" title="sll"></a>sll</h3><ul>
<li>shamt传入ALU，其他就没什么问题了</li>
</ul>
<h3 id="lh，sh，lhu"><a href="#lh，sh，lhu" class="headerlink" title="lh，sh，lhu"></a>lh，sh，lhu</h3><ul>
<li>加上DMOp，在前面有定义</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0]<ul>
<li>从ALUout输出过来，是按字节寻址的指令，但我们的IM是按字寻址的，addr应该是4的整数倍，所以左移两位，按字存取。</li>
</ul>
</li>
<li>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。<ul>
<li>第二种是最后靠信号输出的，更符合电路的或逻辑，便于后续开发，且更加符合电路</li>
</ul>
</li>
<li>在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。<ul>
<li>异步复位reset的优先级高于clk，不管clk是否处于上升沿，都会复位（所以需要加入触发条件中）。</li>
<li>而同步复位的reset优先级低于clk，只有clk到来才会生效。</li>
</ul>
</li>
<li>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。<ul>
<li>addi和add，在operate中加入了溢出检测</li>
<li>以add为例</li>
<li><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/加法检测.jpg" alt="加法检测"></li>
<li>若R[rs]和R[rt]的30都是1且31相同的话，就分别对应正数和负数的溢出情况，则这么计算后temp32!temp31，不相等，所以溢出。</li>
<li>检测溢出后就会抛出异常，但没有检测溢出的话，还是正常计算，所以和addiu，addu一样。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P4</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p3-单周期CPU(logisim实现)</title>
    <url>/2022/11/24/BUAA-CO-p3-%E5%8D%95%E5%91%A8%E6%9C%9FCPU-logisim%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>BUAA-CO课程project3，用logisim实现单周期的CPU</p>
<span id="more"></span>
<h1 id="p3-log"><a href="#p3-log" class="headerlink" title="p3_log"></a>p3_log</h1><p>[toc]</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><ul>
<li>两个mealy机 -&gt; 单周期CPU</li>
<li>控制器生成真值表</li>
<li>抽象和模块化</li>
<li>控制器打表</li>
<li>MIPS测试，设计数据</li>
<li>RAM与ROM的区别</li>
</ul>
<h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><ul>
<li>CPU分为两个部分，数据通路(Datapath)+控制器(control)</li>
</ul>
<h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><ul>
<li>一个MIPS数据通路又可以抽象为五步：取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)</li>
<li>相应的应该有PC、NPC、IM、RF、ALU、DM、Controller这几个大的模块，以及在实现的过程中会存在的MUX、EXT、Splitter这些小的模块（系统与子系统的模块）</li>
<li>数据通路是连接方式的组合，介于我们需要实现指令条数，我们通过这些指令的RTL描述，倒推出这条指令所需要的功能部件，从而建立起部件之间的连接关系，以及控制信号的取值。然后把这些连接关系填入数据通路的表中，填入每一个端口所需要的输入。</li>
<li>把所有的指令分析完后，归并每个端口的输入信号，信号来源唯一的端口可以直接连接，但多输入的情况我们需要MUX+Controller的实现。</li>
<li>得到最后的数据通路图后，我们很容易能构造出数据通路。</li>
</ul>
<h3 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h3><ul>
<li>控制器的设计过程，我们理解为通过opcode和function识别指令+输出相应的控制信号，这两步可以进一步抽象为和逻辑和或逻辑。</li>
<li>我们把表给列出来（其实这也是一种真值表）。</li>
<li>创建好以后，连线就行</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>确定所需实现的指令：addu，subu，ori，lw，sw，beq，jal，jr（MIPS-C0），add，sub，xor，jalr，nop，sll/sllv，lui，slt。</li>
<li>尽量每一种指令都来一下：<ul>
<li>R型：<ul>
<li>计算指令：add,sub,and, or</li>
<li>移位指令：sll,sra,sllv</li>
<li>置位指令：slt,sltu</li>
<li>跳转指令：jr,jalr</li>
<li>系统调用：syscall</li>
</ul>
</li>
<li>I型：<ul>
<li>计算指令：addi,ori,lui</li>
<li>置位指令：slti,sltiu</li>
<li>分支指令：beq,bne,bgtz</li>
<li>访存指令：lw,sw,lh,sh,lhu,lb,sb,lbu</li>
</ul>
</li>
<li>J型：<ul>
<li>跳转指令：j,jal</li>
</ul>
</li>
</ul>
</li>
<li>把每个模块组装好，设计好端口</li>
<li><p>打表连接</p>
</li>
<li><p>在端口的命名中我们采取的一些命名缩写，它的意义是</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命名</th>
<th style="text-align:center">意义</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WD</td>
<td style="text-align:center">write data</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RD</td>
<td style="text-align:center">read data</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">address</td>
</tr>
<tr>
<td style="text-align:center">WR</td>
<td style="text-align:center">write reg</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">write enable</td>
</tr>
</tbody>
</table>
</div>
<h3 id="PC-NPC实现"><a href="#PC-NPC实现" class="headerlink" title="PC/NPC实现"></a>PC/NPC实现</h3><ul>
<li>PC用寄存器实现</li>
<li>NPC先实现一个简单的+4功能</li>
<li><p>后续跳转指令加入时再看</p>
</li>
<li><p>beq：在ALU的地方返回一个rs=rt的结果到NPC，把imm16传到NPC，再传个控制器信号，是beq就跳</p>
</li>
<li>jal：在这里我们的控制信号就要多增加，而且不仅要计算PC+4+imm26的值，我们还需要计算PC+4的值，写入31号$sp寄存器</li>
<li>j：与jal的区别仅在于，不用回写</li>
<li>jr：PC &lt;- GPR[rs],需要读入rs寄存器的值</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">方向</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前位置</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm[26]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">26位立即数</td>
<td style="text-align:center">beq是imm16,jal是add26,可以覆盖</td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">jr需要的32位返回地址</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">BeqYes?</td>
<td style="text-align:center">I</td>
<td style="text-align:left">rs,rt相等的标志</td>
<td style="text-align:center">NPCOp=001起作用</td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：<br> 000: 顺序地址 <br> 001: beq <br> 010: j <br> 011: jal <br> 100: jr</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出接下来的PC</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">PC4[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">PC+4</td>
</tr>
</tbody>
</table>
</div>
<h3 id="IM实现"><a href="#IM实现" class="headerlink" title="IM实现"></a>IM实现</h3><ul>
<li>IM没有写入的要求，用ROM即可，指令为32位，地址位宽可以选取8（即256条指令）</li>
</ul>
<h3 id="InstructionSplitter"><a href="#InstructionSplitter" class="headerlink" title="InstructionSplitter"></a>InstructionSplitter</h3><ul>
<li>在32位的机器码中根据MIPS指令的类型我们需要得到opcode、rs、rt、rd、shamt、funt、imm16、address，在RIJ型的指令中分别会用到，但是我们并不需要判断指令类型给出相应的输出。我们把这些都给输出，需要什么是后续元件与Controller的事。</li>
</ul>
<h3 id="RF实现"><a href="#RF实现" class="headerlink" title="RF实现"></a>RF实现</h3><ul>
<li>这里在p0已经写过了，就直接CV了，但是注意端口的命名可以改一下。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:center">时钟信号</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">clr</td>
<td style="text-align:center">I</td>
<td style="text-align:center">异步复位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:center">写使能，为1时可以写入</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">指定32各寄存器中的一个，将值读入RD1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">指定32各寄存器中的一个，将值读入RD2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">指定32各寄存器中的一个，作为WD值的写入对象</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">在WE为1，将内容写入A3指定的寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:center">输出A1指定的寄存器的值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:center">输出A2指定的寄存器的值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ALU（重点！）"><a href="#ALU（重点！）" class="headerlink" title="ALU（重点！）"></a>ALU（重点！）</h3><ul>
<li><p>在最后加一个MUX输出</p>
</li>
<li><p>addu：直接用加法器</p>
</li>
<li>subu：直接用减法器</li>
<li>slt：比较器</li>
<li>ori：有i的都可以按照这个思路来，在RD2与imm16（Zero_ext32）之间加一个MUX，剩下交给控制器</li>
<li>lw：这里我们需要EXT来实现立即数的符号位拓展，而在ori指令中有非符号位拓展，把他们集成起来做一个EXT模块，剩下交给控制器去决定，R[rt] &lt;- MEM[R[rs]+sign_ext(imm16)]，所以rt与rd到A3加一个MUX</li>
<li>sw：MEM[R[rs]+sign_ext(imm16)] &lt;- R[rt]，RD2接到DMWD</li>
<li>考虑到跳转指令需要对NPC模块进行改装，beq、j、jal、jr指令的实现就放到<a href="#pcnpc实现">PC/NPC实现</a>里了</li>
<li>下面是不同的ALUOp代表的功能</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ALUOp</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0000</td>
<td style="text-align:center">addu</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">subu</td>
</tr>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">ori</td>
</tr>
<tr>
<td style="text-align:center">0011</td>
<td style="text-align:center">slt</td>
</tr>
<tr>
<td style="text-align:center">0100</td>
<td style="text-align:center">lw</td>
</tr>
<tr>
<td style="text-align:center">0101</td>
<td style="text-align:center">sw</td>
</tr>
</tbody>
</table>
</div>
<h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ExtOp</td>
<td style="text-align:center">I</td>
<td style="text-align:center">选择拓展方式：<br> 0: 0拓展<br>1: 符号位拓展</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm16</td>
<td style="text-align:center">I</td>
<td style="text-align:center">输入的16位立即数</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm32</td>
<td style="text-align:center">O</td>
<td style="text-align:center">输出的32位立即数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><ul>
<li>用一个可写入的RAM来实现</li>
<li>用位拓展器把传入的32位值变为8位</li>
</ul>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>可以分为两个部分，一个是识别器，一个是信号器</li>
<li>根据后面的信号表与和或逻辑来搭建</li>
<li>注意合理CV，不然会很难受</li>
<li>注意测试</li>
<li>问题：nop不需要控制为啥，因为nop的时候NPCOp=000，几个WE都是0，写不进东西，所以不需要控制</li>
</ul>
<blockquote>
<p>自此，框架已经搭好，现在开始做打表连接</p>
</blockquote>
<h3 id="数据通路表及控制信号表"><a href="#数据通路表及控制信号表" class="headerlink" title="数据通路表及控制信号表"></a>数据通路表及控制信号表</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/指令RTL描述.jpg" alt="指令的RTL描述"></p>
<ul>
<li>下面根据RTL描述写出数据通路表</li>
<li>每一个指令需要将什么端口连接，指令级数据通路与控制器建模，先忽略控制信号的端口<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" alt="数据通路表"></li>
<li>相应的在分析每条指令的通路的时候可以把控制信号的取值记下来，暂时不包含MUX的控制<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" alt="控制信号表"></li>
<li>所以数据通路连接的总合计为<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/连接总合计.jpg" alt="连接总合计"></li>
<li>在根据数据通路表中的多输入端口，把MUX的Sel信号写入控制信号表<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/MUX控制信号表.jpg" alt="MUX控制信号表"></li>
</ul>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ul>
<li>ROM的寻址方式</li>
<li>加入指令lui<ul>
<li>在数据通路连接表与信号控制表里加入它，然后把该连的线连起来</li>
<li>按照控制表打控制器</li>
</ul>
</li>
<li>发现一个ori在mars里调用了ori、lui、or</li>
<li>但是or除了ALUOp不同以外其余都相同</li>
<li>add,sub</li>
<li>DM写入地址输出</li>
<li>imm32,address移位但ra不移，所以对应到p3的处理办法，ra应该移位</li>
<li>beq的imm16要符号位拓展(p4的时候才发现这个bug，可见测试数据还是很弱的，需要自己造数据)</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>每条指令功能都测试一下</li>
<li>每条指令考虑正负等等</li>
<li>用disassembler的工具进行机械码转汇编语言<ul>
<li>转换注意：b -&gt; j</li>
<li>neg -&gt; sub</li>
</ul>
</li>
<li>CPU的每一步对应着MARS调试的每一步</li>
<li>jr指令可以跳到所有寄存器的储存值，注意！</li>
</ul>
<h2 id="后续增量开发"><a href="#后续增量开发" class="headerlink" title="后续增量开发"></a>后续增量开发</h2><ul>
<li>思考是RIJ哪种指令，思考需不需要跳转<ul>
<li>R型I型对应不同的WRSel</li>
<li>跳转要改变NPCOp和NPC接口</li>
<li>写对应的控制信号</li>
</ul>
</li>
<li>下面由于特殊性，加上lh,lb,sh,sb, sll指令</li>
<li>对于lh,sh,lb,sb,lbu,lhu指令,下面以lb,sb,lbu为例<ul>
<li>改版DM，增加DMOp<a href="第三位表示是否无符号拓展">2:0</a></li>
<li>store操作：通过out与WD的7:0拼起来读入，根据A决定</li>
<li>load操作：只输出out的8位（根据A来决定），注意拓展</li>
<li>其余模块都与sw，lw一致</li>
</ul>
</li>
<li>sll指令比较的特殊，需要加上ASel（为1时选择shamt）</li>
<li>Controller指令的顺序改进</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。<ul>
<li>状态存储：IM，RF，DM</li>
<li>状态转移：NPC，ALU</li>
</ul>
</li>
<li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。<ul>
<li>正确的，合理的，无可挑剔的</li>
</ul>
</li>
<li>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。<ul>
<li>我把Controller分为了两个部分，一个是识别器，一个是信号发送器，主要考虑是可以在main电路中调试的时候看到当前执行的指令。</li>
</ul>
</li>
<li>事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？<ul>
<li>因为nop的时候NPCOp=000，没有跳转，而且几个WE使能是0，写不进东西，所以不需要控制</li>
<li>而且我写了sll，所以nop就对应着移0位的sll，等同于没有修改。</li>
</ul>
</li>
<li>上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。<ul>
<li>可以把其中一个起始地址先设为0，然后另一个可以通过写程序实现判断与修改。</li>
</ul>
</li>
<li>阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。<ul>
<li>有些寄存器没有用到，有些负数的特殊情况没有涉及（比如beq的负数情况），跳转的指令没有设计</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P3</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】矩阵相关问题讲课资料</title>
    <url>/2022/11/24/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B2%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>朋辈辅导师第十二周直播课-矩阵相关典型问题的备课资料，大家有需要自取，备课本有点乱，建议配合视频一起食用。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/F1D5448BCDB824AACC5FB3DF2F454490">矩阵相关典型问题</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="矩阵相关问题"><a href="#矩阵相关问题" class="headerlink" title="矩阵相关问题"></a>矩阵相关问题</h1><p>[toc]</p>
<h2 id="矩阵的基本盘"><a href="#矩阵的基本盘" class="headerlink" title="矩阵的基本盘"></a>矩阵的基本盘</h2><h3 id="可逆定义定义及相关性质及求逆阵的方法"><a href="#可逆定义定义及相关性质及求逆阵的方法" class="headerlink" title="可逆定义定义及相关性质及求逆阵的方法"></a>可逆定义定义及相关性质及求逆阵的方法</h3><ul>
<li>可逆的定义及相关性质<blockquote>
<p>$若\exists B,AB=BA=I，则称A为可逆阵，B为A的逆阵,记作：A^{-1} = B $</p>
</blockquote>
</li>
<li>性质：<blockquote>
<p>$(ABC)^{-1} = C^{-1}B^{-1}A^{-1} $(proof)<br>行列式不为零则可逆<br>……</p>
</blockquote>
</li>
<li><p>逆阵唯一性</p>
<blockquote>
<script type="math/tex; mode=display">
  AB =AC =I  
  则B = BI = B(AC) = (BA)C = C</script></blockquote>
</li>
<li><p>拓展唯一性例题的解法<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0唯一性表示例题1.jpg" alt="唯一性例题"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0唯一性表示例题2.jpg" alt="解法2"></p>
</li>
<li><p>保可逆，反序可逆</p>
<blockquote>
<p>A可逆，B可逆，则AB可逆<br>$proof: ABB^{-1}A^{-1} = I $<br>若AB = I ，BA也可逆。</p>
</blockquote>
</li>
<li>求逆方法有三：增广，伴随，0化式（看见多项式赢麻啦）<blockquote>
<p>增广矩阵的机理<br>伴随公式的引申<br>0化式，关于矩阵的多项式，例题，关于特征多项式（Caley定理）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0化式.jpg" alt="0化式"></p>
</blockquote>
</li>
</ul>
<h3 id="正交及相关性质"><a href="#正交及相关性质" class="headerlink" title="正交及相关性质"></a>正交及相关性质</h3><blockquote>
<p>$A^TA = I,即A^{-1} = A^T,则称A为正交阵 $<br>性质：矩阵乘的转置,与矩阵乘的求逆类似</p>
</blockquote>
<ul>
<li>保长、保内积、保正交<blockquote>
<p>$我们知道向量的模长度公式是吧，对于列向量X，它的模长为||X||^2 = X^TX(内积的表示) ，所以列向量AX(A为正交阵)为||AX||^2 = X^TA^TAX ——保长性$<br>$保内积类似，(X,Y) = (AX,AY) = X^TY $<br>$保正交:两种理解：<br>A正交，B正交，则AB正交<br>X \perp Y \Leftrightarrow AX \perp AY $</p>
</blockquote>
</li>
<li>线性变换初步<blockquote>
<p>线性变换与内积空间来理解, Gram阵</p>
</blockquote>
</li>
<li>每列为单位向量且相互正交，且则阵正交<blockquote>
<p>用矩阵乘法去理解。</p>
</blockquote>
</li>
</ul>
<h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><h3 id="秩的xdm"><a href="#秩的xdm" class="headerlink" title="秩的xdm"></a>秩的xdm</h3><ul>
<li>阶梯阵概念，及其与向量组秩的联系。<blockquote>
<p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>所以三种同解变形，其实就代表着三种初等变换。</p>
</blockquote>
</li>
<li>秩一阵<blockquote>
<p>我们来看一个矩阵，秩一阵，可分解为两个向量之间的乘积。</p>
</blockquote>
</li>
<li><p>我们在最后再来谈秩的各种公式的关系</p>
<blockquote>
<ul>
<li>满秩则有唯一解<br>$proof: \because r(A) = n $<br>$\therefore \{\alpha_1,……,\alpha_n\}可作为一组基 $<br>$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>$坐标即为唯一解 $</li>
<li>满秩则可逆<br>$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li>
</ul>
</blockquote>
</li>
<li><p>所以说到这就只需要明确一个事情，满秩，行向量组列向量组无关，行列式不等于0，可逆，只有唯一解，非奇异这都是等价的概念</p>
</li>
</ul>
<h3 id="各种各样的秩公式"><a href="#各种各样的秩公式" class="headerlink" title="各种各样的秩公式"></a>各种各样的秩公式</h3><h4 id="分块秩公式"><a href="#分块秩公式" class="headerlink" title="分块秩公式"></a>分块秩公式</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4分块秩公式.jpg" alt="分块秩公式"></p>
<h4 id="积阵秩公式"><a href="#积阵秩公式" class="headerlink" title="积阵秩公式"></a>积阵秩公式</h4><ul>
<li>乘积不增秩公式<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4不增秩公式.jpg" alt="不增秩公式"></li>
<li>积0公式<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4不增秩公式.jpg" alt="积0公式"></li>
<li>转置积秩公式<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4积0公式.jpg" alt="内积秩公式"></li>
</ul>
<h4 id="加减秩公式"><a href="#加减秩公式" class="headerlink" title="加减秩公式"></a>加减秩公式</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4加减秩公式.jpg" alt="加减秩公式"></p>
<h3 id="奇妙的秩一阵"><a href="#奇妙的秩一阵" class="headerlink" title="奇妙的秩一阵"></a>奇妙的秩一阵</h3><ul>
<li>用一个例题来说明<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1秩一阵例题.jpg" alt="秩一阵例题"></li>
</ul>
<h4 id="提一嘴先不讲"><a href="#提一嘴先不讲" class="headerlink" title="提一嘴先不讲"></a>提一嘴先不讲</h4><ul>
<li>秩一阵的特征值</li>
<li>秩一阵+平移公式+特征值与行列式的关系</li>
</ul>
<h2 id="下降公式"><a href="#下降公式" class="headerlink" title="下降公式"></a>下降公式</h2><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式例题.png" alt="换位公式例题"></p>
<h3 id="换位公式1-0"><a href="#换位公式1-0" class="headerlink" title="换位公式1.0"></a>换位公式1.0</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式1.0.jpg" alt="换位公式1"></p>
<h3 id="换位公式2-0"><a href="#换位公式2-0" class="headerlink" title="换位公式2.0"></a>换位公式2.0</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式2.0.jpg" alt="换位公式2"></p>
<h3 id="换位公式3-0及特征值（带拓展，看时间）"><a href="#换位公式3-0及特征值（带拓展，看时间）" class="headerlink" title="换位公式3.0及特征值（带拓展，看时间）"></a>换位公式3.0及特征值（带拓展，看时间）</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式3.0.jpg" alt="换位公式3"></p>
<h2 id="奇妙的伴随阵"><a href="#奇妙的伴随阵" class="headerlink" title="奇妙的伴随阵"></a>奇妙的伴随阵</h2><ul>
<li>伴随阵的定义</li>
<li>伴随公式的推导<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2伴随阵定义及相伴公式.jpg" alt="伴随阵及相伴公式"></li>
</ul>
<h3 id="相关行列式值的推导"><a href="#相关行列式值的推导" class="headerlink" title="相关行列式值的推导"></a>相关行列式值的推导</h3><ul>
<li>相关行列式的值的计算<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2各种行列式值之间的关系.jpg" alt="相关行列式的值"></li>
</ul>
<h3 id="相伴秩公式"><a href="#相伴秩公式" class="headerlink" title="相伴秩公式"></a>相伴秩公式</h3><ul>
<li>古典秩定义<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2相伴秩公式.jpg" alt="相伴秩公式"></li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】向量空间与内积空间讲课资料</title>
    <url>/2022/11/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4%E8%AE%B2%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>朋辈辅导师第九周直播课-向量空间和内积空间的备课资料，大家有需要自取。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/C7BC9C11CA3A9858EE1EDD8BBECCA983">向量空间与内积空间</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="向量空间与欧氏空间"><a href="#向量空间与欧氏空间" class="headerlink" title="向量空间与欧氏空间"></a>向量空间与欧氏空间</h1><ul>
<li>高代的概念多的很啊，像我们的矩阵、线性方程组、还有向量，这些之间是一个什么关系呢，它们都统一的在空间这个框架里面被联系起来。所以在学习高代的时候一定要有一个意象化的空间的思想，这个思想对于大家好好的理解概念，会有很大的帮助。</li>
</ul>
<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p>[toc]</p>
<h2 id="空间的定义"><a href="#空间的定义" class="headerlink" title="空间的定义"></a>空间的定义</h2><ul>
<li>向量空间（线性空间）的原始定义：对加倍法封闭</li>
<li>性质：零元一定在空间里</li>
<li>拓展：矩阵空间，矩阵掰直就是向量</li>
<li>那我们来看，联系来了，AX=0的解集就构成空间</li>
<li>何以见得：证明对加倍法封闭</li>
<li>该怎么意象化的理解封闭：你们可以用三维空间来理解，空间是一定过原点的，所以在三维空间中一个过原点的平面是空间，这样的话，在平面上的向量怎么组合都跳不出这个平面，这就叫封闭，没过原点的平面上的向量（注意这里的向量顶点分别在原点和平面上）稍微*2就出去了。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1空间的定义.jpg" alt="空间的定义"></li>
</ul>
<h2 id="从生成空间看到解空间"><a href="#从生成空间看到解空间" class="headerlink" title="从生成空间看到解空间"></a>从生成空间看到解空间</h2><h3 id="再次讨论齐次解与非齐次解"><a href="#再次讨论齐次解与非齐次解" class="headerlink" title="再次讨论齐次解与非齐次解"></a>再次讨论齐次解与非齐次解</h3><ul>
<li><p>写出齐次方程的通解，基和广义坐标的关系，所以我们能看到解空间的影子</p>
</li>
<li><p>所以关于非齐次方程的解是否构成空间？</p>
</li>
<li>常见的问题：判断一个解是否为齐次方程或非齐次方程的解？</li>
<li><p>补充：齐次方程解与非齐次方程解之间的关系<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3齐次解与非齐次解讨论.jpg" alt="齐次解与非齐次解的讨论"></p>
</li>
<li><p>补充：高三定理：一个非齐次线性方程组有解，且所有解组成的解集的一个极大线性无关组含有n个解（秩为n），那么对应的齐次线性方程组基础解系含有n-1个解向量（解空间的维度为n-1），这个命题对吗？</p>
<blockquote>
<p>首先经过我上面的描述能证明：<br>  导出方程的解空间的基+一个特解组成的向量组依然无关<br>  然后：<br>  通过非齐次方程组通解的表达形式可知，该解系中任意一个解都能用上面的无关向量组表示，所以我们说该向量组是极大线性无关组。<br>  设这个无关组秩为n。<br>  则根据构造形式，它的导出方程的解空间秩为n-1</p>
</blockquote>
</li>
<li>所以我们要说解空间了嘛？我知道你很急，但你先别急，让我先急（</li>
<li>我们先来说关于空间的另一种理解，这种理解了以后，关于解空间问题迎刃而解。</li>
</ul>
<h3 id="生成空间的定义"><a href="#生成空间的定义" class="headerlink" title="生成空间的定义"></a>生成空间的定义</h3><ul>
<li>关于空间的另一个理解：生成空间！important！！</li>
<li>我们给定任意的一组向量，他们的线性组合，满足双封闭？事空间！</li>
<li>但是还不够简洁，我们远不需要这些向量的全部，因为我们可以由其中的某些来表示全部，这个大家是知道的，叫极大线性无关组，</li>
<li>所以我们有了另一个理解向量空间的视角：就好像是一个极大线性无关组的任意组合，它们生成了空间。我们把这个极大线性无关组叫做基，基的秩就是空间的维数。</li>
<li>空间相同，就是基等价！<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4生成空间的定义.jpg" alt="生成空间"></li>
</ul>
<h3 id="解空间"><a href="#解空间" class="headerlink" title="解空间"></a>解空间</h3><ul>
<li>所以我们回过头来看看解空间是个什么回事。</li>
<li>解空间就是由通解的基生成的。</li>
<li>解空间的维度：两种理解，一种理解是解线性方程组得到，另一种理解更高级和优雅，是定义完内积空间之后得到。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2解空间的由来.jpg" alt="解空间的秩"></li>
<li>然后大家很迫切的想要弄清楚空间的交和空间的和之间的关系，定义我就不多说了</li>
<li>求空间的和：根据定义两边各取一个向量来表示，就把通解写到一块，所以为啥要理解了生成空间再来看这个，就是两个解空间的生成元放在一块，然后再生成一个空间嘛，所以对于维度公式我们也好理解了。</li>
<li>求两个解空间的交有两种办法，一种是定义，把他们的线性方程组联立到一起，这样解出来的空间就既满足A，又满足B。但是一般如果你刚开始知道基，你就很难去反解出他的线性方程组(得求正交，有点麻烦)，但是你可以直接输出两个解空间集合重合的部分，方法就像上面说的，把两个通解的一般形式放一块，划个等号，然后解出来系数之间的关系。把关系再代回去，就得到了他们交空间的通解的形式(这个通解既能通过A的基生成，又能通过B的基生成)</li>
<li>补充：空间的直和与空间的并。</li>
</ul>
<h2 id="欧氏空间的定义"><a href="#欧氏空间的定义" class="headerlink" title="欧氏空间的定义"></a>欧氏空间的定义</h2><ul>
<li>我们理解了这么多以后其实还是会感觉有点空虚的，空虚在哪？关于解空间的维度我前面留了一个小坑，关于基本解与系数矩阵之间的关系若隐若现。</li>
<li>这一些，我们在定义完内积之后，也将得到解决。</li>
<li>我们常说的欧几里得空间就是内积空间，也就是加上内积的定义以后的向量空间！</li>
</ul>
<h3 id="内积与模长"><a href="#内积与模长" class="headerlink" title="内积与模长"></a>内积与模长</h3><ul>
<li>关于内积是怎么定义的，大家早学过了，那么内积有些什么用呢</li>
<li>内积正定性，定义模长</li>
<li>正交向量的内积</li>
<li>若一个向量与一个向量组都正交，那么他与这个生成空间正交</li>
<li>所以我们可以来以另一个视角理解一下解齐次方程组：<ul>
<li>我们把系数矩阵分行来看，我们把需要解的X乘过去的过程不就是在算他与每一行的内积嘛，它们的内积等于零，所以我们的解与系数矩阵的每一行都正交，所以我们的解空间是怎样的一个空间，是一个与A行向量生成的空间正交的空间，所以这也就不难解释，当A的秩为r，A行向量生成的空间的维数就是r，如果这是在一个总共为n的空间里，那我们的解空间与A空间正交，就有了dim = n-r的公式。这么去理解。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/6内积与Gram.jpg" alt="内积与Gram"></li>
</ul>
</li>
</ul>
<h3 id="Gram方阵"><a href="#Gram方阵" class="headerlink" title="Gram方阵"></a>Gram方阵</h3><ul>
<li>定义，所以易知是对称阵</li>
<li>行列向量都是一样的，我们这里只讨论列向量</li>
<li>我们想想，如果这些向量每一列都相互正交，Gram矩阵应该长什么样，变成了对角阵。</li>
<li>你再想想如果每一个向量都是单位向量，那对角线变成了什么样，单位矩阵！！！</li>
<li>所以我们换一个写法，把向量组拼成矩阵，这就是矩阵的乘法，不要说没学过，就是矩阵乘向量然后拼一块。</li>
<li><p>所以$ A^T A = I$, 这就是正交阵的定义！</p>
</li>
<li><p>矩阵乘法的定义和正交矩阵的定义就来了，不管你有没有学过，反正这讲完了就都应该学过了。</p>
</li>
</ul>
<h2 id="线性映射-amp-线性变换（看时间，待定）"><a href="#线性映射-amp-线性变换（看时间，待定）" class="headerlink" title="线性映射&amp;线性变换（看时间，待定）"></a>线性映射&amp;线性变换（看时间，待定）</h2><ul>
<li>二维矩阵中的两个特殊的变换，旋转与反射。X向量乘上一个矩阵=另一个向量。</li>
<li>所以我们可以把乘矩阵理解成一种变换，这个很重要，前面大家可能接触过乘上可逆矩阵就是初等变换（行变列变），还有可能接触过过渡矩阵给空间的基做变换。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/6内积与Gram.jpg" alt="线性映射初步"></li>
</ul>
<h3 id="线性映射定义"><a href="#线性映射定义" class="headerlink" title="线性映射定义"></a>线性映射定义</h3><ul>
<li>所以我们可以粗浅的定义线性映射为乘矩阵，这种映射可以是$R^m \rightarrow R^n $的，特别的，我们把$R^n \rightarrow R^n $叫做线性变换</li>
</ul>
<h3 id="特殊-正交变换"><a href="#特殊-正交变换" class="headerlink" title="特殊-正交变换"></a>特殊-正交变换</h3><ul>
<li>更加特别的，我们把A矩阵是正交阵的这种叫做，正交变换</li>
<li>正交变换性质：保长保正交，所以体现出来就是单纯的旋转。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/9内积与正交变换.jpg" alt="正交变换"></li>
</ul>
<h2 id="由Gram初见合同与二次型"><a href="#由Gram初见合同与二次型" class="headerlink" title="由Gram初见合同与二次型"></a>由Gram初见合同与二次型</h2><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/10Gram与二次型.jpg" alt="Gram和二次型"></p>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】pre学习笔记</title>
    <url>/2022/10/21/oo-pre%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>上ly老师的OOPre课所做的一些笔记，用cpp为载体比较系统的讲解了面向对象的三大特征（封装、继承、多态），可以作为了解这方面知识的开始，但记录较为繁杂，我后续会持续做整理补充。</p>
<span id="more"></span>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A better C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array, pointer,function,struct,macro</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//封装</span></span><br><span class="line"><span class="comment">//#progma pack(1)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">int</span> j;<span class="comment">//内存对齐</span></span><br><span class="line">    <span class="type">char</span> ch:<span class="number">1</span>;<span class="comment">//位结构</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//统一控制宏，#define 。。。</span></span><br><span class="line"><span class="comment">//#ifdef ... #else ... #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*c++调用c函数</span></span><br><span class="line"><span class="comment">    extern &quot;C&quot;&#123;</span></span><br><span class="line"><span class="comment">    void md5();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载overloading</span></span><br><span class="line"><span class="comment"> void print(int);</span></span><br><span class="line"><span class="comment"> void print(char*);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*default parameter</span></span><br><span class="line"><span class="comment"> void fun(int a,int b,int c=3);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//exception处理 throw(int),抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类中的参数可以用不传地址的函数修改，原理是用了this指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆区栈区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static&amp;extern</span></span><br></pre></td></tr></table></figure>
<h2 id="0913"><a href="#0913" class="headerlink" title="0913"></a>0913</h2><ul>
<li><p>堆区栈区：堆区：malloc new的空间</p>
</li>
<li><p>static:</p>
<ul>
<li>一次构造和全局变量一起析构；</li>
<li>只能本文件使用，链接器链接不到；</li>
<li>类里，用于共享内存，不能在构造函数初始化；</li>
<li>类中函数static修饰后，可以直接用类名调用</li>
</ul>
</li>
<li>总结: static把对象的变量变成了类的变量</li>
<li>extern链接器指令<ul>
<li>全局函数自带extern</li>
</ul>
</li>
<li>声明vs定义</li>
<li>引用，安全版指针，消除了两个问题，野指针问题和半路指岔<br>如何理解向上转型和多态，多态的触发条件是重写</li>
</ul>
<h2 id="0920"><a href="#0920" class="headerlink" title="0920"></a>0920</h2><ul>
<li>设计模式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何构造一个对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;    <span class="comment">//拷贝构造（clone），深拷贝、浅拷贝</span></span><br><span class="line"><span class="comment">//会崩溃，浅拷贝只拷贝了指针地址，而同一块空间不能delete两次.</span></span><br><span class="line"><span class="comment">//所以不能clone指针</span></span><br><span class="line"><span class="comment">//下面是深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t);</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = t.i;</span><br><span class="line">    <span class="comment">//this-&gt;p = t.p;</span></span><br><span class="line">    <span class="keyword">this</span> -&gt; p = <span class="keyword">new</span> <span class="built_in">Test</span>(*t.p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line"><span class="comment">//使用指针的常见错误</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. 野指针</span></span><br><span class="line"><span class="comment">* 2. 内存泄漏</span></span><br><span class="line"><span class="comment">* 3. 重复释放</span></span><br><span class="line"><span class="comment">* 4. 返回局部变量的地址</span></span><br><span class="line"><span class="comment">* 5. 类似浅拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//free</span></span><br><span class="line"><span class="comment">//free(p);</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;<span class="comment">//不可重现错误，a的内存没有再分配那就还是10</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="comment">//解决上一个问题，但是有新问题，p不记得delete</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="built_in">memcpy</span>()浅拷贝</span><br><span class="line"><span class="built_in">clone</span>()和<span class="built_in">putAll</span>()都是只对于built_in类型深克隆</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>C追求的是运行的高效，java追求的是编程的高效</p>
</li>
<li><p>继承</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inheritance</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//implement</span></span><br><span class="line">interface A &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> implements A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const与函数返回值的关系</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">fun</span>()++ &lt;&lt; endl;</span><br><span class="line"><span class="comment">//error:fun()是l-value，常量；</span></span><br><span class="line"><span class="comment">//对于built-in type有效（如 int）</span></span><br><span class="line"><span class="comment">//但对于自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参pass by value         vs          pass by address(pointer &amp; reference)</span></span><br><span class="line"><span class="comment">//功能  read                vs          read/write</span></span><br><span class="line"><span class="comment">//性能  低效(sizeof obj)    vs          高效(sizeof int)</span></span><br><span class="line"><span class="comment">//其他  可能是拷贝构造       vs         nothing</span></span><br><span class="line"><span class="comment">//never passby value(对于自定义变量)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于拷贝构造</span></span><br><span class="line"><span class="type">const</span> Test &amp;t <span class="comment">//这样传参可以保证函数对t只读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const对于类</span></span><br><span class="line"><span class="type">const</span> Test t;</span><br><span class="line">t.<span class="built_in">fun</span>() <span class="comment">//error: 编译器认为你可能在fun里改变自己的内存</span></span><br><span class="line"><span class="comment">//所以得这样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="0927"><a href="#0927" class="headerlink" title="0927"></a>0927</h2><ul>
<li>操作符重写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">int</span> id, <span class="type">int</span> balance);</span><br><span class="line">    Account&amp; <span class="keyword">operator</span>+(<span class="type">int</span> money);</span><br><span class="line">    Account&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    Account <span class="keyword">operator</span>++(<span class="type">int</span>);    <span class="comment">//硬传参</span></span><br><span class="line">&#125;</span><br><span class="line">Account&amp; Account::<span class="keyword">operator</span>+(<span class="type">int</span> money)&#123;</span><br><span class="line">    <span class="keyword">this</span>.balance += money;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Account Account::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="function">Account <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span> -&gt; balance++</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">Account&amp; Account::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; balance ++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>new/delete</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new vs malloc</span></span><br><span class="line"><span class="comment">//new = malloc + construct</span></span><br><span class="line"><span class="comment">//delete = destruct + free  #注意顺序 delete解决申请的内存，free 解决申请内存的内存</span></span><br><span class="line"><span class="comment">//new是一个operator, 可以重写, 可以避免内存碎片化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>继承</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> cardId;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">//history</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BorrowBook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="type">int</span> cardId;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承就是共性与特性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类对父类的重写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">super.<span class="built_in">fun1</span>();<span class="comment">//java</span></span><br><span class="line">Base::<span class="built_in">fun1</span>();<span class="comment">//C++</span></span><br><span class="line"><span class="comment">//如果在子类中重写了父类的函数，98%的可能会出现super</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cpp可以多重继承<ul>
<li>所以不能使用super</li>
</ul>
</li>
<li>不能菱形继承</li>
</ul>
<h2 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h2><ul>
<li>子类的构造会调用父类的构造</li>
<li>析构同样</li>
<li>注意顺序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> m);</span><br><span class="line">&#125;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">int</span> m): <span class="built_in">j</span>(m),<span class="built_in">i</span>(j)&#123; <span class="comment">//这里会先定义i，再给j赋值，按定义的顺序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reuse</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;   <span class="comment">//虚函数，多态和后绑定 later binding 的必要条件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;   <span class="comment">//而且无论多少个虚函数一共占4byte（virtual table这是针对于类的，和对象没关系），virtual关键字自动继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Pet :: <span class="built_in">speak</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pet::speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Pet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Cat :: <span class="built_in">speak</span>()&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;miaomiao&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(Pet &amp;pet)</span></span>&#123;  <span class="comment">//  never pass by value</span></span><br><span class="line">    pet.<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;        <span class="comment">//upcasting,向上类型转换，所以子类不要削弱父类的接口。</span></span><br><span class="line">    <span class="built_in">handle</span>(cat);    <span class="comment">//???</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binding:将一次函数调用与函数入口相对性的一致</span></span><br><span class="line"><span class="comment">//代码区，函数（代码），常量，lib</span></span><br><span class="line"><span class="comment">//全局变量区：包括static，一次初始化，最后析构</span></span><br><span class="line"><span class="comment">//runtime memory:</span></span><br><span class="line"><span class="comment">//1. stack</span></span><br><span class="line"><span class="comment">//2. heap</span></span><br><span class="line"><span class="comment">//early binding</span></span><br><span class="line"><span class="comment">//later binding / runtime binding / dynamic binding</span></span><br><span class="line"><span class="comment">//有指针就没有private</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多态的实现<ul>
<li>虚函数表</li>
<li>虚指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的类型</span></span><br><span class="line"><span class="comment">//constructor: 构造不会用虚函数，不会有多态。</span></span><br><span class="line"><span class="comment">//destructor: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Test</span>(); <span class="comment">//这里需要多态，如果没有，在delete p时只会调~Test</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    ~<span class="built_in">Derived</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Test *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="built_in">fun</span>(derived);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>高级抽象！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象的越高级，就越无法描述</span></span><br><span class="line"><span class="comment">//所以</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//pure virtual(纯虚函数);</span></span><br><span class="line"><span class="comment">//一个类里面有一个纯虚函数，就是abstract class。</span></span><br><span class="line"><span class="comment">//抽象类不可被实例化，但可以被继承，子类通常要对其进行override，没有全部override的话，就是个半抽象</span></span><br><span class="line"><span class="comment">//纯虚函数可以有函数体，但通常没有</span></span><br><span class="line"><span class="comment">//抽象的作用：祖训，提纲挈领</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联(c++里叫抽象类，而java里叫interface)</span></span><br><span class="line"><span class="comment">//java不可以有多继承，但是可以实现多个接口（interface没有属性）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal . <span class="keyword">public</span> FlyObject&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Machine</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> : <span class="keyword">public</span> Machine . <span class="keyword">public</span> FlyObject&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(Bird &amp;bird)</span></span>&#123;    <span class="comment">//follow(FlyObject &amp;fO)</span></span><br><span class="line">    bird.<span class="built_in">fly</span>();             <span class="comment">//由于行为的共性，变得相关</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码重用的另一个拷贝形式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> pool[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>() :<span class="built_in">top</span>(<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pool[--top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    pool[top++] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">push</span>(i*i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要一个double的stack呢；</span></span><br><span class="line"><span class="comment">//constainer 容器</span></span><br><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    T pool[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    Stack&lt;<span class="type">double</span>&gt; doubleStack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++里有STL(standard template library)</span></span><br><span class="line"><span class="comment">//C++与java的区别：java有类库，自成体系，跨平台（用java runtime）</span></span><br><span class="line"><span class="comment">//C++与操作系统有关</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">//动态增长的万能容器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; v[<span class="number">10034</span>] &lt;&lt; endl;   <span class="comment">//[]运算符重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1018"><a href="#1018" class="headerlink" title="1018"></a>1018</h2><ul>
<li>template</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;     <span class="comment">//命名分割，防止命名重复</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyClass&#123;      <span class="comment">//一般放在头文件里</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass::Test test = <span class="built_in">new</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//iterator迭代器模式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != v.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;        <span class="comment">//这里的*，++也是运算符重载</span></span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="课程总结-OO-based-on-cpp"><a href="#课程总结-OO-based-on-cpp" class="headerlink" title="课程总结 OO based on cpp"></a>课程总结 OO based on cpp</h2><ul>
<li>封装<ul>
<li>struct、class</li>
<li>data+function</li>
<li>access control(private, public, protest)</li>
<li>this</li>
<li>construct/destruct stack/heap</li>
<li>reference/copy constructor</li>
<li>keyWord: static const </li>
</ul>
</li>
<li>继承<ul>
<li>共性与特性</li>
<li>多重继承（x）</li>
<li>不要削弱父类接口</li>
<li>构造顺序</li>
</ul>
</li>
<li>多态<ul>
<li>upcasting，传参</li>
<li>runtime binding 前绑定，后绑定</li>
<li>vitual v-table v-ptr</li>
<li>高级抽象：抽象类，接口（行为的共性）</li>
<li>template</li>
<li>性能问题出现前，不需要考虑性能</li>
</ul>
</li>
<li>真理导向，结果导向</li>
</ul>
<h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><ul>
<li>console控制台程序</li>
<li><p>两类：基于Form， 基于Web</p>
</li>
<li><p>win32 application</p>
</li>
<li>API应用程序开发接口</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>pre</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p2mips常用宏定义</title>
    <url>/2022/10/12/BUAA-CO-p2mips%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>我们知道mips的灵活性高，但是可读性差，所以要改变可读性差的问题，我们可以使用宏定义，像写c一样写汇编（）。</p>
<span id="more"></span>
<h1 id="mips常用宏定义"><a href="#mips常用宏定义" class="headerlink" title="mips常用宏定义"></a>mips常用宏定义</h1><ul>
<li>下面是一些常用的宏定义，当然你可以视情况而定，将代码段中重用次数高的，或者是用汇编写意义不太明确的代码写成宏。这样调试的时候，别人和自己看代码的时候，都会舒服许多。</li>
</ul>
<h2 id="end-the-program"><a href="#end-the-program" class="headerlink" title="end the program"></a>end the program</h2><ul>
<li>虽然重用度肯定不高（），但表意明确。</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#end the program</span></span><br><span class="line"><span class="meta">.macro</span> end</span><br><span class="line">    li  $<span class="built_in">v0</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br></pre></td></tr></table></figure>
<h2 id="write-amp-read类"><a href="#write-amp-read类" class="headerlink" title="write&amp;read类"></a>write&amp;read类</h2><ul>
<li>我们知道这些都是靠syscall实现的，所以可以这么来写</li>
<li>另外这种带参数的宏使得宏定义具有类似于C函数的特性。</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#printInt</span></span><br><span class="line"><span class="meta">.macro</span> printInt(%src)</span><br><span class="line">    <span class="keyword">move </span>   $<span class="built_in">a0</span>, %src</span><br><span class="line">    li      $<span class="built_in">v0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"><span class="comment">#getInt</span></span><br><span class="line"><span class="meta">.macro</span> getInt(%des)</span><br><span class="line">    li      $<span class="built_in">v0</span>, <span class="number">5</span></span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">move </span>   %des, $<span class="built_in">v0</span></span><br><span class="line">.end_macro</span><br><span class="line">栗子:</span><br><span class="line">getInt($<span class="built_in">s0</span>)</span><br><span class="line">printInt($<span class="built_in">s0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接打印字符串</span></span><br><span class="line"><span class="meta">.macro</span> printStr(%str)</span><br><span class="line">    <span class="meta">.data</span> </span><br><span class="line"><span class="symbol">        tmpLabel:</span>   .asciiz %str</span><br><span class="line">    <span class="meta">.text</span></span><br><span class="line">        li  $<span class="built_in">v0</span>, <span class="number">4</span></span><br><span class="line">        la  $<span class="built_in">a0</span>, tmpLabel</span><br><span class="line">        <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line">栗子:</span><br><span class="line">printStr(<span class="string">&quot;Hello CO!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印特定地址的字符串</span></span><br><span class="line"><span class="meta">.macro</span> printStrOf(%src)</span><br><span class="line">    li  $<span class="built_in">v0</span>, <span class="number">4</span></span><br><span class="line">    la  $<span class="built_in">a0</span>, %src</span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line">栗子:</span><br><span class="line"><span class="meta">.data</span></span><br><span class="line"><span class="symbol">    myStr:</span>  .asciiz <span class="string">&quot;Hello CO!&quot;</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line">    printStrOf(myStr)</span><br></pre></td></tr></table></figure>
<h2 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push&amp;pop"></a>push&amp;pop</h2><ul>
<li>我们在写函数的时候时常要用到push和pop操作，所以做好写一个宏。</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#push</span></span><br><span class="line"><span class="meta">.macro</span> push(%src)</span><br><span class="line">    <span class="keyword">sw </span>     %src, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">    <span class="keyword">subi </span>   $<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"><span class="comment">#pop</span></span><br><span class="line"><span class="meta">.macro</span> pop(%des)</span><br><span class="line">    <span class="keyword">addi </span>   $<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">lw </span>     %des, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">.end_macro</span><br><span class="line">栗子:</span><br><span class="line"><span class="symbol">    fun:</span></span><br><span class="line">    push($<span class="built_in">ra</span>)</span><br><span class="line">    push($<span class="built_in">s0</span>)</span><br><span class="line">    push($<span class="built_in">t0</span>)</span><br><span class="line">        ...</span><br><span class="line">    pop($<span class="built_in">t0</span>)</span><br><span class="line">    pop($<span class="built_in">s0</span>)</span><br><span class="line">    pop($<span class="built_in">ra</span>)</span><br><span class="line">    <span class="keyword">jr </span> $<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
<h2 id="getIndex类"><a href="#getIndex类" class="headerlink" title="getIndex类"></a>getIndex类</h2><ul>
<li>常见的有get二维数组（矩阵）的系数，还有数组的系数</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get the vector index</span></span><br><span class="line"><span class="meta">.macro</span> get_vector_index(%index, %x)</span><br><span class="line">    <span class="keyword">sll </span>    %index, %x, <span class="number">2</span></span><br><span class="line">.end_macro</span><br><span class="line"><span class="comment">#get the matrix index</span></span><br><span class="line"><span class="meta">.macro</span> get_matrix_Index(%ans, %i, %<span class="keyword">j)</span></span><br><span class="line"><span class="keyword"></span>    li      %ans, your_number_of_columns    <span class="comment">#这里填上你的矩阵列数/行数</span></span><br><span class="line">    <span class="keyword">multu </span>  %i, %ans</span><br><span class="line">    <span class="keyword">mflo </span>   %ans</span><br><span class="line">    <span class="keyword">add </span>    %ans, %ans, %<span class="keyword">j</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">sll </span>    %ans, %ans, <span class="number">2</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
<blockquote>
<p>待补充</p>
</blockquote>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P2</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p2mips汇编翻译C代码典例</title>
    <url>/2022/10/12/BUAA-CO-p2mips%E6%B1%87%E7%BC%96%E7%BF%BB%E8%AF%91C%E4%BB%A3%E7%A0%81%E5%85%B8%E4%BE%8B/</url>
    <content><![CDATA[<p>汇编语言是一种比机械码稍高级一点的语言，而MIPS的汇编语言是一种专用于MIPS架构的CPU的汇编语言，相较于ARM，X86等现在主流的架构的汇编语言，MIPS较为简单，适合入门。<br>MIPS汇编语言是可以一对一翻译成机械码的，每条指令的翻译规则不同，这里需要查手册来解决。<br>至于我们学的C/C++等高级语言，也可以翻译成汇编语言，这个过程叫编译，一般来说编译器可以办成这件事，但对于我们需要学习MIPS的人来说，这需要咱们自己来。</p>
<span id="more"></span>
<h1 id="mips汇编翻译C代码典例-经验"><a href="#mips汇编翻译C代码典例-经验" class="headerlink" title="mips汇编翻译C代码典例/经验"></a>mips汇编翻译C代码典例/经验</h1><blockquote>
<p>说是翻译C代码，其实要是在介绍如何MIPS汇编语言实现高级语言中出现的条件、循环、子程序结构。</p>
</blockquote>
<h2 id="二维数组的写法-内存的申请"><a href="#二维数组的写法-内存的申请" class="headerlink" title="二维数组的写法/内存的申请"></a>二维数组的写法/内存的申请</h2><ul>
<li>写法一：比较的基础，<code>data: .sapce memory_size_bit</code>，注意单位是bit</li>
<li>写法二：辨析.word/.byte/.half的两种写法(以.word为例)</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">data:</span>   <span class="meta">.word</span> <span class="number">64</span>        <span class="comment">#以字的形式储存64这个数，而不是像.space一样申请64字的内存</span></span><br><span class="line"><span class="symbol">data:</span>   <span class="meta">.word</span> <span class="number">0</span> : <span class="number">64</span>    <span class="comment">#以0为初始数据填到64个字的内存里，这才是我们想达到的效果</span></span><br><span class="line"><span class="comment">#所以你也可以</span></span><br><span class="line"><span class="symbol">data:</span>   <span class="meta">.word</span> <span class="number">1</span> : <span class="number">64</span>    <span class="comment">#得到64个(int)1</span></span><br></pre></td></tr></table></figure>
<h2 id="打好macro"><a href="#打好macro" class="headerlink" title="打好macro"></a>打好macro</h2><ul>
<li>打好macro很重要，他的功能类似于函数，能够消除ctrl+CV的代码重用（ly：这是一个很糟糕的事情），提高代码的可读性。</li>
<li>有很多常用的macro比如print、read、end、push等这些，详细请见我的另一个博客：<a href="http://volcaxiao.github.io/2022/10/12/mips常用宏定义/">mips常用宏定义</a></li>
<li>但我们每一次写mips都得自己手打macro，实在是不太优雅，于是我们可以用脚本来实现这样一个无脑功能。</li>
<li>通过脚本新建文件</li>
</ul>
<h2 id="函数一般模板写法"><a href="#函数一般模板写法" class="headerlink" title="函数一般模板写法"></a>函数一般模板写法</h2><ul>
<li>我们在函数调用的时候基本上可以遵循这样一个模板</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 入栈</span></span><br><span class="line">push($<span class="built_in">ra</span>)</span><br><span class="line"><span class="comment"># push(...)</span></span><br><span class="line"><span class="comment"># 传参</span></span><br><span class="line"><span class="keyword">move </span>   $<span class="built_in">t0</span>, $<span class="built_in">a0</span></span><br><span class="line"><span class="comment">#函数过程</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 出栈</span></span><br><span class="line"><span class="comment"># pop(...)</span></span><br><span class="line">pop($<span class="built_in">ra</span>)</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="keyword">jr </span>     $<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>虽然模板很简单，但我们还是得注意几个小问题</p>
</li>
<li><p>我们一般会把a_n作为函数的参数传递（约定俗成，本质上讲a_n和t_n啥的都是一样的，但是不约定规范，可读性和可维护性都会大打折扣）</p>
</li>
<li>push和pop要遵循LIFO(last in first out)，可不能一顿无脑pp，先push的要后面pop，要不然就会出现你的return到了一个不知名的地方。（很诡异</li>
<li>调用函数时，调用者里的用过的t函数一般要push进栈，为啥呢，也是约定俗成，具体请看下一节<a href="#ts寄存器之辩">t/s寄存器之辩</a></li>
</ul>
<h2 id="t-s寄存器之辩"><a href="#t-s寄存器之辩" class="headerlink" title="t/s寄存器之辩"></a>t/s寄存器之辩</h2><ul>
<li><p>这仅是我按照“t寄存器调用者维护，s寄存器被调用者维护”的一些个人的理解，自己看教程的时候其实不是很明白这句话的意思，但在后面打代码的过程中自己悟到了一些。</p>
</li>
<li><p>t寄存器调用者维护：</p>
<ul>
<li>t是指temporary，你把光标放置到Mars的寄存器处能够得到这个提示，意思就相当于临时变量。</li>
<li>由调用者维护的意思是你在调用别的函数时，你得保证你的t寄存器调用前和return后不会发生变化（类比在C中的临时变量），所以你应该去维护他。</li>
<li>一般的维护方法是用栈，在调用前先把t压入栈，调用后再把t pop出来，于是你的t就不会改变。</li>
</ul>
</li>
<li><p>s寄存器被调用者维护：</p>
<ul>
<li>s的含义是saved temporary，是指被调用函数不应改变s寄存器的值，就算要改变也应该先入栈最后再出栈。</li>
<li>总之，被调用函数在编写时应该要保证，函数前后s寄存器的值不发生变化。</li>
</ul>
</li>
<li><p>这是约定下来的规范，只有这样，用汇编这种灵活的语言才不会出岔子。</p>
</li>
</ul>
<h2 id="条件循环语句固定写法"><a href="#条件循环语句固定写法" class="headerlink" title="条件循环语句固定写法"></a>条件循环语句固定写法</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li>最基础的肯定还是if-else结构的语句，大致可以按照下面的写法：</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>另外进阶一点的是if-else_if-else结构</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最后是switch语句</li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul>
<li>固定for和if的写法，记得在for最后写上i++ j begin</li>
</ul>
<h3 id="多重逻辑判断"><a href="#多重逻辑判断" class="headerlink" title="多重逻辑判断"></a>多重逻辑判断</h3><ul>
<li>多重逻辑条件的写法</li>
</ul>
<h2 id="mips一般代码建议"><a href="#mips一般代码建议" class="headerlink" title="mips一般代码建议"></a>mips一般代码建议</h2><ul>
<li>写比对的C代码</li>
<li>写好注释</li>
<li>写好label</li>
<li>写好macro</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P2</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】从线性方程组到矩阵讲课材料</title>
    <url>/2022/10/08/%E4%BB%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E5%88%B0%E7%9F%A9%E9%98%B5%E8%AE%B2%E8%AF%BE%E6%9D%90%E6%96%99/</url>
    <content><![CDATA[<p>朋辈辅导师第三周直播课-空间解析几何基础的备课资料，大家有需要自取。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/D98E660DE6A00FEC3AC14AF6FC383427">从线性方程组到矩阵</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="第六周备课本"><a href="#第六周备课本" class="headerlink" title="第六周备课本"></a>第六周备课本</h1><ul>
<li>我在私下里做了一个小调查哈，知道大家的各班的学习进度以及学习的顺序都不太一样，有的先开始学行列式，有的先开始学向量组，有的先开始学线性方程组，各班都不太一样，但考虑到这已经不是期中的内容了，而到期末呢，大家这些肯定都是要学的，所以我就按着我对于高代的学科体系构建的理解来讲这一次课，每个地方都会涉及到，大家在这个阶段能接受的内容我会多讲，然后后面的内容呢我会随着体系的构建把这些知识给逐步的完善。</li>
<li>对于这些内容呢，已经学过的同学加深一遍印象，没有学过的同学呢，我会浅处着手，再来深入，大家也当预习+学习。大家有什么问题的话，也请及时反馈，可以实时在聊天区表示疑惑，可以在直播的最后填写学支中心的反馈二维码。</li>
<li>我对我们的学习进度简要的设计了一下，我会在9、12、15周带来常规的三次直播，当然期中期末的时候也会有串讲，这是我的暂定进度，大家可以参考一下。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">直播时间</th>
<th style="text-align:center">直播主题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第三周</td>
<td style="text-align:center">空间解析几何基础</td>
</tr>
<tr>
<td style="text-align:center">第六周</td>
<td style="text-align:center">从线性方程组到矩阵</td>
</tr>
<tr>
<td style="text-align:center">第九周</td>
<td style="text-align:center">向量空间与欧式空间</td>
</tr>
<tr>
<td style="text-align:center">第十二周</td>
<td style="text-align:center">特征根与相似变换</td>
</tr>
<tr>
<td style="text-align:center">第十五周</td>
<td style="text-align:center">二次型与合同变换</td>
</tr>
</tbody>
</table>
</div>
<p>我和另外一位辅导师一起做高代的直播，我们的安排呢大致就是我给大家过一遍知识点，然后他来给大家讲解例题。</p>
<p>我们今天呢来讲四个概念，线性方程组、向量组、行列式，这几个东西呢，相互交汇，相互依存，很多概念，大家要将他们统一到自己的知识体系结构中，不能学乱了。</p>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h3 id="线性方程组的表示"><a href="#线性方程组的表示" class="headerlink" title="线性方程组的表示"></a>线性方程组的表示</h3><ul>
<li>向量表示</li>
<li>矩阵表示</li>
</ul>
<h3 id="线性方程组的求解"><a href="#线性方程组的求解" class="headerlink" title="线性方程组的求解"></a>线性方程组的求解</h3><ul>
<li>三类初等变换，同解变形</li>
<li>消元法与矩阵消元法</li>
</ul>
<h3 id="齐次方程与非齐次方程"><a href="#齐次方程与非齐次方程" class="headerlink" title="齐次方程与非齐次方程"></a>齐次方程与非齐次方程</h3><ul>
<li>解的讨论（联系我上次课讲的，维度与约束条件的概念，其实也就是解空间的维度与秩的关系）<ul>
<li>我们方程组的解的几何意义就是在高维空间中超平面的交线</li>
<li>齐次方程一定有解（0解）</li>
<li>当齐次方程的秩小于n时，有无穷多解（多维解空间）</li>
<li>$非齐次方程AX = B有解\Leftrightarrow r(A) = r(A|B) $</li>
<li>无解显而易见</li>
</ul>
</li>
<li>解的联系<ul>
<li>齐次方程通解的形式</li>
<li>非齐次方程的解：<blockquote>
<p>$\forall X, Y是AX = \beta 的解，则AX= \beta ,AY = \beta ,两式相减，A(X-Y) = 0,即X-Y为AX= 0方程的解。 $<br>$\therefore 若AX= \beta 有解Y_0，则对于方程的解X，X-Y_0 = t_1\varepsilon_1 + …… + t_{n-r}\varepsilon_{n-r}$<br>得到非齐次方程的通解</p>
</blockquote>
</li>
<li>$XA = B $的求解问题</li>
<li>给出非齐次方程的特解，相减构造导出方程的基，通过A的秩判断解空间的维度，算出通解。</li>
<li>判断X是否为 $AX = \beta $ 的解：代入即可</li>
</ul>
</li>
</ul>
<h2 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h2><h3 id="n维向量的定义与意义"><a href="#n维向量的定义与意义" class="headerlink" title="n维向量的定义与意义"></a>n维向量的定义与意义</h3><ul>
<li>首先带着一种对于我们能够感知到的三维的向量的认识去看这件事，升到n维以后，空间性质肯定还是存在，就比如说我们讨论的齐次方程与非齐次方程的解，其实就是一个讨论高维空间中超平面的交线的问题。</li>
<li>函数参数，写程序等等，函数传入了6个参数，其实就是构造了一个6维的空间，所以说我们生活在一个3维的空间里，这个维度是长宽高。但我们带着一种多面多元的视角去看世间，多维空间随处可见。</li>
</ul>
<h3 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h3><ul>
<li>$定义：对于一组向量\{\alpha_1, \alpha_2, ……, \alpha_n \}，若有一组k_n,与向量相乘加等于0，则k_1 = k_2 = …… = k_n = 0 , 则称\{\alpha_1, \alpha_2, ……, \alpha_n\}线性无关$<ul>
<li>联想一下，我们第一章的不共面定理不共线定理怎么说的。</li>
<li>所以相应的，不满足就是线性相关</li>
<li>光看这个定义，有点抽象，看不出什么来。</li>
</ul>
</li>
<li><p>相关性质</p>
<ul>
<li>相关的线性表示（及其逆，单边法则）<blockquote>
<p>由线性相关的定义可推出，其中某个向量可以由其余向量线性表示，这又可推出其中的某个向量可以写成前面的向量的线性组合。<br>所以我们逆过来看，线性无关，等价于<br>$每一个向量都不可由前面的向量表示（\alpha_i = 0） $<br>这我们叫做单边法则</p>
</blockquote>
</li>
<li>大数法则/不大法则<blockquote>
<p>我们先来看，一个向量组被另一个向量组表示被表示的意义。<br>$S_1组被S_2组表示\Leftrightarrow \forall \alpha_i \in S_1 , \alpha_i 可以被 \beta_j \in S_2 表示 $<br>大的向量组可以被小的向量组表示，大组必相关<br>（逆否命题：若A组无关，但可以被B组表示，则A比B小 ——不大法则）<br>为啥可以被表示，我们可以理解了后面的秩再来说，是不是说AX=B有解啊。</p>
</blockquote>
</li>
<li>表示的传递性<blockquote>
<p>$我们说S_2 能被S_1表示，S_1能被S_0表示，则S_2能被S_0表示$</p>
</blockquote>
</li>
<li>唯一表示法则<blockquote>
<p>$\{\alpha_1,……,\alpha_n\}无关,\{\alpha_1,……,\alpha_n,\beta\}相关，则\beta 由\{\alpha_1,……,\alpha_n\}唯一表示 $</p>
</blockquote>
</li>
<li>子组相关法则<blockquote>
<p>子组相关，全组必定相关<br>proof:<br>$k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p = 0 (k_1,……,k_p不全为零) $<br>$\therefore k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p + 0\alpha_{p+1} + …… + 0\alpha_n  = 0$</p>
</blockquote>
</li>
<li>等数法则<blockquote>
<p>$\{\alpha_1,……\alpha_p\},\{\beta_1,……\beta_q\}两组无关，且能相互表示，则p=q $<br>由不大法则可证</p>
</blockquote>
</li>
<li>长短法则<blockquote>
<p>长相关则短相关，短无关则长无关<br>看具体怎么理解了，有的老师说“如果矩阵A的子矩阵A0的各行（列）线性无关，则由A0的这些行（列）扩充得到的A的行（列）线性无关。”<br>这是从大到小，从矩阵看问题<br>也可以这么理解（从小到大，从向量组）：</p>
</blockquote>
</li>
</ul>
</li>
<li><p>这些是不是很难理解又臭又长，高等代数是一门极为统一连贯的科目，所以我们由表及里，定义了极大线性无关组，来帮助我们更好的理解线性相关与线性无关。</p>
</li>
<li><p>极大线性无关组</p>
<ul>
<li>定义：我们定义在全组中如果有一个子组线性无关，再加上其他任意一个元素，就会线性相关，我们称之为极大无关。</li>
<li>所以由唯一表示法则可以知道，全组中的其余元素均可由极大无关组唯一表示。</li>
<li>我们来定义一个等价的概念<blockquote>
<p>$S_1，S_2相互表示，则S_1等价于S_2 $<br>所以极大无关组与全组等价，且由于表示的传递性，任意两个极大组之间等价。<br>所以由于等数法则，任意两个极大组之间具有相同的个数。</p>
</blockquote>
</li>
<li>定义秩rank<blockquote>
<p>这样，我们就可以来定义向量组的秩了，我们就定义极大无关组中元素的个数叫做秩。<br>$所以在一个n维空间R^n，我们可以把它看作是一个有无限多向量的向量组，$<br>$那么的它秩是什么，我们选取一组标准正交基（坐标系的坐标，可以用三维来理解），$<br>$是不是说，再这个标准正交基外任意找一个向量，这个向量都能被这组向量表示啊，$<br>$所以rank(R^n) = n $<br>那我们继续想，我不必选择标准正交基是吧，我任意选n个线性无关的向量，他们是不是也是一个极大无关组啊，所以他们也能当作是基。</p>
</blockquote>
</li>
<li>秩与相关性的联系</li>
</ul>
</li>
<li><p>空间的基与解空间（略讲，联系着前面线性方程组来讲）</p>
<ul>
<li>由极大组引出基向量组的概念<blockquote>
<p>是不是隐隐约约感觉这个秩和维度应该是有点关系的<br>所以我们可以用一个极大无关组来作为一组基。<br>在这个空间的其他向量都被它们表示，怎么表示，我就可以定义出广义坐标。<br>…<br>但注意，这里的向量组是有序的，改变顺序，坐标就会变。</p>
</blockquote>
</li>
<li>有序无关组与广义坐标</li>
<li>线性方程组的解由基来表示<blockquote>
<p>所以，你们看过这些以后再来看线性方程组，以及它的解，是不是也就是用坐标来表示，它们的通解的表达形式中仿佛看到了基的出现，所以它们是不是也构成空间？这个我们点到为止，下次课我在来拿出空间和你们细说。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>我们用前面的相关性质来证明和定义了极大组与秩，我们再用秩的定义来更好的理解前面的这些性质与相关和无关的深入理解。</p>
</li>
<li>很简单，记住两条。</li>
<li>一个向量组的元素个数比秩大，就线性相关，等于秩就线性无关。</li>
<li>一个向量组被另一个向量组表示，就是说能被另一个组生成，所以秩肯定不会变大。</li>
<li>所以我们再来理解这些东西</li>
</ul>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><blockquote>
<p>矩阵只是记号，向量拼一块就是矩阵</p>
</blockquote>
<ul>
<li>矩阵的运算<ul>
<li>主要就是乘法及其运算性质</li>
<li>我们能看到这个直接定义并不好看。所以我更推荐大家按照下面这种理解。</li>
<li>矩阵分块<blockquote>
<p>我们在线性方程组的矩阵表示方法中已经看到AX是怎么定义的。<br>所以我们可以推广，把B这个矩阵按列分块成$(\beta_1,……,\beta_q),则AB = (A\beta_1, A\beta_2 , ……,A\beta_q) $</p>
</blockquote>
</li>
<li>所以得匹配才能乘，大家也能看出来其中的性质AB != BA 这种</li>
<li>但是特殊情况，方阵，单位阵。</li>
</ul>
</li>
<li><p>矩阵的可逆与正交</p>
<ul>
<li>可逆的定义及相关性质<blockquote>
<p>$若\exists B,AB=BA=I，则称A为可逆阵，B为A的逆阵,记作：A^{-1} = B $</p>
</blockquote>
</li>
<li>性质：<blockquote>
<p>$(ABC)^{-1} = C^{-1}B^{-1}A^{-1} $(proof)<br>行列式不为零则可逆<br>……</p>
<ul>
<li>逆阵唯一性<script type="math/tex; mode=display">
AB =AC =I  
则B = BI = B(AC) = (BA)C = C</script></li>
<li>保可逆，反序可逆<br>A可逆，B可逆，则AB可逆<br>$proof: ABB^{-1}A^{-1} = I $<br>若AB = I ，BA也可逆。</li>
</ul>
</blockquote>
</li>
<li>正交的定义及其相关性质<blockquote>
<p>$A^TA = I,即A^{-1} = A^T,则称A为正交阵 $<br>性质：矩阵乘的转置,与矩阵乘的求逆类似</p>
<ul>
<li>保长、保内积、保正交<br>$我们知道向量的模长度公式是吧，对于列向量X，它的模长为||X||^2 = X^TX(内积的表示) ，所以列向量AX(A为正交阵)为||AX||^2 = X^TA^TAX ——保长性$<br>$保内积类似，(X,Y) = (AX,AY) = X^TY $<br>$保正交:两种理解：<br>A正交，B正交，则AB正交<br>X \perp Y \Leftrightarrow AX \perp AY $</li>
<li>线性变换初步<br>所以我们从三维来理解一下，一个向量乘上一个矩阵后，变了，但是长度没变，两个向量之间的内积没变，两个向量该垂直的垂直，所以我们把这种变换，保长保内积保正交的变换，叫做线性变换/正交变换，矩阵又有了它的另一层含义。</li>
<li>每列为单位向量且相互正交，且则阵正交<br>用矩阵乘法去理解。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>矩阵的秩</p>
<ul>
<li>阶梯阵概念，及其与向量组秩的联系。<blockquote>
<p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>所以三种同解变形，其实就代表着三种初等变换。</p>
</blockquote>
</li>
<li>秩一阵<blockquote>
<p>我们来看一个一点的矩阵，秩一阵，可分解为两个向量之间的乘积。</p>
</blockquote>
</li>
<li>降秩定理<blockquote>
<p>$r(AB) \le r(A) , r(B) (用AB被A表示证明一边，用转置证明另一边)$</p>
</blockquote>
</li>
<li>满秩、方程组解、可逆之间的关系<blockquote>
<ul>
<li>满秩则有唯一解<br>$proof: \because r(A) = n $<br>$\therefore \{\alpha_1,……,\alpha_n\}可作为一组基 $<br>$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>$坐标即为唯一解 $</li>
<li>满秩则可逆<br>$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="行列式（看时间待定）"><a href="#行列式（看时间待定）" class="headerlink" title="行列式（看时间待定）"></a>行列式（看时间待定）</h2><ul>
<li>行列式的定义<ul>
<li>逆序数</li>
</ul>
</li>
<li>余子式与余子阵</li>
<li>行列式的计算<ul>
<li>对角阵</li>
<li>余子阵展开</li>
</ul>
</li>
<li>相伴逆公式，克莱姆法则<ul>
<li>理解其与秩、可逆，方程组解之间的关系</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】空间解析几何讲课材料-ppt、视频、备课本等</title>
    <url>/2022/10/08/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E8%AE%B2%E8%AF%BE%E6%9D%90%E6%96%99-ppt%E3%80%81%E8%A7%86%E9%A2%91%E3%80%81%E5%A4%87%E8%AF%BE%E6%9C%AC%E7%AD%89/</url>
    <content><![CDATA[<p>朋辈辅导师第三周直播课-空间解析几何基础的备课资料，大家有需要自取。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/03BA02043D71BD977500323FA290621A">空间解析几何</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="空间解析几何总结"><a href="#空间解析几何总结" class="headerlink" title="空间解析几何总结"></a>空间解析几何总结</h1><p>各位同学大家好，我是来自北航学业与发展支持中心的朋辈辅导师肖灿，今天带来的是工科高等代数空间解析几何基础的直播</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>这里的知识大多比较基础，只是高中知识的一点拓展，还有许多内容是高中就学过的。我想，对与能考上北航的同学们来说，这些知识不成什么问题，因此，过于基础的内容我就不讲了。</li>
</ul>
<h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><ul>
<li>共线与不共线其实就代表着你们后面要学的线性相关和线性无关。</li>
<li>不共面定理的延申：混合积，向量组的秩</li>
<li>坐标定义在后面的空间部分也要延伸，三个相互正交的单位向量就是三个线性无关的基底</li>
<li>叉乘的物理背景：力矩</li>
<li>注意叉乘的方向，所以我们知道，叉乘不满足交换律，我们把这个叫反交换律，但是它满足分配律和结合律。</li>
<li>可以用方向余弦来表示单位向量，所以理所应当的得到余弦公式<ul>
<li>其实就是单位向量在三坐标轴上的投影</li>
</ul>
</li>
</ul>
<h2 id="空间曲线"><a href="#空间曲线" class="headerlink" title="空间曲线"></a>空间曲线</h2><ul>
<li>在看参数方程是体现了一种维数的思想，空间曲线是一维的物体所以只有一个参数</li>
<li>拓展：空间曲面的参数方程：两个参数</li>
<li>由于方程H是由方程组消去 z 后得到的结果，因此当 x , y 和 z 满足方程组时，前两个数 x , y 必定满足方程H，这说明曲线C 上的所有点都在由方程H所表示的曲面上.</li>
</ul>
<hr>
<p>我们前面研究的都是空间曲线和空间曲面，我们接下来来研究两个特殊的东西。——平面与直线</p>
<h2 id="空间平面"><a href="#空间平面" class="headerlink" title="空间平面"></a>空间平面</h2><ul>
<li>参数方程和一般方程之中体现自由度和约束条件的关系<ul>
<li>在三维空间中去看待一个约束条件取得的效果就是降一维，这就是为什么我们说二维空间中的一个曲线方程在三维的空间中是一个曲面。这也是为什么我们在后面的大家现在在学的线性方程组的研究中会有解空间的维度和秩之间的关系的问题，注意，这种空间的思想需要在整个高代的学习过程中一直运用，大家一定一定要理解好。</li>
</ul>
</li>
<li>而点法式，一般式都很容易看出法向量来，所以这里就不多说啦</li>
</ul>
<h2 id="空间直线"><a href="#空间直线" class="headerlink" title="空间直线"></a>空间直线</h2><ul>
<li>空间直线的参数式是最好看最直观的，在一个点的一个方向上延申，我们可以通过它来转化</li>
<li>两面式转化成参数式不多说，点向式和参数式之间的相互转换也不多说（他们之间的相互转换就不多说了，大家要有需求的话发弹幕告诉我，人多的话我就讲讲。）</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>空间解析几何基础，是大家期中考的主要内容，好像占70%，所以我的讲课中会大量的引用期中题作为例题，让大家体会一下难度。但是大家不用担心，这些对于大家来说不成问题。</li>
<li>看，是不是不难，但是大家也别对工科高代这门课掉以轻心，毕竟是六学分的大课，以后可能都不会再有课比这课学分多了</li>
<li>想拿高分不难，但是如果你只拿一个比较低的分或者是中等分，那你会和别人拉开很大的差距。</li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p0状态编码分享</title>
    <url>/2022/10/04/BUAA-CO-p0%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>时隔半个月，终于有了更新，主要是一些P0的经验分享——状态编码，当然有一些零零散散的芝士点，会在后面补足的，记得催催。。。</p>
<span id="more"></span>
<h1 id="状态编码的分享"><a href="#状态编码的分享" class="headerlink" title="状态编码的分享"></a>状态编码的分享</h1><h2 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h2><p>相信的大家都开始写状态机了，FSM分为三个部分，主要是状态转移、状态储存、状态输出，其中状态转移、状态输出主要是组合逻辑的操作，因此将这两个模块封装后，可以进行类似于组合逻辑的电路的黑箱测试的操作。<br>当然，我们可以用分析电路(analyze circuit)的功能，非常方便的得到我们想要的电路。<br>这些问题都解决了，留给我们自己的事情就只剩下状态编码的选择、状态转移（输出）的真值表了。</p>
<blockquote>
<p>当然，还有计算机组成课程历史上的一颗明珠——qshr机（指路<a href="http://cscore.buaa.edu.cn/#/discussion_area/579/689/posts">自主研发：权尚浩然型有限状态机</a>），可以省去选状态编码这种憋死选择困难症的操作，直观可读性强，是计算机仿真史上的一个重大发明，虚拟现实专业的同学也应该好好学习借鉴</p>
</blockquote>
<hr>
<p>所以我们来重点看看选择状态编码的门道。<br>这里我们以logisim导航这一题为例，看看不同的状态编码的选择之间的差别。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#状态转移图">状态转移图</a><br><a href="#自己乱编的码">自己乱编的码</a><br><a href="#8421顺序编码">8421顺序编码</a><br><a href="#格雷码">格雷码</a><br><a href="#独热码">独热码</a><br><a href="#瞻仰qshr机">瞻仰qshr机</a></p>
<h2 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h2><ul>
<li>这道题的状态转移图，其实不太好用常见的圈箭头的表示，倒是路径图已经有了，直接在这上面看着打表会方便一点<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1自己的编码图.jpg" alt="自己乱编码的图"></li>
</ul>
<h2 id="自己乱编的码"><a href="#自己乱编的码" class="headerlink" title="自己乱编的码"></a>自己乱编的码</h2><blockquote>
<p>编码中还需要注意一个问题，就是我们输入的三位数从高位到地位应该是(l2,l1,l0),所以在我们打表的时候的命名请按照(l2,l1,l0,d1,d0)的顺序(分别表示location,direction),同样输出我们使用(L2,L1,L0,hit)的顺序。这样符合逻辑！</p>
<p>在打完表以后，也要注意，分离器(splitter)分离出来的位次依次是(l0,l1,l2)，所以为了好看，打完表以后，把输入输出的顺序调一下！调成(l0,l1,l2,hit)</p>
</blockquote>
<ul>
<li>上图是我自己的胡乱编码，其实也不胡乱，中间三个状态是独热码表示。他的效果如下：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1自己码.png" alt="自己码"></li>
</ul>
<h2 id="8421顺序编码"><a href="#8421顺序编码" class="headerlink" title="8421顺序编码"></a>8421顺序编码</h2><ul>
<li>顺序编码是我们最好理解的一种编码，最符合我们人类的直觉往往最不符合计算机的直觉，因为虽然顺序编码的最为紧密（紧密也有紧密的好处），但是由于相邻两个状态之间的变化太大，实际的硬件的寄存器很难做到同时发生变化，所以出错的概率很高（我们叫做毛刺现象）。</li>
<li>所以在我们平常的作业中使使可能没太大问题，但是实际应用中用的很少。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2_8421码.png" alt="8421码"></li>
</ul>
<h2 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h2><ul>
<li>格雷码的特点就是解决了顺序码的缺点，相邻的两状态之间编码之变一位，就不会出现毛刺的现象。</li>
<li>但是格雷码最大的问题在于设计的难度</li>
<li>其实格雷码最好是初态和末态也只差一位，但我实在有点找不到，有能够找到的dl可以在评论区指出。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3_格雷码.png" alt="格雷码"></li>
</ul>
<h2 id="独热码"><a href="#独热码" class="headerlink" title="独热码"></a>独热码</h2><ul>
<li>独热码的编码可能是唯一一个计算机好理解，人也好理解的编码，再加上他一下只需要变动两次（置一+置零），所以毛刺的概率低。</li>
<li>而且，虽然说编码不太紧密，用到的寄存器位数多（也就是触发器多），但是这也使得组合逻辑电路会精简一些，大家可以看接下来的实现。</li>
<li>就是这两个特点使得独热码在实际应用中十分广泛。<blockquote>
<p>独热码适合写条件复杂但是状态少的状态机；<br>  格雷码适合写条件不复杂但是状态多的状态机。</p>
</blockquote>
</li>
<li>这里分享一个小妙招，格雷码一个一个的在Analysis里打表不方便（位数太多了），而其实独热码大多数位数都是零，所以可以先构造出这样的电路<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/独热码构造捷径.png" alt="独热码构造捷径"></li>
<li>然后再Project -&gt; Analyze circuit,出来的初始真值表就是全置零的啦。</li>
<li>如下图（独热码的真值表太长了我就不晒出来了）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4_独热码.png" alt="独热码"></li>
<li>当然这肯定不是最简化的电路，你可以根据要求自己搭更加简单的电路，包括说用复用器来实现更简化，在这里就不赘述了。</li>
</ul>
<h2 id="瞻仰qshr机"><a href="#瞻仰qshr机" class="headerlink" title="瞻仰qshr机"></a>瞻仰qshr机</h2><ul>
<li>对于qshr机，评论区zytgg的评论一针见血：<blockquote>
<p>是否等价于把独热编码的状态机按位拆开？</p>
<ul>
<li>确实，独热码的思路就是有多少状态就用多少触发器，qshr机也就是这么个道理，每一个状态都用一个寄存器存下，和我们画状态转移图的时候的思路是一致的。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>介于qshr机在计算机仿真史上做出的贡献，我们看到了，对于这个题navigation来说，有很直观的状态转移图，还记得我在最开始说的嘛，”这道题的状态转移图，其实不太好用常见的圈箭头的表示，倒是路径图已经有了，直接在这上面看着打表会方便一点”，不用打表，题图即是状态转移图！！！</p>
</blockquote>
<ul>
<li><p>所以我们把原基础的qshr机封装一下，让他看起来更具有仿真的意味！<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/qshr机改良版.png" alt="qshr机封装版"></p>
</li>
<li><p>虽然只是对qshr机的拙略模仿，但是你们不觉得很酷嘛，这很符合我对未来的想象（）。</p>
</li>
</ul>
<hr>
<h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><ul>
<li>其实有限状态机核心的部分就是状态转移，状态转移核心的部分就是编码选择和打表，掌握好了这几个地方，封装再好点（便于调试），有限状态机就不难啦。</li>
<li>感谢qshr大佬的灵感支持！</li>
<li>感谢zyt、cys等佬的理论拓展！</li>
<li>有不妥之处请各位大佬指出，谢谢观看！</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>P0</tag>
        <tag>状态编码</tag>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>工科大物-热力学基础总结</title>
    <url>/2022/09/13/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E7%83%AD%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>系边上老师的课边做的一些笔记以及自己的一些想法，但有时候可能会拖更，分享给大家，有不妥之处，敬请评论区指正。</p>
<span id="more"></span>
<h1 id="热力学总结"><a href="#热力学总结" class="headerlink" title="热力学总结"></a>热力学总结</h1><h2 id="内能、功、热量、热一律"><a href="#内能、功、热量、热一律" class="headerlink" title="内能、功、热量、热一律"></a>内能、功、热量、热一律</h2><ul>
<li>系统的状态发生变化 -&gt; 热力学过程<ul>
<li>弛豫时间：系统由非平衡态达到平衡态所需的时间</li>
<li>准静态过程（平衡过程）：过程无限（理想过程）缓慢，每个中间过程都无限接近平衡态（每一点都满足 $ PV = \nu RT$），可以用P-V图表示。</li>
</ul>
</li>
<li>做功（机械能转化的量度）：在准静态过程中：<blockquote>
<p>$状态从 (P_1,v_1,T_1)到(P_2,V_2,T_2)$<br>$ A = \int _{1 \rightarrow 2} \vec{F} \cdot d \vec{l} $<br>$ = \int_{1 \rightarrow 2} P \cdot S \cdot dl = \int _{v_1} ^{v_2} P dV $</p>
<ul>
<li>在P-V图上体现为始末状态所围的面积</li>
<li>$ \Delta V &gt; 0 气体对外界做正功  ，在P-V图上，顺时钟循环 A &gt; 0 $</li>
</ul>
</blockquote>
</li>
<li>热量也是一种能量交换的度量！</li>
<li>热力学第一定律：<blockquote>
<p>$ 系统内能的增量：\Delta E = A’ + Q (A’ 为外界对系统做的功，Q为外界向系统传递的热量) $<br>$\therefore 外界对系统传递的热量 Q = \Delta E + A$<br>$ Q = dE + A$</p>
</blockquote>
</li>
</ul>
<h2 id="气体的摩尔热容量"><a href="#气体的摩尔热容量" class="headerlink" title="气体的摩尔热容量"></a>气体的摩尔热容量</h2><ul>
<li>$热容C：C = \lim _{ \Delta T \to 0 } \frac{ \Delta Q }{ \Delta T} = \frac{dQ}{dT} $</li>
<li>$比热容：单位质量物质的热容 C_b = \frac{dQ}{mdT} : J/Kg \cdot K$</li>
<li>$ 摩尔热容：J / mol \cdot K$</li>
<li>定容摩尔热容：<blockquote>
<p> $ C_{V,m} = \frac{ (dQ)_V }{ \nu dT } = \frac{dE}{dT}+ P\frac{dV}{dT} \stackrel{dV=0}{=} \frac{dE}{dT} = \frac{i}{2}R $</p>
</blockquote>
</li>
<li>定压摩尔热容：<blockquote>
<p>$ C_{P,m} = \frac{dE}{dT}+ P\frac{dV}{dT} = \frac{i}{2}R+ P\frac{dV}{dT} \stackrel{PV=RT}{==} (\frac{i}{2}+1)R $</p>
</blockquote>
</li>
<li>比热容比（泊松比）：定压摩尔热容比定容摩尔热容</li>
<li>准静态过程的热量的计算</li>
</ul>
<h2 id="等值过程的过程方程和能量关系"><a href="#等值过程的过程方程和能量关系" class="headerlink" title="等值过程的过程方程和能量关系"></a>等值过程的过程方程和能量关系</h2><blockquote>
<p>我们研究一个过程可以着重研究四个方面：其特点、过程方程、过程曲线、能量关系。</p>
</blockquote>
<ul>
<li>等压过程<blockquote>
<p>$ P=const, \frac{V}{T}=const$<br>$ A = \int _{V_1}^{V_2} P dV = \nu R \Delta T  $<br>$ \Delta E = \nu \frac{i}{2} R \Delta T = Q_P - A $<br>$ Q_P = \nu C_{P,m} (T_2-T_1) $</p>
</blockquote>
</li>
<li>等容过程<blockquote>
<p>$ A = 0 (dV = 0) $<br>$ \Delta E = \nu \frac{i}{2} R \Delta T  $<br>$ Q_V = \Delta E = \nu C_{V,m} \Delta T = \frac{i}{2} V \Delta P $</p>
</blockquote>
</li>
<li>等温过程<blockquote>
<p>$PV = const, \Delta E = 0 $<br>$Q_T =  \nu C_{T,m} \Delta T $<br>$\because \Delta T = 0,Q_T为有限量 \Rightarrow C_{T,m} = +\infty  $<br>$Q_T = A = \int _{1 \to 2} PdV = \int_{V_1}^{V_2} \nu \frac{R}{V}TdV $<br>$=\nu R T \ln{\frac{V_2}{V_1} } = \nu R T \ln{\frac{P_1}{P_2} } $</p>
</blockquote>
</li>
</ul>
<h2 id="绝热过程"><a href="#绝热过程" class="headerlink" title="绝热过程"></a>绝热过程</h2><ul>
<li>绝热过程：系统在整个过程中，始终不和外界交换热量。<blockquote>
<p>$ 特点：dQ = 0 , C_{Q,m} = 0 $<br>$ dQ = 0 \Rightarrow dA + dE = 0 $<br>$ 我们利用等容关系能得到：-PdV = \nu C_{V,m} dT $<br>$ 但是我们在绝热过程中P,V都会变$<br>$ \therefore 对克拉伯龙方程微分 $<br>$ PdV+ VdP = \nu R dT $<br>$ 把上式代入得：(C_{V,m}+ R)PdV = - C_{V,m} V dP $<br>$\therefore \frac{dP}{P} = - \gamma \frac{dV}{V} $<br>$ 两边求导：PV^{\gamma} = const (过程/泊松方程) $</p>
</blockquote>
</li>
<li><p>绝热曲线：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/pict_1.jpg" alt="pict1"></p>
<ul>
<li>我们来仔细辨析一下其中的原理，从宏观和微观的角度。</li>
</ul>
</li>
<li><p>能量关系：</p>
<blockquote>
<p>$ \Delta E = \nu \frac{i}{2} R \Delta T = \nu C_{V,m} \Delta T = -A$<br>$\because \frac{i}{2} = \frac{1}{\gamma - 1} $<br>$\therefore A = \frac{P_1 V_1 - P_2 V_2}{ \gamma - 1} $</p>
<ul>
<li>当然，我们也可以通过理气对外做功的方程以及泊松方程直接求A<br>$A = \int_{V_2}^{V_1} PdV =  $</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="多方过程"><a href="#多方过程" class="headerlink" title="多方过程"></a>多方过程</h2><ul>
<li>多方过程：理想气体的一般过程。</li>
<li>$ 过程方程：PV^n = const $<ul>
<li>从方程可以看出，这个过程介于等压过程和等容过程之间，为啥这么说捏？<blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="循环过程"><a href="#循环过程" class="headerlink" title="循环过程"></a>循环过程</h2><ul>
<li>循环过程：从初始状态出发，一系列变化回到初始状态<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/pict_2.jpg" alt="pict2"></li>
<li>$特点：\Delta E = 0 \therefore A = Q $<blockquote>
<p>$A = \int_LPdV = \pm S_{abcda} $<br>$ A的\pm 取决于L路径的正负$</p>
</blockquote>
</li>
<li>应用：热机与制冷机</li>
</ul>
<h2 id="拓展—热力经济学"><a href="#拓展—热力经济学" class="headerlink" title="拓展—热力经济学"></a>拓展—热力经济学</h2><blockquote>
<p>持续更新中。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>工科大学物理</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>物理</tag>
        <tag>热力学</tag>
        <tag>热力学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】pre_Summary</title>
    <url>/2022/09/10/OO-pre-Summary/</url>
    <content><![CDATA[<p>常见styleCheck报错改进合集，git相关知识，在题解过程中了解java语法以及面向对象知识</p>
<span id="more"></span>]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>pre</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-数分1】北航信息类数分一资料</title>
    <url>/2022/09/06/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>北航大一的数分（一）资料，有<strong>数分讲座的ppt</strong>以及<strong>2010-2022的期中考题</strong>、<strong>2010-2021的期末考题</strong>，其中期末的考题以及处理好了，题目和答案分开在两个文件夹内。但期中的考题答案和题目还合在一起，这里并不是俺懒（确信.jpg，而是学长觉得授人以鱼不如授人以渔，所以内有<strong>wps处理教程</strong>，赶紧学起来叭！！！</p>
<span id="more"></span>
<h1 id="数分（一）资料"><a href="#数分（一）资料" class="headerlink" title="数分（一）资料"></a>数分（一）资料</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>快点端上来罢 我已经等不及了<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%80.jpg" alt="图1"></p>
</blockquote>
<ul>
<li><a href="https://bhpan.buaa.edu.cn:443/link/D8A4739E259BFEBEE88FD61C2F75F331">北航云盘-淑芬（一）资料</a><br>有效期限：2025-10-01 23:59</li>
<li>有效期快到了的话提醒我续费（</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>第一个文件夹，北航学院开的<strong>数分讲座的ppt</strong>，你们也会有这种讲座的，课程组的老师会在每章结束后开讲座（一般在周日下午），俺还是比较推荐你们去看看的，错过了也没关系，一般会有录屏，要去自己找找（上大学，<strong>信息检索</strong>的能力是挺需要的，就比如你们要能从我这篇文章中取得你们需要的东西），录屏可以开1.5倍或者是2倍速看。<ul>
<li>什么？怎么开倍速，建议去了解一下<strong>浏览器插件</strong>。</li>
</ul>
</li>
<li>第二个文件夹，数分期中的试卷，这个对于大家挺重要的，而且建议打印下来，<strong>刷纸质版</strong>。往年题是真的要认真刷的！！！<ul>
<li>但是你们也注意到，答案和题目混在一块，别急，<a href="#正片开始-wps_pdf处理">去后面看看，有好东西</a>。按照这里一步一步走就可以自己造试卷了，而且有北航专属彩蛋相送。</li>
</ul>
</li>
<li>第三个文件夹，数分期末试卷，这里就都喂你们口中了，利用好喔~<ul>
<li>看完这里以后别急着走哈，后面有学长头铁的<strong>备考建议</strong>捏~~~~<a href="#备考建议及写在最后的话">备考建议</a></li>
</ul>
</li>
</ul>
<h2 id="正片开始-wps-pdf处理"><a href="#正片开始-wps-pdf处理" class="headerlink" title="正片开始-wps_pdf处理"></a>正片开始-wps_pdf处理</h2><ul>
<li>ms office全家桶是非常强大的办公软件，用的好ms office当然能够解决好许多问题。而wps这一类金山的东西一直给人一种广告多不好用的印象，但其实金山软件公司在1988年创立，和ms争夺办公软件的市场许多年，wps在功能性上完全不输ms office，所以大家可以放心食用，另外广告这件事也不用担心，马上就没了（手动滑稽</li>
</ul>
<h3 id="具体教程"><a href="#具体教程" class="headerlink" title="具体教程"></a>具体教程</h3><ul>
<li>我们打开2020-2021的期中试卷，看到里面还有答案。我们点击 <strong>编辑-&gt;编辑内容</strong> 可以发现页面变成了这样<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%BA%8C.png" alt="图二"></li>
<li><p>问题是这样不好处理选项啊，删错了怎么办？（可以ctrl+z）</p>
<ul>
<li>这样可以来<strong>处理大题</strong>，像这样，直接<strong>全部选中，delete</strong>，就okk了<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%89.jpg" alt="图三"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E5%9B%9B.jpg" alt="图四"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%BA%94.jpg" alt="图五"></li>
</ul>
</li>
<li><p>那选择题怎么搞？ 可以点击 <strong>编辑-&gt;擦除</strong> ，去试一下很好搞的，绝对不是俺懒（确信.jpg。</p>
</li>
<li>编辑内容功能还可以用来<strong>去除部分水印</strong>，留给大家遇到了再自己去尝试了，当然有需求可以评论区告诉我。</li>
<li>最后，全都处理完后记得<strong>另存为</strong>，放到另一个文件夹里。（<strong>管理资料</strong>的能力也同样重要！</li>
</ul>
<h3 id="白嫖wps会员方法"><a href="#白嫖wps会员方法" class="headerlink" title="白嫖wps会员方法"></a>白嫖wps会员方法</h3><ul>
<li>有人说（也有可能没有）：学长学长，wps它没有会员不好用哇！</li>
<li>不用担心，北航有办法</li>
<li>网址：s.buaa.edu.cn（在校外用vpn1就可以上）</li>
<li><strong>登录后</strong>在下载中心点击<strong>金山软件</strong>-&gt;<strong>wps激活绑定</strong>，这样就能加入北航的企业团队啦，就有了白嫖的企业vip！</li>
<li>而且在<a href="https://s.buaa.edu.cn">北航正版软件平台</a>上，你还能看到其他有用的软件，按需自取吧！</li>
</ul>
<h2 id="备考建议及写在最后的话"><a href="#备考建议及写在最后的话" class="headerlink" title="备考建议及写在最后的话"></a>备考建议及写在最后的话</h2><ul>
<li>最后是学长的唠叨，数分高代作为两个大宗科目（恐怖的6学分），希望大家都能把握好。</li>
<li>多<strong>刷刷往年题</strong>，此外推荐好好看看<strong>书本及其课后题</strong>和<strong>老师的ppt</strong>，其实很多题都换汤不换药。</li>
<li>另外推荐看看<strong>蓝书的典型例题</strong>，整理的挺全面的。</li>
<li>然后最重要的是<strong>平时要学好</strong>！</li>
</ul>
<blockquote>
<p>the end 祝大家好好学习天天向上！</p>
</blockquote>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>数分</tag>
        <tag>wps</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】北航信息类高代资料</title>
    <url>/2022/09/06/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E9%AB%98%E4%BB%A3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>北航大一高代的资料，高代的题可能就不像数分的题整理的那么的整齐，可能<strong>有点零散</strong>，特别是期中的题，俺可能还一不小心删掉一部分（秃头），而且很多<strong>试题都没有答案</strong>。不过乐观点想，期中大家真的不用太担心，试题没有答案的话可以多<strong>和同学讨论</strong>，<strong>对答案</strong>，<strong>问老师</strong>；这也是个主动学习的过程。另外文档里，有俺滴<strong>手写笔记</strong>，大一上跟着<strong>赵迪老师</strong>上课，受益匪浅，学会了很多 <strong><em>学术语言</em></strong>()，<strong>大大滴推荐</strong>。另外这一篇也有<strong>加餐</strong>，给大家讲一下可以从哪里<strong>找试卷资源</strong>，这样大家也能自己去找资源！</p>
<span id="more"></span>
<h1 id="高代资料"><a href="#高代资料" class="headerlink" title="高代资料"></a>高代资料</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>话不多说，上链接！<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E9%AB%98%E4%BB%A3%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%80.jpg" alt="图一"></p>
</blockquote>
<ul>
<li><a href="https://bhpan.buaa.edu.cn:443/link/197EDC5E339248FC004CD796F84C3EB8">北航云盘-高代资料</a><br>有效期限：2025-10-01 23:59</li>
<li>有效期快到了的话提醒我续费（</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="高代期中"><a href="#高代期中" class="headerlink" title="高代期中"></a>高代期中</h3><ul>
<li>期中这个文件夹里是些零零碎碎的东西，其中有一本 <strong>！几何书（教材）</strong> 那上面应该就是你们期中考试的大致范围了。</li>
<li>不过高代的期中完全不用担心，只占10的平时分，而且巨简单，高代难的在后面<strong>概念多</strong>起来的时候，容易头晕。</li>
</ul>
<h3 id="高代期末"><a href="#高代期末" class="headerlink" title="高代期末"></a>高代期末</h3><ul>
<li>这个文件夹里，有高代的<strong>芝士点总结</strong>，还有<strong>真题试卷</strong>和<strong>练习的试卷</strong>，知识点可以看看，主要多刷题多总结。</li>
</ul>
<h3 id="最后两个文件"><a href="#最后两个文件" class="headerlink" title="最后两个文件"></a>最后两个文件</h3><ul>
<li>这两个文件，一个是<strong>教材的答案</strong>，不是教材的顺序，但是很多题是重合的，<strong>仔细找找</strong>应该能找到答案。</li>
<li>另一个是学长<strong>面向高代考纲（手动滑稽）</strong> 的一手资料，里面会有一些<strong>难懂难蚌</strong>的学术词汇，大家可以简单看看。</li>
</ul>
<h2 id="加餐时间"><a href="#加餐时间" class="headerlink" title="加餐时间"></a>加餐时间</h2><blockquote>
<p>此次的加餐主要是为了解决资源检索的问题，关于数分高代，或说一些其他科目(程设)，有哪些资料的来源。</p>
</blockquote>
<h3 id="梦拓学长学姐"><a href="#梦拓学长学姐" class="headerlink" title="梦拓学长学姐"></a>梦拓学长学姐</h3><h3 id="老师发的资料"><a href="#老师发的资料" class="headerlink" title="老师发的资料"></a>老师发的资料</h3><h3 id="腾讯乐享"><a href="#腾讯乐享" class="headerlink" title="腾讯乐享"></a>腾讯乐享</h3><h3 id="各种群聊"><a href="#各种群聊" class="headerlink" title="各种群聊"></a>各种群聊</h3><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><blockquote>
<p>持续更新中，未完待续。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学集合论</title>
    <url>/2022/09/06/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>也系边上老师的课边做的一些笔记以及自己的一些想法，但有时候可能会拖更，分享给大家，有不妥之处，敬请评论区指正。</p>
<span id="more"></span>
<h1 id="集合的基本概念及其运算"><a href="#集合的基本概念及其运算" class="headerlink" title="集合的基本概念及其运算"></a>集合的基本概念及其运算</h1><h2 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h2><ul>
<li>集合要有明确特征，不能是模糊概念，如：高个子学生</li>
<li>集合的表示方法：<ul>
<li>枚举法</li>
<li>抽象法：用谓词来概括，$S=\{x|P(x)\}$<ul>
<li>抽象描述不唯一。</li>
<li>不能取 $p(x)为x \notin x$ ，否则罗素悖论<blockquote>
<p>$T=\{x|x \notin x\},有\forall x,x \in T \Leftrightarrow x \notin x$<br>$假设这里的x就是T，那么就有T \in T \Leftrightarrow T \notin T$ <br><br>猫了个打盹（）</p>
</blockquote>
</li>
<li>$所以其实抽象原则有点危险，Cantor悖论，理发师悖论，说谎者悖论。$</li>
<li>$悖论产生的原因：自引用，自作用。$</li>
</ul>
</li>
<li>归纳定义：包含基本项、归纳项、以及最小化。（可以类比一下上学期公理系统的定义）<ul>
<li>基本项和归纳项不难理解，归纳项就是推演规则。<blockquote>
<p>这里我们来定义一个集合A<br>$非空集合S_0 \subseteq A (基本项)$ <br><br>$一组规则，\forall x \in A,x \stackrel{这一组规则}{\longrightarrow} y,y \in A (归纳项)$</p>
</blockquote>
</li>
<li>这里重点辨析一下极小化：<blockquote>
<p>保证A中每个元素都可通过有限次使用1或2来获得。<br>$如果集合 S \subseteq A 也满足 1和2，则 A \subseteq S$<br>$（如果集合 S \subseteq A 也满足 1和 2，则 S = A ）$ <br><br>最小化很必要，就是说如果只有1和2两句话，A中有其他不符合1、2规则的元素也可以满足，归纳定义法定义的集合就不唯一！！！<br>为什么叫极小化，就是说A中没有其他多余的元素，是通过1、2能得到的最小集合，清清爽爽。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合的相等与包含"><a href="#集合的相等与包含" class="headerlink" title="集合的相等与包含"></a>集合的相等与包含</h2><blockquote>
<p>相等和包含的定义在高中的时候就说过了，这里说点不一样的。</p>
</blockquote>
<ul>
<li>集合与元素的排列次序与元素重复出现的次数无关<blockquote>
<p>体现为{1,2,3}={3,1,2}<br>{a,b,c}={a,a,c,b,b,c}(这个也叫多重集)</p>
</blockquote>
</li>
<li>相等与包含的等价表示<blockquote>
<p>$A=B \Leftrightarrow \forall x(x \in A \leftrightarrow x \in B)$<br>$A \subseteq B \Leftrightarrow \forall x (x \in A \rightarrow x \in B)$<br>$A \subset B \Leftrightarrow A \subseteq B \wedge A \neq B \Leftrightarrow \forall x(x \in A \rightarrow x \in B) \wedge \exists x(x \in B \wedge x \notin A)$</p>
</blockquote>
</li>
<li>集合的元素可以是集合<blockquote>
<p>所以这里就有必要辨析一下 $ “\in” 和 “\subseteq” $ 的区别<br>例：A={1,2,{1,2,3}}<br>$\therefore 1 \in A$<br><br>$\{1,2\} \subseteq A$<br><br>$\{1,2,3\} \in A$<br><br>$\{1,\{1,2,3\}\} \subseteq A $<br><br>在这里，“1”，“2”，“{1，2，3}”是平级的。这里我们可以类比电脑的文件夹存储方式。</p>
</blockquote>
</li>
<li>还有一个关系，咱们可以看看。<blockquote>
<p>$ 设A，B，C都是集合，若 A \subseteq B 且 B \subseteq C,则 A \subseteq C $<br>$ 但是，若A \in B,B \in C,则A不一定\in C $<br>$ 例： A = \{ 1 \},B = \{ \{ 1 \} \} , C = \{ \{ \{ 1 \} \} \} (晕.jpg) $</p>
</blockquote>
</li>
</ul>
<h2 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h2><ul>
<li>集合A的全部子集构成的集合 称为A的 幂集，记作 $ \rho(A) $。<blockquote>
<p>$ \rho ( A ) = \{ X | X \subseteq A \} $<br>$ \therefore B \subseteq A \iff B \in \rho ( A ) $</p>
</blockquote>
</li>
<li>基数，有穷集合A中所含有元素的个数称为 A 的基数。记作#A。<blockquote>
<p>对于A中的每个元素在A的幂集元素中只有两种选择，(to be | not to be) ,所以只要A是有穷集合，则 $ \sharp \rho ( A ) = 2 ^ { \sharp A } $</p>
</blockquote>
</li>
</ul>
<h2 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h2><ul>
<li>$有\cup,\cap,-(差，也叫对称补),\sim(补，也称绝对补)，\oplus(叫对称差)$<ul>
<li>$为啥 \sim 叫绝对补捏,因为\sim A = U - A$<blockquote>
<p>$所以 x \notin A \iff x \in \sim A$</p>
</blockquote>
</li>
<li>$那为啥\oplus 叫对称差捏,因为A \oplus B = (A-B) \cup (B-A)$<blockquote>
<p>就是去除掉相同的部分，跟异或有点像有米有。</p>
</blockquote>
</li>
</ul>
</li>
<li>$还有俩特殊的\bigcup、\bigcap,推广到n个集合的情况$<ul>
<li>$记作:\bigcup_{i=1}^{n}A_i ,也可以写成无穷的形式: \bigcap_{i=1}^{\infty}A_i$</li>
</ul>
</li>
<li>集合族，集合的聚合：如果一个集合的所有元素都是集合，则称该集合为 集合族 或 集合的聚合。<ul>
<li>$ 标码集合的概念：A = \{A_{s1},A_{s2},\dots\} ,J=\{s1,s2,\dots\}$<blockquote>
<p>$则A可以简化写成：A=\{A_i|i \in J\},咱们把A叫加标集合，J叫标码集合$</p>
</blockquote>
</li>
<li>$聚合上的\bigcup,\bigcap运算也有点讲究，我们将其称为广义并、广义交，主要体现在\bigcap 上$<blockquote>
<p>$集合族A，A元素的并集可以表示为\bigcup A 或者 \bigcup_{i\in J}A_i$ <br><br>即有就留下。<br>$即：\bigcup A =\{x| \exists S(S \in A \vee x \in S)\}$<br>$特殊的来了，对于\bigcap 咱们要求A \neq \phi,命名同上$<br>$我们定义：\bigcap A= \{x| \forall S (S \in A \rightarrow x \in S)\},$<br>$\therefore 若A=\phi，则S\in A \rightarrow x \in S 永真，\bigcap A 为U。$<br>$这里的\bigcup A有取所有A的元素都有的元素就留下$</p>
<ul>
<li>我觉得在这个定义上，和运算上的 $ \times \div $ 有点像，但我基础不够说不出来有什么内部的联系，等我研究一下，有成果在评论区告诉大家</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>另外，由集合族定义牵扯的广义分配律，广义德摩根律大家也可以去看看形式，这里不赘述了</li>
<li>还有一有意思的原理：（集合恒等式的基本形式可以与逻辑等值式类比）<ul>
<li>对偶原理：在不含有 $ -和\oplus $ 的集合恒等式中，将 $ \cup 与\cap $ 互换，$ \phi 与 U $ 互换，得到的仍是集合恒等式（或者可以用逻辑上的对偶定理来理解，真值不变）。<blockquote>
<p>是不是很有趣，为啥会这样呢。这两个玩意都是布尔代数的特例，可以去了解一下<a href="https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0/525084">布尔代数</a></p>
</blockquote>
</li>
</ul>
</li>
<li>咱们学过范式，我们可以用 $\{ \neg , \vee , \wedge \}$ 这个完备集来表示所有的逻辑情况，在集合里我们也可以用把所有的其他运算符化成 $\{\sim , \cup , \cap \}$ 来简化运算。当然很多时候可以用元素分析，需要灵活应对。<blockquote>
<p>$ A - B = A \cap \sim B$<br>$ A \oplus B = (A-B) \cup (B-A)=(A \cap \sim B) \cup (B \cap \sim A)$</p>
</blockquote>
</li>
</ul>
<h2 id="有穷集的计数原理"><a href="#有穷集的计数原理" class="headerlink" title="有穷集的计数原理"></a>有穷集的计数原理</h2><ul>
<li>如题，有定理 $ \sharp (A \cup B) = \sharp A + \sharp B -\sharp (A \cap B)$</li>
<li>可以画Venn图辅助理解。</li>
</ul>
<h2 id="集合的归纳定义法"><a href="#集合的归纳定义法" class="headerlink" title="集合的归纳定义法"></a>集合的归纳定义法</h2><ul>
<li>在第一节<a href="#集合与元素">集合与元素</a>讲过基础的定义，其中我们说抽象定义有时会有点不清楚，所以我们学习更好的归纳定义。</li>
<li>其中需注意的极小化定义，一般表述为“只有有限次应用基础语句和归纳语句得到的元素才是该集合中的元素”</li>
</ul>
<h2 id="有序偶和笛卡尔乘积"><a href="#有序偶和笛卡尔乘积" class="headerlink" title="有序偶和笛卡尔乘积"></a>有序偶和笛卡尔乘积</h2><ul>
<li>有序偶：两个对象x、y，他们按规定的顺序构成的序列，称之为有序偶，记为 &lt; x , y &gt;。</li>
<li>其中x称为第一元，y称为第二元。</li>
<li>有序偶的集合表示：<blockquote>
<p>&lt; x , y &gt; = { { x } , {x , y}}</p>
<ul>
<li>这样表示的话，有序偶的有序性得以体现。</li>
</ul>
</blockquote>
</li>
<li>$ n元序偶定义为：&lt; x_1 , x_2 , x_3 , \dots , x_n &gt; = &lt; &lt; x_1 , x_2 , \dots x_{n-1}&gt;, x_n &gt; $<ul>
<li>尝试着写一下n元序偶的集合表示呗！</li>
</ul>
</li>
<li>笛卡尔乘积：<blockquote>
<p>$ A \times B = \{ &lt; x, y&gt; | x \in A \wedge y \in B\}$</p>
<ul>
<li>由于有序偶的有序性，所以笛卡尔积不符合交换律和结合律</li>
<li>$ \sharp (A \times B) = \sharp A \cdot \sharp B (A,B为任意有限集) $</li>
</ul>
</blockquote>
</li>
<li>运算性质：<blockquote>
<p>$ A \times (B \cup C) = (A \times B) \cup (A \times C)$<br><br>$ (A \cup B) \times C = (A \times C) \cup (B \times C)$</p>
<ul>
<li>类似的分配律性质对 $\cap , -$ 也适用 </li>
</ul>
</blockquote>
</li>
<li>n个集合的笛卡尔积推广，自己类推一下叭。</li>
</ul>
<blockquote>
<p>未完待续。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>工科大物-气体动理论总结</title>
    <url>/2022/09/06/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E6%B0%94%E4%BD%93%E5%8A%A8%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>系边上老师的课边做的一些笔记以及自己的一些想法，但有时候可能会拖更，分享给大家，有不妥之处，敬请评论区指正。</p>
<span id="more"></span>
<h1 id="气体动理论总结（持续更新中…）"><a href="#气体动理论总结（持续更新中…）" class="headerlink" title="气体动理论总结（持续更新中…）"></a>气体动理论总结（持续更新中…）</h1><h2 id="一、基本概念、微观结构、统计规律"><a href="#一、基本概念、微观结构、统计规律" class="headerlink" title="一、基本概念、微观结构、统计规律"></a>一、基本概念、微观结构、统计规律</h2><h3 id="1、热力学系统与外界"><a href="#1、热力学系统与外界" class="headerlink" title="1、热力学系统与外界"></a>1、热力学系统与外界</h3><ul>
<li>热力学系统：一般相对较大、能被察觉，包含大量的分子原子。</li>
<li>外界：系统之外（严谨的废话）。</li>
</ul>
<h3 id="2、物质的微观结构"><a href="#2、物质的微观结构" class="headerlink" title="2、物质的微观结构"></a>2、物质的微观结构</h3><ul>
<li>宏观的物体都由大量微观粒子构成</li>
<li>所有分子都在不停无规则的热运动</li>
<li>分子间存在相互作用力</li>
</ul>
<h3 id="3、气体分子热运动的主要特征"><a href="#3、气体分子热运动的主要特征" class="headerlink" title="3、气体分子热运动的主要特征"></a>3、气体分子热运动的主要特征</h3><ul>
<li>分子间间距大</li>
<li>碰撞频繁</li>
<li>遵从牛顿运动定律（相对较低速）</li>
</ul>
<h3 id="4、理想气体微观模型"><a href="#4、理想气体微观模型" class="headerlink" title="4、理想气体微观模型"></a>4、理想气体微观模型</h3><ul>
<li>气体分子看作小球，可以弹性也可以刚性</li>
<li>分子间只有相互碰撞，没有其他相互作用，所以没有分子间势能</li>
<li>碰撞时分子看成完全弹性小球</li>
</ul>
<h3 id="5、平衡态"><a href="#5、平衡态" class="headerlink" title="5、平衡态"></a>5、平衡态</h3><ul>
<li>是指在系统不受外界影响时，各部分宏观性质长时间不随时间改变的状态</li>
<li>平衡态应用：热力学第三定律</li>
</ul>
<h3 id="6、温度"><a href="#6、温度" class="headerlink" title="6、温度"></a>6、温度</h3><hr>
<p>整理老师ppt的部分结束了，俺懒得copy了，接下来就是一些理论的推导过程以及我觉得重要的地方</p>
<h2 id="理想气体平衡态时宏观描述"><a href="#理想气体平衡态时宏观描述" class="headerlink" title="理想气体平衡态时宏观描述"></a>理想气体平衡态时宏观描述</h2><blockquote>
<p>注意表述，有哪些定语，理想气体、平衡态、宏观</p>
</blockquote>
<ul>
<li>有V(体积)、P(压强)、T(温度)、M(质量)、、、气体的宏观量，并且有由它们相互之间构成的关系——克拉伯龙方程</li>
<li>还有许多由实验得来的定律，等温的玻意尔定律，等容的查理定律，等压的盖吕萨克定律都可以在克拉伯龙方程得到体现，相信大家高中学的都挺好，这些不在话下。</li>
</ul>
<blockquote>
<p>$PV= \nu RT$    ($\nu$为摩尔数，T单位为开尔文K)<br>它有许多变式<br>$\because \nu=\frac{m}{M}=\frac{N}{N_A}$<br>$\therefore \dotsb$<br>$\because k = \frac{R}{N_A}$（k为玻尔兹曼常数）<br>$\because n=\frac{N}{V} = \frac{\nu N_A}{V}$ (n为分子数密度)<br>$\therefore 它又能写成 PV=NkT, P=nkT$<br>其中常数$R=8.314510J/molK$<br>$k=1.380658 \times 10^{-23} J/K$</p>
</blockquote>
<h2 id="理想气体压强公式"><a href="#理想气体压强公式" class="headerlink" title="理想气体压强公式"></a>理想气体压强公式</h2><ul>
<li>首先得清楚，压强的来源是每一个小分子对于器壁都会有冲击力，但是这里的P是大量分子撞击的宏观结果，单个的分子无法讨论压强。</li>
<li>下面开始推导</li>
</ul>
<blockquote>
<p>在一个边长分别为$l_1,l_2,l_3$的全反射壁容器内<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E6%B0%94%E4%BD%93%E5%8A%A8%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/%E5%9B%BE2.1.jpg" alt="容器"></p>
</blockquote>
<h2 id="分子碰撞基本理论——平均自由程"><a href="#分子碰撞基本理论——平均自由程" class="headerlink" title="分子碰撞基本理论——平均自由程"></a>分子碰撞基本理论——平均自由程</h2><p>Maxwell速率分布</p>
<h2 id="温度公式"><a href="#温度公式" class="headerlink" title="温度公式"></a>温度公式</h2><p>温度与平动动能有关，相同温度不同气体，平动动能一定相等，但总动能和内能不一定相等</p>
<h2 id="阿佛加德罗定律"><a href="#阿佛加德罗定律" class="headerlink" title="阿佛加德罗定律"></a>阿佛加德罗定律</h2><h2 id="道尔顿分压定理"><a href="#道尔顿分压定理" class="headerlink" title="道尔顿分压定理"></a>道尔顿分压定理</h2><h2 id="能量均分定理"><a href="#能量均分定理" class="headerlink" title="能量均分定理"></a>能量均分定理</h2><h2 id="气体内能的讨论"><a href="#气体内能的讨论" class="headerlink" title="气体内能的讨论"></a>气体内能的讨论</h2><h2 id="Maxwell速率分布"><a href="#Maxwell速率分布" class="headerlink" title="Maxwell速率分布"></a>Maxwell速率分布</h2><p>最可几/最概然 速率 无序度增加</p>
]]></content>
      <categories>
        <category>工科大学物理</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>物理</tag>
        <tag>热力学</tag>
        <tag>气体动理论</tag>
      </tags>
  </entry>
  <entry>
    <title>blog配置教程</title>
    <url>/2022/09/06/blog%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
