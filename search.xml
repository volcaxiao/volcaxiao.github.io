<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【BUAA-CO】p0状态编码分享</title>
    <url>/2022/10/04/BUAA-CO-p0%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>时隔半个月，终于有了更新，主要是一些P0的经验分享——状态编码，当然有一些零零散散的芝士点，会在后面补足的，记得催催。。。</p>
<span id="more"></span>
<h1 id="状态编码的分享"><a href="#状态编码的分享" class="headerlink" title="状态编码的分享"></a>状态编码的分享</h1><h2 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h2><p>相信的大家都开始写状态机了，FSM分为三个部分，主要是状态转移、状态储存、状态输出，其中状态转移、状态输出主要是组合逻辑的操作，因此将这两个模块封装后，可以进行类似于组合逻辑的电路的黑箱测试的操作。<br>当然，我们可以用分析电路(analyze circuit)的功能，非常方便的得到我们想要的电路。<br>这些问题都解决了，留给我们自己的事情就只剩下状态编码的选择、状态转移（输出）的真值表了。</p>
<blockquote>
<p>当然，还有计算机组成课程历史上的一颗明珠——qshr机（指路<a href="http://cscore.buaa.edu.cn/#/discussion_area/579/689/posts">自主研发：权尚浩然型有限状态机</a>），可以省去选状态编码这种憋死选择困难症的操作，直观可读性强，是计算机仿真史上的一个重大发明，虚拟现实专业的同学也应该好好学习借鉴</p>
</blockquote>
<hr>
<p>所以我们来重点看看选择状态编码的门道。<br>这里我们以logisim导航这一题为例，看看不同的状态编码的选择之间的差别。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#状态转移图">状态转移图</a><br><a href="#自己乱编的码">自己乱编的码</a><br><a href="#8421顺序编码">8421顺序编码</a><br><a href="#格雷码">格雷码</a><br><a href="#独热码">独热码</a><br><a href="#瞻仰qshr机">瞻仰qshr机</a></p>
<h2 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h2><ul>
<li>这道题的状态转移图，其实不太好用常见的圈箭头的表示，倒是路径图已经有了，直接在这上面看着打表会方便一点<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1自己的编码图.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1自己的编码图.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="自己乱编码的图"></li>
</ul>
<h2 id="自己乱编的码"><a href="#自己乱编的码" class="headerlink" title="自己乱编的码"></a>自己乱编的码</h2><blockquote>
<p>编码中还需要注意一个问题，就是我们输入的三位数从高位到地位应该是(l2,l1,l0),所以在我们打表的时候的命名请按照(l2,l1,l0,d1,d0)的顺序(分别表示location,direction),同样输出我们使用(L2,L1,L0,hit)的顺序。这样符合逻辑！</p>
<p>在打完表以后，也要注意，分离器(splitter)分离出来的位次依次是(l0,l1,l2)，所以为了好看，打完表以后，把输入输出的顺序调一下！调成(l0,l1,l2,hit)</p>
</blockquote>
<ul>
<li>上图是我自己的胡乱编码，其实也不胡乱，中间三个状态是独热码表示。他的效果如下：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1自己码.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1自己码.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="自己码"></li>
</ul>
<h2 id="8421顺序编码"><a href="#8421顺序编码" class="headerlink" title="8421顺序编码"></a>8421顺序编码</h2><ul>
<li>顺序编码是我们最好理解的一种编码，最符合我们人类的直觉往往最不符合计算机的直觉，因为虽然顺序编码的最为紧密（紧密也有紧密的好处），但是由于相邻两个状态之间的变化太大，实际的硬件的寄存器很难做到同时发生变化，所以出错的概率很高（我们叫做毛刺现象）。</li>
<li>所以在我们平常的作业中使使可能没太大问题，但是实际应用中用的很少。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2_8421码.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2_8421码.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8421码"></li>
</ul>
<h2 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h2><ul>
<li>格雷码的特点就是解决了顺序码的缺点，相邻的两状态之间编码之变一位，就不会出现毛刺的现象。</li>
<li>但是格雷码最大的问题在于设计的难度</li>
<li>其实格雷码最好是初态和末态也只差一位，但我实在有点找不到，有能够找到的dl可以在评论区指出。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3_格雷码.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3_格雷码.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="格雷码"></li>
</ul>
<h2 id="独热码"><a href="#独热码" class="headerlink" title="独热码"></a>独热码</h2><ul>
<li>独热码的编码可能是唯一一个计算机好理解，人也好理解的编码，再加上他一下只需要变动两次（置一+置零），所以毛刺的概率低。</li>
<li>而且，虽然说编码不太紧密，用到的寄存器位数多（也就是触发器多），但是这也使得组合逻辑电路会精简一些，大家可以看接下来的实现。</li>
<li>就是这两个特点使得独热码在实际应用中十分广泛。<blockquote>
<p>独热码适合写条件复杂但是状态少的状态机；<br>  格雷码适合写条件不复杂但是状态多的状态机。</p>
</blockquote>
</li>
<li>这里分享一个小妙招，格雷码一个一个的在Analysis里打表不方便（位数太多了），而其实独热码大多数位数都是零，所以可以先构造出这样的电路<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/独热码构造捷径.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/独热码构造捷径.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="独热码构造捷径"></li>
<li>然后再Project -&gt; Analyze circuit,出来的初始真值表就是全置零的啦。</li>
<li>如下图（独热码的真值表太长了我就不晒出来了）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4_独热码.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4_独热码.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="独热码"></li>
<li>当然这肯定不是最简化的电路，你可以根据要求自己搭更加简单的电路，包括说用复用器来实现更简化，在这里就不赘述了。</li>
</ul>
<h2 id="瞻仰qshr机"><a href="#瞻仰qshr机" class="headerlink" title="瞻仰qshr机"></a>瞻仰qshr机</h2><ul>
<li>对于qshr机，评论区zytgg的评论一针见血：<blockquote>
<p>是否等价于把独热编码的状态机按位拆开？</p>
<ul>
<li>确实，独热码的思路就是有多少状态就用多少触发器，qshr机也就是这么个道理，每一个状态都用一个寄存器存下，和我们画状态转移图的时候的思路是一致的。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>介于qshr机在计算机仿真史上做出的贡献，我们看到了，对于这个题navigation来说，有很直观的状态转移图，还记得我在最开始说的嘛，”这道题的状态转移图，其实不太好用常见的圈箭头的表示，倒是路径图已经有了，直接在这上面看着打表会方便一点”，不用打表，题图即是状态转移图！！！</p>
</blockquote>
<ul>
<li><p>所以我们把原基础的qshr机封装一下，让他看起来更具有仿真的意味！<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/qshr机改良版.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/qshr机改良版.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="qshr机封装版"></p>
</li>
<li><p>虽然只是对qshr机的拙略模仿，但是你们不觉得很酷嘛，这很符合我对未来的想象（）。</p>
</li>
</ul>
<hr>
<h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><ul>
<li>其实有限状态机核心的部分就是状态转移，状态转移核心的部分就是编码选择和打表，掌握好了这几个地方，封装再好点（便于调试），有限状态机就不难啦。</li>
<li>感谢qshr大佬的灵感支持！</li>
<li>感谢zyt、cys等佬的理论拓展！</li>
<li>有不妥之处请各位大佬指出，谢谢观看！</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>P0</tag>
        <tag>状态编码</tag>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p2mips常用宏定义</title>
    <url>/2022/10/12/BUAA-CO-p2mips%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>我们知道mips的灵活性高，但是可读性差，所以要改变可读性差的问题，我们可以使用宏定义，像写c一样写汇编（）。</p>
<span id="more"></span>
<h1 id="mips常用宏定义"><a href="#mips常用宏定义" class="headerlink" title="mips常用宏定义"></a>mips常用宏定义</h1><ul>
<li>下面是一些常用的宏定义，当然你可以视情况而定，将代码段中重用次数高的，或者是用汇编写意义不太明确的代码写成宏。这样调试的时候，别人和自己看代码的时候，都会舒服许多。</li>
</ul>
<h2 id="end-the-program"><a href="#end-the-program" class="headerlink" title="end the program"></a>end the program</h2><ul>
<li>虽然重用度肯定不高（），但表意明确。</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#end the program</span></span><br><span class="line"><span class="meta">.macro</span> end</span><br><span class="line">    li  $<span class="built_in">v0</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br></pre></td></tr></table></figure>
<h2 id="write-amp-read类"><a href="#write-amp-read类" class="headerlink" title="write&amp;read类"></a>write&amp;read类</h2><ul>
<li>我们知道这些都是靠syscall实现的，所以可以这么来写</li>
<li>另外这种带参数的宏使得宏定义具有类似于C函数的特性。</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#printInt</span></span><br><span class="line"><span class="meta">.macro</span> printInt(%src)</span><br><span class="line">    <span class="keyword">move </span>   $<span class="built_in">a0</span>, %src</span><br><span class="line">    li      $<span class="built_in">v0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"><span class="comment">#getInt</span></span><br><span class="line"><span class="meta">.macro</span> getInt(%des)</span><br><span class="line">    li      $<span class="built_in">v0</span>, <span class="number">5</span></span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">move </span>   %des, $<span class="built_in">v0</span></span><br><span class="line">.end_macro</span><br><span class="line">栗子:</span><br><span class="line">getInt($<span class="built_in">s0</span>)</span><br><span class="line">printInt($<span class="built_in">s0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接打印字符串</span></span><br><span class="line"><span class="meta">.macro</span> printStr(%str)</span><br><span class="line">    <span class="meta">.data</span> </span><br><span class="line"><span class="symbol">        tmpLabel:</span>   .asciiz %str</span><br><span class="line">    <span class="meta">.text</span></span><br><span class="line">        li  $<span class="built_in">v0</span>, <span class="number">4</span></span><br><span class="line">        la  $<span class="built_in">a0</span>, tmpLabel</span><br><span class="line">        <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line">栗子:</span><br><span class="line">printStr(<span class="string">&quot;Hello CO!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印特定地址的字符串</span></span><br><span class="line"><span class="meta">.macro</span> printStrOf(%src)</span><br><span class="line">    li  $<span class="built_in">v0</span>, <span class="number">4</span></span><br><span class="line">    la  $<span class="built_in">a0</span>, %src</span><br><span class="line">    <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line">栗子:</span><br><span class="line"><span class="meta">.data</span></span><br><span class="line"><span class="symbol">    myStr:</span>  .asciiz <span class="string">&quot;Hello CO!&quot;</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line">    printStrOf(myStr)</span><br></pre></td></tr></table></figure>
<h2 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push&amp;pop"></a>push&amp;pop</h2><ul>
<li>我们在写函数的时候时常要用到push和pop操作，所以做好写一个宏。</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#push</span></span><br><span class="line"><span class="meta">.macro</span> push(%src)</span><br><span class="line">    <span class="keyword">sw </span>     %src, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">    <span class="keyword">subi </span>   $<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"><span class="comment">#pop</span></span><br><span class="line"><span class="meta">.macro</span> pop(%des)</span><br><span class="line">    <span class="keyword">addi </span>   $<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">lw </span>     %des, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">.end_macro</span><br><span class="line">栗子:</span><br><span class="line"><span class="symbol">    fun:</span></span><br><span class="line">    push($<span class="built_in">ra</span>)</span><br><span class="line">    push($<span class="built_in">s0</span>)</span><br><span class="line">    push($<span class="built_in">t0</span>)</span><br><span class="line">        ...</span><br><span class="line">    pop($<span class="built_in">t0</span>)</span><br><span class="line">    pop($<span class="built_in">s0</span>)</span><br><span class="line">    pop($<span class="built_in">ra</span>)</span><br><span class="line">    <span class="keyword">jr </span> $<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
<h2 id="getIndex类"><a href="#getIndex类" class="headerlink" title="getIndex类"></a>getIndex类</h2><ul>
<li>常见的有get二维数组（矩阵）的系数，还有数组的系数</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get the vector index</span></span><br><span class="line"><span class="meta">.macro</span> get_vector_index(%index, %x)</span><br><span class="line">    <span class="keyword">sll </span>    %index, %x, <span class="number">2</span></span><br><span class="line">.end_macro</span><br><span class="line"><span class="comment">#get the matrix index</span></span><br><span class="line"><span class="meta">.macro</span> get_matrix_Index(%ans, %i, %<span class="keyword">j)</span></span><br><span class="line"><span class="keyword"></span>    li      %ans, your_number_of_columns    <span class="comment">#这里填上你的矩阵列数/行数</span></span><br><span class="line">    <span class="keyword">multu </span>  %i, %ans</span><br><span class="line">    <span class="keyword">mflo </span>   %ans</span><br><span class="line">    <span class="keyword">add </span>    %ans, %ans, %<span class="keyword">j</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">sll </span>    %ans, %ans, <span class="number">2</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
<blockquote>
<p>待补充</p>
</blockquote>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P2</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p2mips汇编翻译C代码典例</title>
    <url>/2022/10/12/BUAA-CO-p2mips%E6%B1%87%E7%BC%96%E7%BF%BB%E8%AF%91C%E4%BB%A3%E7%A0%81%E5%85%B8%E4%BE%8B/</url>
    <content><![CDATA[<p>汇编语言是一种比机械码稍高级一点的语言，而MIPS的汇编语言是一种专用于MIPS架构的CPU的汇编语言，相较于ARM，X86等现在主流的架构的汇编语言，MIPS较为简单，适合入门。<br>MIPS汇编语言是可以一对一翻译成机械码的，每条指令的翻译规则不同，这里需要查手册来解决。<br>至于我们学的C/C++等高级语言，也可以翻译成汇编语言，这个过程叫编译，一般来说编译器可以办成这件事，但对于我们需要学习MIPS的人来说，这需要咱们自己来。</p>
<span id="more"></span>
<h1 id="mips汇编翻译C代码典例-经验"><a href="#mips汇编翻译C代码典例-经验" class="headerlink" title="mips汇编翻译C代码典例/经验"></a>mips汇编翻译C代码典例/经验</h1><blockquote>
<p>说是翻译C代码，其实要是在介绍如何MIPS汇编语言实现高级语言中出现的条件、循环、子程序结构。</p>
</blockquote>
<h2 id="二维数组的写法-内存的申请"><a href="#二维数组的写法-内存的申请" class="headerlink" title="二维数组的写法/内存的申请"></a>二维数组的写法/内存的申请</h2><ul>
<li>写法一：比较的基础，<code>data: .sapce memory_size_bit</code>，注意单位是bit</li>
<li>写法二：辨析.word/.byte/.half的两种写法(以.word为例)</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">data:</span>   <span class="meta">.word</span> <span class="number">64</span>        <span class="comment">#以字的形式储存64这个数，而不是像.space一样申请64字的内存</span></span><br><span class="line"><span class="symbol">data:</span>   <span class="meta">.word</span> <span class="number">0</span> : <span class="number">64</span>    <span class="comment">#以0为初始数据填到64个字的内存里，这才是我们想达到的效果</span></span><br><span class="line"><span class="comment">#所以你也可以</span></span><br><span class="line"><span class="symbol">data:</span>   <span class="meta">.word</span> <span class="number">1</span> : <span class="number">64</span>    <span class="comment">#得到64个(int)1</span></span><br></pre></td></tr></table></figure>
<h2 id="打好macro"><a href="#打好macro" class="headerlink" title="打好macro"></a>打好macro</h2><ul>
<li>打好macro很重要，他的功能类似于函数，能够消除ctrl+CV的代码重用（ly：这是一个很糟糕的事情），提高代码的可读性。</li>
<li>有很多常用的macro比如print、read、end、push等这些，详细请见我的另一个博客：<a href="http://volcaxiao.github.io/2022/10/12/mips常用宏定义/">mips常用宏定义</a></li>
<li>但我们每一次写mips都得自己手打macro，实在是不太优雅，于是我们可以用脚本来实现这样一个无脑功能。</li>
<li>通过脚本新建文件</li>
</ul>
<h2 id="函数一般模板写法"><a href="#函数一般模板写法" class="headerlink" title="函数一般模板写法"></a>函数一般模板写法</h2><ul>
<li>我们在函数调用的时候基本上可以遵循这样一个模板</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 入栈</span></span><br><span class="line">push($<span class="built_in">ra</span>)</span><br><span class="line"><span class="comment"># push(...)</span></span><br><span class="line"><span class="comment"># 传参</span></span><br><span class="line"><span class="keyword">move </span>   $<span class="built_in">t0</span>, $<span class="built_in">a0</span></span><br><span class="line"><span class="comment">#函数过程</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 出栈</span></span><br><span class="line"><span class="comment"># pop(...)</span></span><br><span class="line">pop($<span class="built_in">ra</span>)</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="keyword">jr </span>     $<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>虽然模板很简单，但我们还是得注意几个小问题</p>
</li>
<li><p>我们一般会把a_n作为函数的参数传递（约定俗成，本质上讲a_n和t_n啥的都是一样的，但是不约定规范，可读性和可维护性都会大打折扣）</p>
</li>
<li>push和pop要遵循LIFO(last in first out)，可不能一顿无脑pp，先push的要后面pop，要不然就会出现你的return到了一个不知名的地方。（很诡异</li>
<li>调用函数时，调用者里的用过的t函数一般要push进栈，为啥呢，也是约定俗成，具体请看下一节<a href="#ts寄存器之辩">t/s寄存器之辩</a></li>
</ul>
<h2 id="t-s寄存器之辩"><a href="#t-s寄存器之辩" class="headerlink" title="t/s寄存器之辩"></a>t/s寄存器之辩</h2><ul>
<li><p>这仅是我按照“t寄存器调用者维护，s寄存器被调用者维护”的一些个人的理解，自己看教程的时候其实不是很明白这句话的意思，但在后面打代码的过程中自己悟到了一些。</p>
</li>
<li><p>t寄存器调用者维护：</p>
<ul>
<li>t是指temporary，你把光标放置到Mars的寄存器处能够得到这个提示，意思就相当于临时变量。</li>
<li>由调用者维护的意思是你在调用别的函数时，你得保证你的t寄存器调用前和return后不会发生变化（类比在C中的临时变量），所以你应该去维护他。</li>
<li>一般的维护方法是用栈，在调用前先把t压入栈，调用后再把t pop出来，于是你的t就不会改变。</li>
</ul>
</li>
<li><p>s寄存器被调用者维护：</p>
<ul>
<li>s的含义是saved temporary，是指被调用函数不应改变s寄存器的值，就算要改变也应该先入栈最后再出栈。</li>
<li>总之，被调用函数在编写时应该要保证，函数前后s寄存器的值不发生变化。</li>
</ul>
</li>
<li><p>这是约定下来的规范，只有这样，用汇编这种灵活的语言才不会出岔子。</p>
</li>
</ul>
<h2 id="条件循环语句固定写法"><a href="#条件循环语句固定写法" class="headerlink" title="条件循环语句固定写法"></a>条件循环语句固定写法</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li>最基础的肯定还是if-else结构的语句，大致可以按照下面的写法：</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>另外进阶一点的是if-else_if-else结构</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最后是switch语句</li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul>
<li>固定for和if的写法，记得在for最后写上i++ j begin</li>
</ul>
<h3 id="多重逻辑判断"><a href="#多重逻辑判断" class="headerlink" title="多重逻辑判断"></a>多重逻辑判断</h3><ul>
<li>多重逻辑条件的写法</li>
</ul>
<h2 id="mips一般代码建议"><a href="#mips一般代码建议" class="headerlink" title="mips一般代码建议"></a>mips一般代码建议</h2><ul>
<li>写比对的C代码</li>
<li>写好注释</li>
<li>写好label</li>
<li>写好macro</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P2</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p3-单周期CPU(logisim实现)</title>
    <url>/2022/11/24/BUAA-CO-p3-%E5%8D%95%E5%91%A8%E6%9C%9FCPU-logisim%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>BUAA-CO课程project3，用logisim实现单周期的CPU</p>
<span id="more"></span>
<h1 id="p3-log"><a href="#p3-log" class="headerlink" title="p3_log"></a>p3_log</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><ul>
<li>两个mealy机 -&gt; 单周期CPU</li>
<li>控制器生成真值表</li>
<li>抽象和模块化</li>
<li>控制器打表</li>
<li>MIPS测试，设计数据</li>
<li>RAM与ROM的区别</li>
</ul>
<h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><ul>
<li>CPU分为两个部分，数据通路(Datapath)+控制器(control)</li>
</ul>
<h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><ul>
<li>一个MIPS数据通路又可以抽象为五步：取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)</li>
<li>相应的应该有PC、NPC、IM、RF、ALU、DM、Controller这几个大的模块，以及在实现的过程中会存在的MUX、EXT、Splitter这些小的模块（系统与子系统的模块）</li>
<li>数据通路是连接方式的组合，介于我们需要实现指令条数，我们通过这些指令的RTL描述，倒推出这条指令所需要的功能部件，从而建立起部件之间的连接关系，以及控制信号的取值。然后把这些连接关系填入数据通路的表中，填入每一个端口所需要的输入。</li>
<li>把所有的指令分析完后，归并每个端口的输入信号，信号来源唯一的端口可以直接连接，但多输入的情况我们需要MUX+Controller的实现。</li>
<li>得到最后的数据通路图后，我们很容易能构造出数据通路。</li>
</ul>
<h3 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h3><ul>
<li>控制器的设计过程，我们理解为通过opcode和function识别指令+输出相应的控制信号，这两步可以进一步抽象为和逻辑和或逻辑。</li>
<li>我们把表给列出来（其实这也是一种真值表）。</li>
<li>创建好以后，连线就行</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>确定所需实现的指令：addu，subu，ori，lw，sw，beq，jal，jr（MIPS-C0），add，sub，xor，jalr，nop，sll/sllv，lui，slt。</li>
<li>尽量每一种指令都来一下：<ul>
<li>R型：<ul>
<li>计算指令：add,sub,and, or</li>
<li>移位指令：sll,sra,sllv</li>
<li>置位指令：slt,sltu</li>
<li>跳转指令：jr,jalr</li>
<li>系统调用：syscall</li>
</ul>
</li>
<li>I型：<ul>
<li>计算指令：addi,ori,lui</li>
<li>置位指令：slti,sltiu</li>
<li>分支指令：beq,bne,bgtz</li>
<li>访存指令：lw,sw,lh,sh,lhu,lb,sb,lbu</li>
</ul>
</li>
<li>J型：<ul>
<li>跳转指令：j,jal</li>
</ul>
</li>
</ul>
</li>
<li>把每个模块组装好，设计好端口</li>
<li><p>打表连接</p>
</li>
<li><p>在端口的命名中我们采取的一些命名缩写，它的意义是</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命名</th>
<th style="text-align:center">意义</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WD</td>
<td style="text-align:center">write data</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RD</td>
<td style="text-align:center">read data</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">address</td>
</tr>
<tr>
<td style="text-align:center">WR</td>
<td style="text-align:center">write reg</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">write enable</td>
</tr>
</tbody>
</table>
</div>
<h3 id="PC-NPC实现"><a href="#PC-NPC实现" class="headerlink" title="PC/NPC实现"></a>PC/NPC实现</h3><ul>
<li>PC用寄存器实现</li>
<li>NPC先实现一个简单的+4功能</li>
<li><p>后续跳转指令加入时再看</p>
</li>
<li><p>beq：在ALU的地方返回一个rs=rt的结果到NPC，把imm16传到NPC，再传个控制器信号，是beq就跳</p>
</li>
<li>jal：在这里我们的控制信号就要多增加，而且不仅要计算PC+4+imm26的值，我们还需要计算PC+4的值，写入31号$sp寄存器</li>
<li>j：与jal的区别仅在于，不用回写</li>
<li>jr：PC &lt;- GPR[rs],需要读入rs寄存器的值</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">方向</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前位置</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm[26]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">26位立即数</td>
<td style="text-align:center">beq是imm16,jal是add26,可以覆盖</td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">jr需要的32位返回地址</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">BeqYes?</td>
<td style="text-align:center">I</td>
<td style="text-align:left">rs,rt相等的标志</td>
<td style="text-align:center">NPCOp=001起作用</td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：<br> 000: 顺序地址 <br> 001: beq <br> 010: j <br> 011: jal <br> 100: jr</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出接下来的PC</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">PC4[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">PC+4</td>
</tr>
</tbody>
</table>
</div>
<h3 id="IM实现"><a href="#IM实现" class="headerlink" title="IM实现"></a>IM实现</h3><ul>
<li>IM没有写入的要求，用ROM即可，指令为32位，地址位宽可以选取8（即256条指令）</li>
</ul>
<h3 id="InstructionSplitter"><a href="#InstructionSplitter" class="headerlink" title="InstructionSplitter"></a>InstructionSplitter</h3><ul>
<li>在32位的机器码中根据MIPS指令的类型我们需要得到opcode、rs、rt、rd、shamt、funt、imm16、address，在RIJ型的指令中分别会用到，但是我们并不需要判断指令类型给出相应的输出。我们把这些都给输出，需要什么是后续元件与Controller的事。</li>
</ul>
<h3 id="RF实现"><a href="#RF实现" class="headerlink" title="RF实现"></a>RF实现</h3><ul>
<li>这里在p0已经写过了，就直接CV了，但是注意端口的命名可以改一下。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:center">时钟信号</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">clr</td>
<td style="text-align:center">I</td>
<td style="text-align:center">异步复位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:center">写使能，为1时可以写入</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">指定32各寄存器中的一个，将值读入RD1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">指定32各寄存器中的一个，将值读入RD2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">指定32各寄存器中的一个，作为WD值的写入对象</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">在WE为1，将内容写入A3指定的寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:center">输出A1指定的寄存器的值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:center">输出A2指定的寄存器的值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ALU（重点！）"><a href="#ALU（重点！）" class="headerlink" title="ALU（重点！）"></a>ALU（重点！）</h3><ul>
<li><p>在最后加一个MUX输出</p>
</li>
<li><p>addu：直接用加法器</p>
</li>
<li>subu：直接用减法器</li>
<li>slt：比较器</li>
<li>ori：有i的都可以按照这个思路来，在RD2与imm16（Zero_ext32）之间加一个MUX，剩下交给控制器</li>
<li>lw：这里我们需要EXT来实现立即数的符号位拓展，而在ori指令中有非符号位拓展，把他们集成起来做一个EXT模块，剩下交给控制器去决定，R[rt] &lt;- MEM[R[rs]+sign_ext(imm16)]，所以rt与rd到A3加一个MUX</li>
<li>sw：MEM[R[rs]+sign_ext(imm16)] &lt;- R[rt]，RD2接到DMWD</li>
<li>考虑到跳转指令需要对NPC模块进行改装，beq、j、jal、jr指令的实现就放到<a href="#pcnpc实现">PC/NPC实现</a>里了</li>
<li>下面是不同的ALUOp代表的功能</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ALUOp</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0000</td>
<td style="text-align:center">addu</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">subu</td>
</tr>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">ori</td>
</tr>
<tr>
<td style="text-align:center">0011</td>
<td style="text-align:center">slt</td>
</tr>
<tr>
<td style="text-align:center">0100</td>
<td style="text-align:center">lw</td>
</tr>
<tr>
<td style="text-align:center">0101</td>
<td style="text-align:center">sw</td>
</tr>
</tbody>
</table>
</div>
<h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ExtOp</td>
<td style="text-align:center">I</td>
<td style="text-align:center">选择拓展方式：<br> 0: 0拓展<br>1: 符号位拓展</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm16</td>
<td style="text-align:center">I</td>
<td style="text-align:center">输入的16位立即数</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm32</td>
<td style="text-align:center">O</td>
<td style="text-align:center">输出的32位立即数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><ul>
<li>用一个可写入的RAM来实现</li>
<li>用位拓展器把传入的32位值变为8位</li>
</ul>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>可以分为两个部分，一个是识别器，一个是信号器</li>
<li>根据后面的信号表与和或逻辑来搭建</li>
<li>注意合理CV，不然会很难受</li>
<li>注意测试</li>
<li>问题：nop不需要控制为啥，因为nop的时候NPCOp=000，几个WE都是0，写不进东西，所以不需要控制</li>
</ul>
<blockquote>
<p>自此，框架已经搭好，现在开始做打表连接</p>
</blockquote>
<h3 id="数据通路表及控制信号表"><a href="#数据通路表及控制信号表" class="headerlink" title="数据通路表及控制信号表"></a>数据通路表及控制信号表</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/指令RTL描述.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/指令RTL描述.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="指令的RTL描述"></p>
<ul>
<li>下面根据RTL描述写出数据通路表</li>
<li>每一个指令需要将什么端口连接，指令级数据通路与控制器建模，先忽略控制信号的端口<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据通路表"></li>
<li>相应的在分析每条指令的通路的时候可以把控制信号的取值记下来，暂时不包含MUX的控制<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="控制信号表"></li>
<li>所以数据通路连接的总合计为<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/连接总合计.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/连接总合计.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连接总合计"></li>
<li>在根据数据通路表中的多输入端口，把MUX的Sel信号写入控制信号表<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/MUX控制信号表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/MUX控制信号表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MUX控制信号表"></li>
</ul>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ul>
<li>ROM的寻址方式</li>
<li>加入指令lui<ul>
<li>在数据通路连接表与信号控制表里加入它，然后把该连的线连起来</li>
<li>按照控制表打控制器</li>
</ul>
</li>
<li>发现一个ori在mars里调用了ori、lui、or</li>
<li>但是or除了ALUOp不同以外其余都相同</li>
<li>add,sub</li>
<li>DM写入地址输出</li>
<li>imm32,address移位但ra不移，所以对应到p3的处理办法，ra应该移位</li>
<li>beq的imm16要符号位拓展(p4的时候才发现这个bug，可见测试数据还是很弱的，需要自己造数据)</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>每条指令功能都测试一下</li>
<li>每条指令考虑正负等等</li>
<li>用disassembler的工具进行机械码转汇编语言<ul>
<li>转换注意：b -&gt; j</li>
<li>neg -&gt; sub</li>
</ul>
</li>
<li>CPU的每一步对应着MARS调试的每一步</li>
<li>jr指令可以跳到所有寄存器的储存值，注意！</li>
</ul>
<h2 id="后续增量开发"><a href="#后续增量开发" class="headerlink" title="后续增量开发"></a>后续增量开发</h2><ul>
<li>思考是RIJ哪种指令，思考需不需要跳转<ul>
<li>R型I型对应不同的WRSel</li>
<li>跳转要改变NPCOp和NPC接口</li>
<li>写对应的控制信号</li>
</ul>
</li>
<li>下面由于特殊性，加上lh,lb,sh,sb, sll指令</li>
<li>对于lh,sh,lb,sb,lbu,lhu指令,下面以lb,sb,lbu为例<ul>
<li>改版DM，增加DMOp<a href="第三位表示是否无符号拓展">2:0</a></li>
<li>store操作：通过out与WD的7:0拼起来读入，根据A决定</li>
<li>load操作：只输出out的8位（根据A来决定），注意拓展</li>
<li>其余模块都与sw，lw一致</li>
</ul>
</li>
<li>sll指令比较的特殊，需要加上ASel（为1时选择shamt）</li>
<li>Controller指令的顺序改进</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。<ul>
<li>状态存储：IM，RF，DM</li>
<li>状态转移：NPC，ALU</li>
</ul>
</li>
<li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。<ul>
<li>正确的，合理的，无可挑剔的</li>
</ul>
</li>
<li>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。<ul>
<li>我把Controller分为了两个部分，一个是识别器，一个是信号发送器，主要考虑是可以在main电路中调试的时候看到当前执行的指令。</li>
</ul>
</li>
<li>事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？<ul>
<li>因为nop的时候NPCOp=000，没有跳转，而且几个WE使能是0，写不进东西，所以不需要控制</li>
<li>而且我写了sll，所以nop就对应着移0位的sll，等同于没有修改。</li>
</ul>
</li>
<li>上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。<ul>
<li>可以把其中一个起始地址先设为0，然后另一个可以通过写程序实现判断与修改。</li>
</ul>
</li>
<li>阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。<ul>
<li>有些寄存器没有用到，有些负数的特殊情况没有涉及（比如beq的负数情况），跳转的指令没有设计</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P3</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p4单周期CPU-verilog实现</title>
    <url>/2022/11/24/BUAA-CO-p4%E5%8D%95%E5%91%A8%E6%9C%9FCPU-verilog%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>BUAA-CO课程p4，用verilog实现单周期的CPU</p>
<span id="more"></span>
<h1 id="p4-log"><a href="#p4-log" class="headerlink" title="p4_log"></a>p4_log</h1><h2 id="模块化层次化"><a href="#模块化层次化" class="headerlink" title="模块化层次化"></a>模块化层次化</h2><ul>
<li>整体结构与p3中logisim的分层一致，顶层端口定义为mips.v</li>
<li>不同：<ul>
<li>需要增加同步复位信号reset</li>
<li>clk留端口，而不是内置</li>
</ul>
</li>
<li>需要支持的指令集为：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</li>
<li>后期添加的指令为：slt,sll,lh,sh,lbu</li>
</ul>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><ul>
<li>模块化、端口定义等等大致和p3一致</li>
<li>连线的时候的命名：推荐使用模块+输出端口命名法，小写字母表示，每一个模块的线放一块，这样输入的时候一目了然<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/连线命名方式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/连线命名方式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连线命名"></li>
<li>注意存储器地址访问的/4细节，思考题中的[11:2]应该就是出于这个考虑</li>
</ul>
<h3 id="datapath"><a href="#datapath" class="headerlink" title="datapath"></a>datapath</h3><ul>
<li>所有的MUX放在同一个MUX.v的文件中，命名为：MUX_SelNum_bit(默认为32位), 如MUX_4,MUX_4_26,MUX_2_5;</li>
</ul>
<h4 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">异步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址2</td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入的数据</td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A1地址寄存器中的值</td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A2地址寄存器中的值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前指令地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Simm26[25:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">地址偏移</td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">返回地址</td>
</tr>
<tr>
<td style="text-align:center">CmpOut</td>
<td style="text-align:center">I</td>
<td style="text-align:left">B类指令的比较结果</td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：&lt;/br&gt; 000: 顺序+4 &lt;/br&gt; 001: B类跳转 &lt;/br&gt;010: jal/j &lt;/br&gt; 011:jr/jalr</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">下一条指令地址</td>
</tr>
</tbody>
</table>
</div>
<h4 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h4><p>信号名|IO|描述|备注|<br>|:-:|:-:|:-|:-|<br>|imm16[15:0]|I|16位立即数|<br>|EXTOp|I|EXT功能选择：&lt;/br&gt; 0: 0拓展 &lt;/br&gt; 1: 符号位拓展|lui指令的高位拓展在ALU里执行|<br>|S0imm32|O|拓展后的32位立即数|</p>
<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">ALU功能选择</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">位移值</td>
</tr>
<tr>
<td style="text-align:center">ALUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">计算结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">异步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待操作数据的地址</td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">DMout[31:0]</td>
<td style="text-align:center">输出的32位数据</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据通路表"></p>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul>
<li>对于控制器，我采用先用操作码识别出不同的指令，再去记录下每个控制信号所对应的指令，因为这样更加符合电路的直观（或运算），也更符合我对未来的想象（）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="控制信号表"></li>
</ul>
<h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><ul>
<li>还是用p3时候的测试数据，但是需要多多注意的是这个东西肉眼debug其实还好一点，但更加适合自动化评测，开始手搓！</li>
</ul>
<h2 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h2><h3 id="slt"><a href="#slt" class="headerlink" title="slt"></a>slt</h3><ul>
<li>处理ctrl，ALU，先填表再连线</li>
</ul>
<h3 id="sll"><a href="#sll" class="headerlink" title="sll"></a>sll</h3><ul>
<li>shamt传入ALU，其他就没什么问题了</li>
</ul>
<h3 id="lh，sh，lhu"><a href="#lh，sh，lhu" class="headerlink" title="lh，sh，lhu"></a>lh，sh，lhu</h3><ul>
<li>加上DMOp，在前面有定义</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0]<ul>
<li>从ALUout输出过来，是按字节寻址的指令，但我们的IM是按字寻址的，addr应该是4的整数倍，所以左移两位，按字存取。</li>
</ul>
</li>
<li>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。<ul>
<li>第二种是最后靠信号输出的，更符合电路的或逻辑，便于后续开发，且更加符合电路</li>
</ul>
</li>
<li>在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。<ul>
<li>异步复位reset的优先级高于clk，不管clk是否处于上升沿，都会复位（所以需要加入触发条件中）。</li>
<li>而同步复位的reset优先级低于clk，只有clk到来才会生效。</li>
</ul>
</li>
<li>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。<ul>
<li>addi和add，在operate中加入了溢出检测</li>
<li>以add为例</li>
<li><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/加法检测.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/加法检测.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="加法检测"></li>
<li>若R[rs]和R[rt]的30都是1且31相同的话，就分别对应正数和负数的溢出情况，则这么计算后temp32!temp31，不相等，所以溢出。</li>
<li>检测溢出后就会抛出异常，但没有检测溢出的话，还是正常计算，所以和addiu，addu一样。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P4</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p5流水线CPU-lite</title>
    <url>/2022/11/24/BUAA-CO-p5%E6%B5%81%E6%B0%B4%E7%BA%BFCPU-lite/</url>
    <content><![CDATA[<p>BUAA-CO课程p5，用verilog实现五级流水线的CPU，首次操作难度较大</p>
<span id="more"></span>
<h1 id="p5-log"><a href="#p5-log" class="headerlink" title="p5_log"></a>p5_log</h1><h2 id="设计思路-纲领"><a href="#设计思路-纲领" class="headerlink" title="设计思路-纲领"></a>设计思路-纲领</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>我们先通过对于RTL构造出无需转发的数据通路表</li>
<li>在考虑转发的情况构造出转发的数据通路</li>
<li><p>搭建电路（图文结合）</p>
</li>
<li><p>然后逐条指令分析主控制器控制信号</p>
</li>
<li>逐条指令分析$T_{use}, T_{new} $</li>
<li>构造策略矩阵</li>
<li><p>写控制表达式</p>
</li>
<li><p>这是一个自下而上的过程</p>
</li>
<li>可以先实现p5所需的基础指令</li>
<li><p>然后对于MIPS-C3架构指令集增量开发</p>
</li>
<li><p>最后构建自动化测试与样例生成器</p>
</li>
</ul>
<h3 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h3><ul>
<li>对于指令的分类很重要</li>
<li>下面是所需要是实现的指令类和指令</li>
<li>寄存器寄存器计算：add, sub, slt, sltu, and, or, xor</li>
<li>寄存器立即数计算：addi, slti, andi, ori, xori</li>
<li>位移类： sll, srl, sra, sllv, srlv, srav</li>
<li>B类：beq, bne</li>
<li>store：sw, sh, sb</li>
<li><p>load：lw, lh, lhu, lb, lbu</p>
</li>
<li><p>跳转并链接：jal, jalr, j</p>
</li>
<li>跳转寄存器：jr, jalr</li>
<li>加载高位：lui</li>
<li>空指令：nop</li>
<li>读乘除法寄存器：mfhi, mflo</li>
<li><p>写乘除法寄存器：mult, multu, div, divu, mthi, mtlo</p>
</li>
<li><p>p5要求实现的基础指令有：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</p>
</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>在控制信号连线名末尾加上_阶段字母，如：NPCOp_D，用以区分所属阶段</li>
<li>在寄存器输出信号前加上阶段字母_, 如：D_A1,用以区分所属阶段</li>
<li>功能部件输出信号前加上功能部件.，（实际打码时舍弃）</li>
<li>MUX命名采取X_输入端口名_选择数</li>
<li>转发MUX命名采用F_输入端口名_选择数，级数越大优先级越高</li>
</ul>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><h4 id="数据通路表"><a href="#数据通路表" class="headerlink" title="数据通路表"></a>数据通路表</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/数据通路表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据通路表"></p>
<h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><h5 id="IFU-PC-IM"><a href="#IFU-PC-IM" class="headerlink" title="IFU(PC\IM)"></a>IFU(PC\IM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能</td>
<td style="text-align:left">暂停时使用</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">由NPC返回，下一条指令的PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前执行的指令地址</td>
</tr>
<tr>
<td style="text-align:center">instr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前执行的指令</td>
</tr>
</tbody>
</table>
</div>
<h5 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h5><ul>
<li>内部转发</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址2</td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入的数据</td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A1地址寄存器中的值</td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A2地址寄存器中的值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D1[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据1</td>
</tr>
<tr>
<td style="text-align:center">D2[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据2</td>
</tr>
<tr>
<td style="text-align:center">CMPOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">CMP功能选择：&lt;/br&gt; 000: beq &lt;/br&gt; 001: bne &lt;/br&gt; 010: blez &lt;/br&gt; 011: bgtz</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">O</td>
<td style="text-align:left">结果为1则分支跳转，为0不跳转</td>
</tr>
</tbody>
</table>
</div>
<h5 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前指令地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Simm26[25:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">地址偏移</td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">返回地址</td>
</tr>
<tr>
<td style="text-align:center">CmpOut</td>
<td style="text-align:center">I</td>
<td style="text-align:left">B类指令的比较结果</td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：&lt;/br&gt; 000: 顺序+4 &lt;/br&gt; 001: B类跳转 &lt;/br&gt;010: jal/j &lt;/br&gt; 011:jr/jalr</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">下一条指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">imm16[15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">16位立即数</td>
</tr>
<tr>
<td style="text-align:center">EXTOp</td>
<td style="text-align:center">I</td>
<td style="text-align:left">EXT功能选择：&lt;/br&gt; 0: 0拓展 &lt;/br&gt; 1: 符号位拓展</td>
<td style="text-align:left">lui指令的高位拓展在ALU里执行</td>
</tr>
<tr>
<td style="text-align:center">S0imm32</td>
<td style="text-align:center">O</td>
<td style="text-align:left">拓展后的32位立即数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">ALU功能选择</td>
<td style="text-align:left">具体对于功能后有附录</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">位移值</td>
</tr>
<tr>
<td style="text-align:center">ALUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">计算结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="MDU-乘除模块"><a href="#MDU-乘除模块" class="headerlink" title="MDU(乘除模块)"></a>MDU(乘除模块)</h5><h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待操作数据的地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待写入的数据</td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">DMout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出的32位数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h4><ul>
<li>每个流水线寄存器都保存着一条指令完成后续操作所需要的的全部信息。</li>
<li>对于每一个流水线的产生结果的级次，我需要用一个MUX来确定哪个是当前指令的用于转发的有效数据，PC+8， ALUout，DMout，所以我们增加outSel的选择信号，此选择信号可以代替RFWDSel的功能</li>
</ul>
<h5 id="D-IF-ID"><a href="#D-IF-ID" class="headerlink" title="D(IF/ID)"></a>D(IF/ID)</h5><ul>
<li>可以在D级内置Splitter</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">暂停时置位0</td>
</tr>
<tr>
<td style="text-align:center">F_instr[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级取出的指令</td>
</tr>
<tr>
<td style="text-align:center">F_PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级输出的指令PC</td>
</tr>
<tr>
<td style="text-align:center">D_opcode[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前D级的opcode</td>
</tr>
<tr>
<td style="text-align:center">D_rs[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rs</td>
</tr>
<tr>
<td style="text-align:center">D_rt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
</tr>
<tr>
<td style="text-align:center">D_rd[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rd</td>
</tr>
<tr>
<td style="text-align:center">D_shamt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">偏移量，位移指令使用</td>
</tr>
<tr>
<td style="text-align:center">D_funct[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">funtion码</td>
</tr>
<tr>
<td style="text-align:center">D_imm16[15:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">16位立即数</td>
</tr>
<tr>
<td style="text-align:center">D_address[25:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">26位地址</td>
</tr>
<tr>
<td style="text-align:center">D_PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D级当前指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="E-ID-EX"><a href="#E-ID-EX" class="headerlink" title="E(ID/EX)"></a>E(ID/EX)</h5><ul>
<li>从E级开始流水控制信号</li>
<li>T_new-1</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
<td style="text-align:left">暂停时置为1</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A1</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_shamt</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_S0imm32</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_shamt</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_S0imm32</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_E[3:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">BSel_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="M-EX-MEM"><a href="#M-EX-MEM" class="headerlink" title="M(EX/MEM)"></a>M(EX/MEM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_M[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="W-MEM-WB"><a href="#W-MEM-WB" class="headerlink" title="W(MEM/WB)"></a>W(MEM/WB)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_DR</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[4:0] W_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_DR</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_W</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h3 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h3><ul>
<li>此CPU采用集中译码的方式，在D级译码，控制信号进入流水，使用过的就不用进入了</li>
<li>T_new产生后随着流水线递减</li>
<li>分为MCU，HCU</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/控制信号表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="控制信号表"></p>
<h4 id="主控制器（MCU）"><a href="#主控制器（MCU）" class="headerlink" title="主控制器（MCU）"></a>主控制器（MCU）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">opcode[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_opcode</td>
</tr>
<tr>
<td style="text-align:center">funct[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_funct</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NPCOp_D[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DEXTOp_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">imm26Sel_D</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DA3Sel_D[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left">E_ALU_B信号选择：{}</td>
</tr>
<tr>
<td style="text-align:center">outSel[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">有效转发数据Sel</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令用到rs寄存器所剩下的时间</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令产生结果所需的时间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>MUX控制信号的具体含义可以看数据通路表</li>
</ul>
<h4 id="冒险控制器（HCU）"><a href="#冒险控制器（HCU）" class="headerlink" title="冒险控制器（HCU）"></a>冒险控制器（HCU）</h4><ul>
<li>空行表示逻辑与功能上的分割</li>
<li>我这里只需要D级输出T_use因为我只有stall需要用到T_use，而stall应只在D级就决定，转发只需判断Tnew==0</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D_A1[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">D_A2[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A1[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">E_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">W_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFRD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">NPC读入RA的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD1的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD2的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_A的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_B的转发</td>
</tr>
<tr>
<td style="text-align:center">DMV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM_WD的转发</td>
</tr>
<tr>
<td style="text-align:center">stall</td>
<td style="text-align:center">O</td>
<td style="text-align:left">暂停信号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Sel结尾代表常规MUX信号，Fwd结尾代表转发MUX信号</li>
<li>转发MUX的Sel的含义大致是数字越大优先级越高，优先级是E、M、W</li>
</ul>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><ul>
<li>特别注意在M_V2存入F_ALU_V2</li>
</ul>
<h3 id="跳转分支指令"><a href="#跳转分支指令" class="headerlink" title="跳转分支指令"></a>跳转分支指令</h3><ul>
<li>要特别注意PC+8的转发问题，当检测到jal时转发</li>
</ul>
<h3 id="冒险处理"><a href="#冒险处理" class="headerlink" title="冒险处理"></a>冒险处理</h3><ul>
<li>遵循暴力转发策略，在打好常规的数据通路表后，观察哪些端口需要用到寄存器值（需求者），再把所有的供给者的情况遍历出来</li>
<li>AT法: 需求者是需要用这个值来运算的，找到所有与V，RD相关的端口；供给者是需要这个值来存入的，考虑它啥时候能够算出来。</li>
<li>因此对于 $T_{use} $ 我们只需要考虑被需求所以只可能在DEM级</li>
<li>对于</li>
<li>$T_{use} = 0$: beq, jr</li>
<li>$T_{use} = 1$: add, sub, ori, lw, sw</li>
<li>$T_{use} = 2$: lw, sw</li>
<li>表出来后，尽量转发</li>
<li>暂停的机制：暂停IF,暂停D级，清空E级，</li>
<li>转发机制：结果出来后都转发，只需改变控制信号。</li>
<li>我们把RFWE放入HCU用以保证写使能信号有效（有效数据）</li>
<li>判断A3!=0</li>
<li>注意对于不要用的rt，rs置位2</li>
</ul>
<h4 id="冒险控制表"><a href="#冒险控制表" class="headerlink" title="冒险控制表"></a>冒险控制表</h4><ul>
<li>先根据每一条指令，整理其Tuse，Tnew</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/指令时间表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/指令时间表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="指令时间表"></p>
<ul>
<li>再根据每条指令的时间列出转发暂停控制信号表</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/冲突控制表.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/冲突控制表.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="冲突控制表"></p>
<h2 id="测试数据及自动化测试"><a href="#测试数据及自动化测试" class="headerlink" title="测试数据及自动化测试"></a>测试数据及自动化测试</h2><h3 id="常规测试"><a href="#常规测试" class="headerlink" title="常规测试"></a>常规测试</h3><ul>
<li>这里同p4的测试</li>
</ul>
<h3 id="冒险测试"><a href="#冒险测试" class="headerlink" title="冒险测试"></a>冒险测试</h3><ul>
<li>对于冲突进行覆盖性分析，需要我们根据冲突表，45种情况每一种都设计相应的冒险测试数据（建立在基础测试通过的情况下）</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><ul>
<li>我实现了一个半自动化的测试程序具体见上交的材料</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。<ul>
<li>我们使用两个寄存器值的时间最早来到了D级，所以很可能会引发暂停.</li>
<li>如下面这种情况，若beq的结果在E级产生，则不需要暂停，可以转发，但是现在beq在D级的时候lw还在M级，没有产生结果，需要暂停。</li>
</ul>
</li>
</ol>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span>   $<span class="built_in">t0</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beq </span>  $<span class="built_in">t0</span>, $<span class="built_in">t0</span>, label</span><br></pre></td></tr></table></figure>
<ol>
<li>因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？<ul>
<li>因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把PC+8写入寄存器，不然jr时延迟槽内的指令会再执行一次</li>
</ul>
</li>
<li>我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？<ul>
<li>来自寄存器的值是当前这一级的值，而功能部件输出的值是要写入下一级的，有一定的延迟，不能统一时间，转发的值就不稳定</li>
</ul>
</li>
<li>我们为什么要使用 GPR 内部转发？该如何实现？<ul>
<li>为了保持W级的写入和此时D级的读出是同一个值，规避数据冒险。实现方法就是在RF模块里加上一个MUX，判断当冲突条件满足时，转发。</li>
</ul>
</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> RD1 = (A3 == A1) &amp; (A3 != <span class="number">0</span>) &amp; (en == <span class="number">1</span>)? WD : greg[A1];</span><br><span class="line"><span class="keyword">assign</span> RD2 = (A3 == A2) &amp; (A3 != <span class="number">0</span>) &amp; (en == <span class="number">1</span>)? WD : greg[A2];</span><br></pre></td></tr></table></figure>
<ul>
<li>当然不使用内部转发的话也不是不行，可以把Wout接入RD出口的转发多路选择器。</li>
</ul>
<ol>
<li>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？<ul>
<li>需求者有：NPC.RA, CMP.D1|D2, ALU.V1|V2, DM.WD</li>
<li>供给者：PC+8, ALU, DM</li>
<li>转发数据通路：每一级上加上一个outMUX，用于选择转发回去的结果，选择信号每条指令不同；在每个需求者端口前加上转发MUX，用于接收来自E, M, W三级的转发。</li>
</ul>
</li>
<li>在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。<ul>
<li>增加了sll，sb|lb|lbu指令，所以课上的拓展大多数能覆盖到</li>
<li>高内聚低耦合原理：大多数只需要改变控制信号以及相应的功能模块增加功能，但不排除某些需要修改数据通路</li>
<li>对于计算类：首先改变MCU，注意每个指令的控制信号的对应，再改ALU的结构，增加输出选择</li>
<li>对于访存类：改变MCU+修改DM增加相应的功能</li>
<li>对于跳转类：修改MCU+NPC相应功能修改</li>
<li>小技巧：寻找已有的指令中与新增的指令相似的指令（可能不止一条），然后顺着这几条指令改。</li>
</ul>
</li>
<li>简要描述你的译码器架构，并思考该架构的优势以及不足。<ul>
<li>我当前是集中式译码</li>
<li>优势：不需要编写多个译码器</li>
<li>不足：流水线寄存器会变得十分的臃肿</li>
</ul>
</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">0</span>] = _beq | _jal ;</span><br><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">1</span>] = _j | _jal;</span><br><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">2</span>] = _jr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DEXTOp = _lw | _sw | _lb | _lbu | _sb ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">0</span>] = _sub | _slt | _sll;</span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">1</span>] = _ori | _slt ;</span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">2</span>] = _lui | _sll ;</span><br><span class="line"><span class="keyword">assign</span> ALUOp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> CMPOp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> CMPOp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> CMPOp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DMOp[<span class="number">0</span>] = _lbu | _lb | _sb;</span><br><span class="line"><span class="keyword">assign</span> DMOp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> DMOp[<span class="number">2</span>] = _lbu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> RFWE = _add | _sub | _ori | _slt | _lw | _jal | _lui | _lb | _lbu | _sll;</span><br><span class="line"><span class="keyword">assign</span> DMWE = _sw | _sb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> imm26Sel = _j | _jal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DA3Sel[<span class="number">0</span>] = _ori | _lw | _lui | _lb | _lbu;</span><br><span class="line"><span class="keyword">assign</span> DA3Sel[<span class="number">1</span>] = _jal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> BSel = _ori | _lw | _sw | _lui | _lb | _lbu | _sb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> outSel[<span class="number">0</span>] = _add | _sub | _ori | _slt | _lui | _sll;</span><br><span class="line"><span class="keyword">assign</span> outSel[<span class="number">1</span>] = _lw | _lb | _lbu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> T_rsUse[<span class="number">0</span>] = _add | _sub | _ori | _lw | _sw | _lui | _lb | _lbu | _sb;</span><br><span class="line"><span class="keyword">assign</span> T_rsUse[<span class="number">1</span>] = (_jal | _sll);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> T_rtUse[<span class="number">0</span>] = _add | _sub | _sll;</span><br><span class="line"><span class="keyword">assign</span> T_rtUse[<span class="number">1</span>] = _sw | _sb | (_ori | _lw | _lui | _jal | _jr | _lb | _lbu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> T_new_D[<span class="number">0</span>] = _lw | _lb | _lbu;</span><br><span class="line"><span class="keyword">assign</span> T_new_D[<span class="number">1</span>] = _lw | _add | _sub | _ori | _lui | _lb | _lbu | _sll;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P5</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p6流水线CPU-pro</title>
    <url>/2022/11/24/BUAA-CO-p6%E6%B5%81%E6%B0%B4%E7%BA%BFCPU-pro/</url>
    <content><![CDATA[<p>BUAA-CO课程p6，在p5的基础上，增加一些基础指令，IM、DM外置，增加乘除模块等</p>
<span id="more"></span>
<h1 id="p6-log"><a href="#p6-log" class="headerlink" title="p6_log"></a>p6_log</h1><blockquote>
<p>p6在p5的基础上进行改进，除了加指令外，有几点改动<br>通过output传出相应信号不再使用$display<br>IM，DM外置只留下相应接口<br>但需要实现单独的乘除法模块和数据拓展模块</p>
</blockquote>
<h2 id="设计思路-纲领"><a href="#设计思路-纲领" class="headerlink" title="设计思路-纲领"></a>设计思路-纲领</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>我们先通过对于RTL构造出无需转发的数据通路表</li>
<li>在考虑转发的情况构造出转发的数据通路</li>
<li><p>搭建电路（图文结合）</p>
</li>
<li><p>然后逐条指令分析主控制器控制信号</p>
</li>
<li>逐条指令分析 $T_{use}, T_{new} $</li>
<li>构造策略矩阵</li>
<li><p>写控制表达式</p>
</li>
<li><p>这是一个自下而上的过程</p>
</li>
<li>可以先实现p5所需的基础指令</li>
<li><p>然后对于MIPS-C3架构指令集增量开发</p>
</li>
<li><p>最后构建自动化测试与样例生成器</p>
</li>
</ul>
<h3 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h3><ul>
<li>对于指令的分类很重要</li>
<li>下面是所需要是实现的指令类和指令</li>
<li>寄存器寄存器计算：add, sub, and, or, slt, sltu,  xor</li>
<li>寄存器立即数计算：addi, andi, ori, slti, xori</li>
<li>位移类： sll, srl, sra, sllv, srlv, srav</li>
<li>B类：beq, bne</li>
<li>store：sw, sh, sb</li>
<li><p>load：lw, lh, lhu, lb, lbu</p>
</li>
<li><p>跳转并链接：jal, jalr, j</p>
</li>
<li>跳转寄存器：jr, jalr</li>
<li>加载高位：lui</li>
<li>空指令：nop</li>
<li>读乘除法寄存器：mfhi, mflo</li>
<li><p>写乘除法寄存器：mult, multu, div, divu, mthi, mtlo</p>
</li>
<li><p>p5要求实现的基础指令有：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</p>
</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>在控制信号连线名末尾加上_阶段字母，如：NPCOp_D，用以区分所属阶段</li>
<li>在寄存器输出信号前加上阶段字母_, 如：D_A1,用以区分所属阶段</li>
<li>功能部件输出信号前加上功能部件.，（实际打码时舍弃）</li>
<li>MUX命名采取X_输入端口名_选择数</li>
<li>转发MUX命名采用F_输入端口名_选择数，级数越大优先级越高</li>
</ul>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><h4 id="数据通路表"><a href="#数据通路表" class="headerlink" title="数据通路表"></a>数据通路表</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%A1%A8.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%A1%A8.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据通路表"></p>
<h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><h5 id="IFU-PC-IM"><a href="#IFU-PC-IM" class="headerlink" title="IFU(PC\IM)"></a>IFU(PC\IM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能</td>
<td style="text-align:left">暂停时使用</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">由NPC返回，下一条指令的PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前执行的指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h5><ul>
<li>内部转发</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读出地址2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A1地址寄存器中的值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出A2地址寄存器中的值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D1[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D2[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待比较数据2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">CMPOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">CMP功能选择：&lt;/br&gt; 000: beq &lt;/br&gt; 001: bne &lt;/br&gt; 010: blez &lt;/br&gt; 011: bgtz</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">O</td>
<td style="text-align:left">结果为1则分支跳转，为0不跳转</td>
</tr>
</tbody>
</table>
</div>
<h5 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">当前指令地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Simm26[25:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">地址偏移</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ra[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">返回地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">CmpOut</td>
<td style="text-align:center">I</td>
<td style="text-align:left">B类指令的比较结果</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">NPCOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">NPC功能选择：&lt;/br&gt; 000: 顺序+4 &lt;/br&gt; 001: B类跳转 &lt;/br&gt;010: jal/j &lt;/br&gt; 011:jr/jalr</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">下一条指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">imm16[15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">16位立即数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">EXTOp</td>
<td style="text-align:center">I</td>
<td style="text-align:left">EXT功能选择：&lt;/br&gt; 0: 0拓展 &lt;/br&gt; 1: 符号位拓展</td>
<td style="text-align:left">lui指令的高位拓展在ALU里执行</td>
</tr>
<tr>
<td style="text-align:center">S0imm32</td>
<td style="text-align:center">O</td>
<td style="text-align:left">拓展后的32位立即数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">ALU功能选择</td>
<td style="text-align:left">具体对于功能后有附录</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">位移值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ALUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">计算结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="MDU-乘除模块"><a href="#MDU-乘除模块" class="headerlink" title="MDU(乘除模块)"></a>MDU(乘除模块)</h5><ul>
<li>给M，W级的out中加上MDUout</li>
<li>busy阻塞实现：将busy和start_E，MDUOP_D接入HCU</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">start</td>
<td style="text-align:center">I</td>
<td style="text-align:left">开始运算信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">MDUOp[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">乘除模块功能选择信号</td>
<td style="text-align:left">见附录</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">运算数2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Busy</td>
<td style="text-align:center">O</td>
<td style="text-align:left">乘除法延迟符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">HI[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">HI寄存器输出值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">LO[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">LO寄存器输出值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">MDUout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">MDU输出(HI \</td>
<td style="text-align:left">LO)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>功能选择信号定义</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">MDUOp[3:0]</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0000</td>
<td style="text-align:center">nop(相当于不使能)</td>
</tr>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">mult</td>
</tr>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">multu</td>
</tr>
<tr>
<td style="text-align:center">0011</td>
<td style="text-align:center">div</td>
</tr>
<tr>
<td style="text-align:center">0100</td>
<td style="text-align:center">divu</td>
</tr>
<tr>
<td style="text-align:center">0101</td>
<td style="text-align:center">mfhi</td>
</tr>
<tr>
<td style="text-align:center">0110</td>
<td style="text-align:center">mflo</td>
</tr>
<tr>
<td style="text-align:center">0111</td>
<td style="text-align:center">mthi</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">mtlo</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待操作数据的地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待写入的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">DMout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出的32位数据</td>
</tr>
</tbody>
</table>
</div>
<h5 id="BE"><a href="#BE" class="headerlink" title="BE"></a>BE</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM写入地址</td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位置一表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">原始待写入数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ByteEn[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">字节使能</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">处理后写入数据</td>
<td style="text-align:left">移动到相应的位置上，比如存入字节则8位以上全置位0</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DE"><a href="#DE" class="headerlink" title="DE"></a>DE</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM读出地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">待处理DM读出数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMOp[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM功能选择：000: word &lt;/br&gt; 001: halfword &lt;/br&gt; 010: byte &lt;/br&gt; 1xx: 无符号拓展load</td>
<td style="text-align:left">最高位1表示无符号位拓展</td>
</tr>
<tr>
<td style="text-align:center">RD_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">处理后DM读出数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h4><ul>
<li>每个流水线寄存器都保存着一条指令完成后续操作所需要的的全部信息。</li>
<li>对于每一个流水线的产生结果的级次，我需要用一个MUX来确定哪个是当前指令的用于转发的有效数据，PC+8， ALUout，DMout，所以我们增加outSel的选择信号，此选择信号可以代替RFWDSel的功能</li>
</ul>
<h5 id="D-IF-ID"><a href="#D-IF-ID" class="headerlink" title="D(IF/ID)"></a>D(IF/ID)</h5><ul>
<li>可以在D级内置Splitter</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">暂停时置位0</td>
</tr>
<tr>
<td style="text-align:center">F_instr[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级取出的指令</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">F_PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">F级输出的指令PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_opcode[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前D级的opcode</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_rs[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rs</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_rt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_rd[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rd</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_shamt[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">偏移量，位移指令使用</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_funct[5:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">funtion码</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_imm16[15:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">16位立即数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_address[25:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">26位地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">D_PC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D级当前指令地址</td>
</tr>
</tbody>
</table>
</div>
<h5 id="E-ID-EX"><a href="#E-ID-EX" class="headerlink" title="E(ID/EX)"></a>E(ID/EX)</h5><ul>
<li>从E级开始流水控制信号</li>
<li>T_new-1</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
<td style="text-align:left">暂停时置为1</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A1</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] D_shamt</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_S0imm32</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] D_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A1</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_shamt</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_S0imm32</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_E[3:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">BSel_E</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="M-EX-MEM"><a href="#M-EX-MEM" class="headerlink" title="M(EX/MEM)"></a>M(EX/MEM)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_V2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A2</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[4:0] E_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] E_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_E[2:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">DMWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_V2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A2</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_M[2:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">DMWE_M</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h5 id="W-MEM-WB"><a href="#W-MEM-WB" class="headerlink" title="W(MEM/WB)"></a>W(MEM/WB)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位</td>
</tr>
<tr>
<td style="text-align:center">en</td>
<td style="text-align:center">I</td>
<td style="text-align:left">使能信号</td>
</tr>
<tr>
<td style="text-align:center">[4:0] M_A3</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_ALUout</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_DR</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">[31:0] M_PC</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_M</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">outSel_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[4:0] W_A3</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_ALUout</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_DR</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">[31:0] W_PC</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_W</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">outSel_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h3 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h3><ul>
<li>此CPU采用集中译码的方式，在D级译码，控制信号进入流水，使用过的就不用进入了</li>
<li>T_new产生后随着流水线递减</li>
<li>分为MCU，HCU</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E8%A1%A8.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E8%A1%A8.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="控制信号表"></p>
<h4 id="主控制器（MCU）"><a href="#主控制器（MCU）" class="headerlink" title="主控制器（MCU）"></a>主控制器（MCU）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">opcode[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_opcode</td>
</tr>
<tr>
<td style="text-align:center">funct[5:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D_funct</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">NPCOp_D[2:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ALUOp_D[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DEXTOp_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMOp_D[2:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DMWE_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">imm26Sel_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">DA3Sel_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">BSel_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left">E_ALU_B信号选择：{}</td>
</tr>
<tr>
<td style="text-align:center">RFWDSel_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">outSel_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">有效转发数据Sel</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MDUOp_D[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">start_D</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令用到rs寄存器所剩下的时间</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">rt</td>
</tr>
<tr>
<td style="text-align:center">T_new_D[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">当前指令产生结果所需的时间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>MUX控制信号的具体含义可以看数据通路表</li>
</ul>
<h4 id="冒险控制器（HCU）"><a href="#冒险控制器（HCU）" class="headerlink" title="冒险控制器（HCU）"></a>冒险控制器（HCU）</h4><ul>
<li>空行表示逻辑与功能上的分割</li>
<li>我这里只需要D级输出T_use因为我只有stall需要用到T_use，而stall应只在D级就决定，转发只需判断Tnew==0</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号名</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D_A1[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">D_A2[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A1[4：0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">E_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A2[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">E_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">M_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">W_A3[4:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">RFWE_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Busy</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">MDUOp[3:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">start_E</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_rsUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center">T_rtUse[1:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">D级MCU输出T_use</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T_new_E[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_M[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">T_new_W[1:0]</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RFRD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">NPC读入RA的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD1的转发</td>
</tr>
<tr>
<td style="text-align:center">CMPD2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">D_RD2的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV1Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_A的转发</td>
</tr>
<tr>
<td style="text-align:center">ALUV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">ALU_B的转发</td>
</tr>
<tr>
<td style="text-align:center">DMV2Fwd[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM_WD的转发</td>
</tr>
<tr>
<td style="text-align:center">stall</td>
<td style="text-align:center">O</td>
<td style="text-align:left">暂停信号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Sel结尾代表常规MUX信号，Fwd结尾代表转发MUX信号</li>
<li>转发MUX的Sel的含义大致是数字越大优先级越高，优先级是E、M、W</li>
</ul>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><ul>
<li>写好对应的BE、DE</li>
</ul>
<h3 id="跳转分支指令"><a href="#跳转分支指令" class="headerlink" title="跳转分支指令"></a>跳转分支指令</h3><ul>
<li>要特别注意PC+8的转发问题，当检测到jal时转发</li>
<li>因为我是统一NPC模块，提供npc接口，所以NPC模块的pc输入得是F级的pc</li>
<li>所以要注意beq生效的时候接入的是下一条的pc，所以应该是<code>PC+Simm32</code>而不用+4。</li>
</ul>
<h3 id="乘除指令"><a href="#乘除指令" class="headerlink" title="乘除指令"></a>乘除指令</h3><ul>
<li>MDU的AB端口都接入F_ALUV1，F_ALUV2(与ALU一致)</li>
<li>传入MDUOp判断指令</li>
<li>实现方法是在cnt结束之前一直用64位的tmp寄存器保存结果</li>
<li>除cnt—，和BusyReg置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li>
</ul>
<h3 id="冒险处理"><a href="#冒险处理" class="headerlink" title="冒险处理"></a>冒险处理</h3><ul>
<li>先根据每一条指令，整理其Tuse，Tnew</li>
<li><p>整理出指令的时间表<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%8C%87%E4%BB%A4%E6%97%B6%E9%97%B4%E8%A1%A8.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%8C%87%E4%BB%A4%E6%97%B6%E9%97%B4%E8%A1%A8.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="指令时间表"></p>
</li>
<li><p>再根据每条指令的时间列出转发暂停控制信号表<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E5%86%B2%E7%AA%81%E6%8E%A7%E5%88%B6%E8%A1%A8.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E5%86%B2%E7%AA%81%E6%8E%A7%E5%88%B6%E8%A1%A8.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="冲突控制表"></p>
</li>
</ul>
<h4 id="转发策略"><a href="#转发策略" class="headerlink" title="转发策略"></a>转发策略</h4><ul>
<li>遵循暴力转发策略，在打好常规的数据通路表后，观察哪些端口需要用到寄存器值（需求者），再把所有的供给者的情况遍历出来</li>
<li>可以适当增加转发条件，如T_new = 0</li>
<li>AT法: 需求者是需要用这个值来运算的，找到所有与V，RD相关的端口；供给者是需要这个值来存入的，考虑它啥时候能够算出来。</li>
<li>我们把RFWE放入HCU用以保证写使能信号有效（有效数据）</li>
<li>判断A3!=0</li>
<li>转发要素：<ul>
<li>(A1(2) = A3)?</li>
<li>$T_{new} = 0 $ ?</li>
<li>RFWE = 1 ?</li>
<li>A3 != 0 ?</li>
</ul>
</li>
<li>转发机制：结果出来后都转发，只需改变控制信号。</li>
<li>代码如下：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> CMPD1Fwd = ((D_A1 == E_A3) &amp; (T_new_E == <span class="number">0</span>) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>)? `Eout :</span><br><span class="line">                  ((D_A1 == M_A3) &amp; (T_new_M == <span class="number">0</span>) &amp; RFWE_M &amp; M_A3!=<span class="number">0</span>)? `Mout :</span><br><span class="line">                  ((D_A1 == W_A3) &amp; (T_new_W == <span class="number">0</span>) &amp; RFWE_W &amp; W_A3!=<span class="number">0</span>)? `Wout :</span><br><span class="line">                  `origin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> CMPD2Fwd = ((D_A2 == E_A3) &amp; (T_new_E == <span class="number">0</span>) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>)? `Eout :</span><br><span class="line">                  ((D_A2 == M_A3) &amp; (T_new_M == <span class="number">0</span>) &amp; RFWE_M &amp; M_A3!=<span class="number">0</span>)? `Mout :</span><br><span class="line">                  ((D_A2 == W_A3) &amp; (T_new_W == <span class="number">0</span>) &amp; RFWE_W &amp; W_A3!=<span class="number">0</span>)? `Wout :</span><br><span class="line">                  `origin;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="暂停策略"><a href="#暂停策略" class="headerlink" title="暂停策略"></a>暂停策略</h4><ul>
<li>注意对于不要用的rt，rs要把T_use置位2（防止在i型指令的时候多暂停）</li>
<li>所以常规寄存器的暂停要素： <ul>
<li>$T_{use} &lt; T_{new}$ 这在图表上对应了四种暂停情况，咱们枚举出来</li>
<li>A1(2) = A3 ?</li>
<li>RFWE = 1 ?</li>
<li>A3 != 0 ?</li>
</ul>
</li>
<li>代码如下：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> stall_rs0_E1 = (T_rsUse == <span class="number">0</span>) &amp; (T_new_E == <span class="number">2&#x27;b01</span>) &amp; (D_A1 == E_A3) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs0_E2 = (T_rsUse == <span class="number">0</span>) &amp; (T_new_E == <span class="number">2&#x27;b10</span>) &amp; (D_A1 == E_A3) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs0_M1 = (T_rsUse == <span class="number">0</span>) &amp; (T_new_M == <span class="number">2&#x27;b01</span>) &amp; (D_A1 == M_A3) &amp; RFWE_M &amp; M_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs1_E2 = (T_rsUse == <span class="number">1</span>) &amp; (T_new_E == <span class="number">2&#x27;b10</span>) &amp; (D_A1 == E_A3) &amp; RFWE_E &amp; E_A3!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span> stall_rs = stall_rs0_E1 | stall_rs0_E2 | stall_rs0_M1 | stall_rs1_E2;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于乘除指令：<ul>
<li>将Busy，start_E，MDUOp_D传入HCU</li>
<li>然后md暂停信号为<code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li>
</ul>
</li>
<li>暂停的机制：暂停D级，清空E级，暂停IF</li>
</ul>
<h2 id="测试数据及自动化测试"><a href="#测试数据及自动化测试" class="headerlink" title="测试数据及自动化测试"></a>测试数据及自动化测试</h2><h3 id="常规测试"><a href="#常规测试" class="headerlink" title="常规测试"></a>常规测试</h3><ul>
<li>基础指令的测试同p4</li>
</ul>
<h3 id="冒险测试"><a href="#冒险测试" class="headerlink" title="冒险测试"></a>冒险测试</h3><ul>
<li>对于冲突进行覆盖性分析，需要我们根据冲突表，45种情况每一种都设计相应的冒险测试数据（建立在基础测试通过的情况下）</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p>
<ul>
<li>乘除法都有较高的延迟，若整合进ALU，则进行乘除法的时候，所有的运算类指令都只能阻塞在D级，造成了极大的性能损失。单独设置MDU的话，无关的指令还能正常的在ALU运行，效率较高。</li>
<li>HI，LO寄存器并不是通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于GRF中，内置在MDU中即可。</li>
</ul>
<p>2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p>
<ul>
<li>真实的流水线CPU采用的乘法是有加法器和移位器循环，具体实现过程为：<blockquote>
<p>首先CPU会初始化三个通用寄存器用来存放被乘数，乘数，部分积。<br>部分积寄存器初始化为0。<br>判断乘数寄存器的低位是0|1，如果为0则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。<br>在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。<br>同时部分积寄存器高位补0。如果为1则将部分积寄存器加上被乘数寄存器，再进行移位操作。<br>当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。</p>
</blockquote>
</li>
<li>还有另一种乘法的方式：<blockquote>
<p>只需两个寄存器，A[31:0],B[63:0]，A初始化为被乘数，B初始化为乘数。<br>每一次取B的最低位，为1则将A[31:0]+B[63:32] -&gt; B[63:32]，为0则不操作。<br>每次将B &gt;&gt; 1，然后高位补0。</p>
</blockquote>
</li>
<li>除法实现：<blockquote>
<p>与乘法的操作基本相反，首先CPU会初始化三个寄存器,用来存放被除数，除数，部分商。余数(被除数与除数比较的结果)放到被除数的有效高位上。CPU做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先CPU会把被除数bit位与除数bit位对齐，然后再让对齐的被除数与除数比较(双符号位判断)。比如01-10=11(前面的1是符号位) 1-2=-1 计算机通过符号位和后一位的bit位来判断大于和小于，那么01-10=11 就说明01小于10，如果得数为01就代表大于，如果得数为00代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位(上商就是将商的最低位左移1位腾出商寄存器最低位上新的商)如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。</p>
</blockquote>
</li>
</ul>
<p>3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p>
<ul>
<li>除cnt—，和BusyReg置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li>
<li>对于乘除指令：<ul>
<li>将Busy，start_E，MDUOp_D传入HCU</li>
<li>然后md暂停信号为<code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li>
</ul>
</li>
</ul>
<p>4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p>
<ul>
<li>对于需要写入的位置更加的直观，相当于将DMWE、DMOP写入的A[1:0]用四位字节使能信号表示，十分的统一。</li>
</ul>
<p>5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p>
<ul>
<li>按字节读写的时候，我们获得的是一字节，但是我们如果要lw或lh的话我们就需要拼接。如果是sw或sh的话我们需要多次存入。</li>
<li>若用lb，sb，lh，sh这种非取字的读写时，按字节读可以省去，取位，拼接的步骤，效率要优于按字读写。</li>
</ul>
<p>6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p>
<ul>
<li>NPC统一，NPC统一模块，具体可见<a href="#跳转分支指令">跳转分支指令实现</a></li>
<li>指令分类，MCU指令括号分类防止译码指令过长<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/MCU%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/MCU%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MCU指令分类"></li>
<li>每一级设置outMUX，只需在MCU中控制outSel即可决定转发值及写入寄存器的值</li>
<li>多用注释来对代码段进行分割，代码对齐（保持好的代码风格）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%B3%A8%E9%87%8A%E5%88%86%E5%89%B2.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p6/%E6%B3%A8%E9%87%8A%E5%88%86%E5%89%B2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="注释分割"></li>
</ul>
<p>7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p>
<ul>
<li>实现过程见<a href="#冒险处理">实现方法-冒险处理</a></li>
<li>在常规测试通过后，我们可以将T_rsUse和T_rtUse相同的指令归类为同一需求指令，把T_new相同的指令归类为同一供给指令。<ul>
<li>所以可以在new方面有下列指令：add，lw，jal，mfhi</li>
<li>在rsUse方面有下面情况：add，sll，lw，beq，jr，mult，mthi</li>
</ul>
</li>
<li>然后对着转发的时间表，设计测试数据：</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rs0_E1</span></span><br><span class="line"><span class="keyword">add </span>  $<span class="built_in">t0</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span></span><br><span class="line"><span class="keyword">beq </span>  $<span class="built_in">t0</span>, $<span class="built_in">t3</span>, label1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment"># rs0_E2</span></span><br><span class="line"><span class="keyword">lw </span>   $<span class="built_in">t0</span>, <span class="number">0</span>($<span class="built_in">t1</span>)</span><br><span class="line"><span class="keyword">beq </span>  $<span class="built_in">t0</span>, $<span class="built_in">t3</span>, label1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">#rs0_E0</span></span><br><span class="line"><span class="keyword">jal </span>  label1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">ori </span>  $<span class="built_in">t0</span>, $<span class="number">0</span>, <span class="number">0x1234</span></span><br><span class="line"><span class="symbol">label1:</span> <span class="keyword">jr </span>$<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>....</span><br></pre></td></tr></table></figure>
<p>8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</p>
<ul>
<li>手动构造策略见上</li>
<li>完全随机生成有几大不足之处，如无法保证内存对齐，无法保证延迟槽中没有跳转分支，无法避免一定几率的死循环等等</li>
<li>但可以加入策略：<ul>
<li>比如只用t0-t6寄存器以保证产生足够多的冲突</li>
<li>在检测到生成跳转后禁用跳转指令</li>
<li>检测到内存不对齐可以不生成等等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P6</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-CO】p7流水线CPU-Ultra</title>
    <url>/2022/12/03/BUAA-CO-p7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU-Ultra/</url>
    <content><![CDATA[<p>BUAA-CO课程p7，将之前完成的CPU封装，完成一个MIPS的微系统，能够实现异常与中断。</p>
<span id="more"></span>
<h1 id="p7-log"><a href="#p7-log" class="headerlink" title="p7_log"></a>p7_log</h1><blockquote>
<p>p7需要我们把p6设计的流水线CPU封装，并连接上一系列的外设，完成一个MIPS的微系统，能够实现异常和中断<br>所以我们要实现以下工作：<br>p6流水线的设计见p6文档，在这我们，把CPU留下接口后可以忽略他的内部的实现细节。<br>实现CP0协寄存器，异常和中断<br>实现系统桥，连接DM，Timer等外设</p>
</blockquote>
<h2 id="设计思路-纲领"><a href="#设计思路-纲领" class="headerlink" title="设计思路-纲领"></a>设计思路-纲领</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>实现计时器</li>
<li>实现系统桥</li>
<li>实现CP0</li>
<li>改进CPU的内部结构，使其拥有检测内部异常，响应外部中断，实现异常指令</li>
<li>通过Mars编写异常处理程序</li>
<li>测试</li>
</ul>
<h3 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h3><ul>
<li>对于指令的分类很重要</li>
<li>下面是所需要是实现的指令类和指令</li>
<li>寄存器寄存器计算：add, sub, and, or, slt, sltu,  xor</li>
<li>寄存器立即数计算：addi, andi, ori, slti, xori</li>
<li>位移类： sll, srl, sra, sllv, srlv, srav</li>
<li>B类：beq, bne</li>
<li>store：sw, sh, sb</li>
<li><p>load：lw, lh, lhu, lb, lbu</p>
</li>
<li><p>跳转并链接：jal, jalr, j</p>
</li>
<li>跳转寄存器：jr, jalr</li>
<li>加载高位：lui</li>
<li>空指令：nop</li>
<li>读乘除法寄存器：mfhi, mflo</li>
<li><p>写乘除法寄存器：mult, multu, div, divu, mthi, mtlo</p>
</li>
<li><p>p5要求实现的基础指令有：add, sub, ori, lw, sw, beq, lui, jal, jr, nop</p>
</li>
<li>p7在p6的基础上新增的指令：mfc0, mtc0, eret, syscall</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>在控制信号连线名末尾加上_阶段字母，如：NPCOp_D，用以区分所属阶段</li>
<li>在寄存器输出信号前加上阶段字母_, 如：D_A1,用以区分所属阶段</li>
<li>功能部件输出信号前加上功能部件.，（实际打码时舍弃）</li>
<li>MUX命名采取X_输入端口名_选择数</li>
<li>转发MUX命名采用F_输入端口名_选择数，级数越大优先级越高</li>
<li>内部异常信号，用EXC_异常类型_阶段</li>
<li>接口名清晰易懂</li>
</ul>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="Timer1-Timer2"><a href="#Timer1-Timer2" class="headerlink" title="Timer1/Timer2"></a>Timer1/Timer2</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">addr[31:2]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer写入地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer写使能</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Din[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer写入数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Dout[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">Timer读取的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">IRQ</td>
<td style="text-align:center">O</td>
<td style="text-align:left">interupte require</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A_cpu[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">读取or写入外设的地址</td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">WD_cpu[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写入外设的数据</td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">ByteEn[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">写外设的字节使能</td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">DM_RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">DM读取值</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">T0_RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">T0读取值</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">T1_RD_in[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">T1读取值</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">A_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">WD_out[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left"></td>
<td style="text-align:left">cpu输出</td>
</tr>
<tr>
<td style="text-align:center">RD_in[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">外设读入至CPU</td>
<td style="text-align:left">外设读入</td>
</tr>
<tr>
<td style="text-align:center">DMWE[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM写使能</td>
<td style="text-align:left">由byteen与地址决定</td>
</tr>
<tr>
<td style="text-align:center">T0WE</td>
<td style="text-align:center">O</td>
<td style="text-align:left">T0写使能</td>
<td style="text-align:left">同上</td>
</tr>
<tr>
<td style="text-align:center">T1WE</td>
<td style="text-align:center">O</td>
<td style="text-align:left">T1写使能</td>
<td style="text-align:left">同上</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CP0协寄存器"><a href="#CP0协寄存器" class="headerlink" title="CP0协寄存器"></a>CP0协寄存器</h3><ul>
<li>内置在CPU M级中，用于获取外部中断和内部异常的信息，并发送异常/中断请求。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">addr_R[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mfc0读CP0的编号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">CPWE</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mtc0写使能</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">addr_W[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mtc0写CP0的编号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">mtc0写CP0的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">M_PC[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">中断异常产生时的M_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ExcCode[4:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">产生中断异常的类型</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">BD_M</td>
<td style="text-align:center">I</td>
<td style="text-align:left">branch delay分支延迟槽</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">HWInt[7:2]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">六个设备的中断标志</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">EXL_clr</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Eret_M用于将SR的EXL置零</td>
<td style="text-align:left">表示退出中断异常</td>
</tr>
<tr>
<td style="text-align:center">EIrequire</td>
<td style="text-align:center">O</td>
<td style="text-align:left">异常/中断请求</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">EPC[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">输出EPC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">RD[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">mfc0读CP0的数据</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">IO</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">I</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">reset</td>
<td style="text-align:center">I</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">i_inst_rdata[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">从IM读取的指令</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_rdata[31:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left">从DM读取的数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Int_put</td>
<td style="text-align:center">I</td>
<td style="text-align:left">外部中断的信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Int_T0</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer0输入的中断信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Int_T1</td>
<td style="text-align:center">I</td>
<td style="text-align:left">Timer1输入的中断信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">i_inst_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">F_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_inst_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">M_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM的读取or写入地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_wdata[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DMWD</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">m_data_byteen[3:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">DM的字节使能信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_inst_addr[31:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">W_PC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_grf_we</td>
<td style="text-align:center">O</td>
<td style="text-align:left">RFWE_W</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_grf_addr[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">W_A3</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">w_grf_wdata[4:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:left">RFWD/Wout</td>
</tr>
</tbody>
</table>
</div>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="内部异常"><a href="#内部异常" class="headerlink" title="内部异常"></a>内部异常</h3><ul>
<li>每一级的异常进流水，已有异常的话按原异常流水（优先级）</li>
<li>在ExcCode_fixE的时候给overflow+上RFWE的判别</li>
<li>响应异常时需要做下面几件事：<ul>
<li>清空：EMW寄存器响应Req，清空寄存器(注意处理PC，同stall情况)</li>
</ul>
</li>
</ul>
<h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><ul>
<li>外部中断的优先级大于内部异常</li>
</ul>
<h3 id="Mars异常程序"><a href="#Mars异常程序" class="headerlink" title="Mars异常程序"></a>Mars异常程序</h3><ul>
<li><code>.ktext 4180</code>将异常处理程序写在4180处</li>
<li>注意处理中断时需要<code>sb $27,0x7f20($0)</code>响应异常</li>
</ul>
<h2 id="测试数据及自动化测试"><a href="#测试数据及自动化测试" class="headerlink" title="测试数据及自动化测试"></a>测试数据及自动化测试</h2><ul>
<li>测试要将各种异常覆盖到</li>
<li>同时注意尽可能多的中断情况</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><ul>
<li>自动化测试上我实现了机器码的生成（不足1120行补零）</li>
<li>实现了格式的统一，去掉时间输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">command = <span class="string">&quot;java -jar Mars.jar db nc mc CompactDataAtZero a dump .text HexText testcode/testcode.txt testcode/test.asm&quot;</span></span><br><span class="line">os.system(command=command)</span><br><span class="line">command = <span class="string">&quot;java -jar Mars.jar db nc mc CompactDataAtZero a dump 0x4180-0x6ffc HexText testcode/handlerCode.txt testcode/test.asm&quot;</span></span><br><span class="line">os.system(command=command)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&quot;testcode/testcode.txt&quot;</span>) <span class="keyword">as</span> testcode:</span><br><span class="line">    test = testcode.read()</span><br><span class="line">    line = test.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&quot;testcode/handlerCode.txt&quot;</span>) <span class="keyword">as</span> handlerCode:</span><br><span class="line">    handler = handlerCode.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&quot;testcode/code.txt&quot;</span>, mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> code:</span><br><span class="line">    code.write(test)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1120</span>-line):</span><br><span class="line">        code.write(<span class="string">&quot;00000000\n&quot;</span>)</span><br><span class="line">    code.write(handler)</span><br></pre></td></tr></table></figure>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p>
<ul>
<li>鼠标和键盘产生中断信号，进入中断处理程序，在中断处理程序中，鼠标和键盘输入信号</li>
</ul>
<p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p>
<ul>
<li>若自定义入口地址，则很多软件将会不兼容，在程序员视角设计软件的时候，中断处理的入口地址是不重要的，也就是说这是软件和硬件之间的协议。</li>
</ul>
<p>3、为何与外设通信需要 Bridge？</p>
<ul>
<li>外设的种类是繁多，我们通过bridge并且约定某段内存地址对应于某个外设，这样我们就只需要通过访存去实现与外设的联系，指令集会比较的简洁。添加外设时，外设也只需要体现在入口地址的不同而不需要改变CPU的内部结构，让CPU访问外设只需通过地址，这样也是体现了”高内聚，低耦合”的原则。</li>
</ul>
<p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p>
<ul>
<li>两种中断，模式0为定时中断，模式1为周期性中断。区别在于倒计时达到0之后的状态。</li>
<li><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p7/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-CO/p7/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="状态转移"></li>
</ul>
<p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p>
<ul>
<li>写入EPC会出错，延迟槽标记信号也会出错。</li>
<li>如果是中断或者异常而清空流水线，应该保持原有的PC值，以保证宏观PC的正确。</li>
<li>如果是阻塞而清空流水线，应该要保持原有的PC并且保持原有的BD标志信号。</li>
</ul>
<p>6、为什么 jalr 指令为什么不能写成 jalr $31, $31？</p>
<ul>
<li>这种操作具有二义性，不知道先跳转还是先链接</li>
<li>指令集要求。寄存器说明符 rs 和 rd 不得相等，因为此类指令在重新执行时不具有相同的效果。执行此类指令的结果是不可预测的。此限制允许异常处理程序在分支延迟槽中发生异常时通过重新执行分支来恢复执行。</li>
</ul>
]]></content>
      <categories>
        <category>BUAA计算机组成原理</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>CO</tag>
        <tag>大二</tag>
        <tag>计组</tag>
        <tag>MIPS</tag>
        <tag>P7</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】ElevatorDispatcher1.0</title>
    <url>/2023/04/02/BUAA-OO-ElevatorDispatcher-1-0/</url>
    <content><![CDATA[<p>北航面向对象与程序设计第二单元课程作业，电梯调度器ElevatorDispatcher 1.0。<br>主要涉及多线程程序设计，设计模式的使用。</p>
<span id="more"></span>
<h1 id="hw5-log"><a href="#hw5-log" class="headerlink" title="hw5_log"></a>hw5_log</h1><h2 id="前置知识-多线程"><a href="#前置知识-多线程" class="headerlink" title="前置知识-多线程"></a>前置知识-多线程</h2><ul>
<li>IDEA多线程调试，试过，感觉报用，感觉还是<strong>print输出</strong>的方法最能模拟这个多线程的<strong>运行时的状态</strong>。<ul>
<li>其实如果可以，去实现一个<strong>debug模式</strong>，输入一个标志进入debug模式（还可以有不同的debug模式），运行时输出自己想要的信息。（要不然还得自己一行一行的注释，累死，而且容易出问题，忘删了交上去浪费一次机会！</li>
</ul>
</li>
<li><code>t1.yield()</code>, <code>t1.sleep()</code>, <code>t2.join()</code>, <code>o.wait()</code>, <code>o.notifiy()</code>都是调度策略，<strong>不要轮询</strong></li>
<li>如果共享对象不发出调度指令，我们需要线程互斥控制，<code>synchronized</code>关键字，每一个同步控制块都有一把锁，拿到锁的线程才能进控制块。<ul>
<li>对于这里，如果刚刚学多线程，会有点迷惑，这个块有什么用，我觉得可以带着这个疑问看下去，理会区分<strong>类和线程之间的差别</strong>。</li>
<li>static于非static的区别，<strong>锁对象和锁类</strong>的区别。</li>
<li>方法级的同步控制与obj的局部代码的同步块，其实是一样的，只是说把synchronized块放到方法上的话，<strong>同步块就是一整个方法</strong>。</li>
</ul>
</li>
<li>直接调用run与线程调度执行run的区别，阅读Thread类的源码与Runable的源码，发现Runable十分简单粗暴的留了个run的方法，所以区别在于，直接调用run方法其实只相当于<strong>执行了一个函数</strong>，并没有创建一个线程，<strong>创建线程需要Thread类的start方法</strong>。所以一般不要去直接调用run方法。</li>
<li>生产者模式，观察者模式，这是两种比较典型的多线程设计模式，这个可以后面说。<ul>
<li>我们的电梯其实是一种很明显的生产消费的模式，输入线程是需求的生产者，电梯是需求的消费者，是一种一对多的服务，当然没那么简单，这个后面再说。</li>
</ul>
</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>需要实现一个电梯调度的系统（电梯的属性固定），尽可能快的完成乘客的请求</li>
<li>电梯可以有可以捎带策略，基准是ALS调度策略<ul>
<li>但是我选择大家的选择LOOK策略，因为我觉得这个方法更加<strong>能够灵活应对增加的请求</strong>，同时用户等待时间也会比较短。</li>
</ul>
</li>
<li><p>队列和楼层之间的关系是否需要更便捷的管理？</p>
<ul>
<li>我选择<strong>分楼层管理请求队列</strong>，方便查询。</li>
</ul>
</li>
<li><p>注意可能上了就下的极端情况（后续迭代，但是好像没有，预测失败。。。</p>
</li>
</ul>
<h2 id="可能用到的设计模式"><a href="#可能用到的设计模式" class="headerlink" title="可能用到的设计模式"></a>可能用到的设计模式</h2><ul>
<li><strong>生产者消费者模式</strong>：输入类作为生产者，任务表作为托盘，电梯作为消费者（其实并不是</li>
<li>观察者模式：（后续迭代可能会有，比如说乘客突然改变想法，但是也没有，再次预测失败呜呜呜</li>
<li>工厂模式：考虑到后续自定义电梯的实现</li>
<li>状态模式：电梯可以有好几种状态，上行下行，开门关门，满员，（故障，预测成功！！！</li>
<li><strong>策略模式</strong>：主要考虑到，电梯策略的选择，与分派器策略的选择</li>
<li>单例模式</li>
<li>责任链模式</li>
<li>master-worker模式</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li><p>生产消费模型：</p>
<ul>
<li>实现输入接口</li>
<li>建立请求表类<ul>
<li>建立请求类（即passenger）</li>
</ul>
</li>
<li>建立调度器类（这个不是必须的，但是后续迭代中逐渐变得必须了起来</li>
<li>建立电梯的类</li>
<li>实现输出接口</li>
</ul>
</li>
<li><p>设置策略类</p>
<ul>
<li>电梯策略</li>
<li>调度器策略</li>
</ul>
</li>
<li><p>为了统一代码的风格，提高效率，我这里提前对代码进行几点规定：</p>
<ul>
<li>设锁的房内只提供对共享资源读写的能力，其余不设锁</li>
<li>只在取不到需求的时候wait，而且是<strong>在需求表的方法中wait</strong>，所以在Dispatcher与Elevator的类中不需要wait，让共享对象自己来做好自己的管理</li>
<li>只在需求表这一个共享对象中设锁（其实电梯也是共享对象，但综合考虑下来，不设锁的效率更优。</li>
</ul>
</li>
<li><p>在类的设置上，我遵循开闭原则，面向于接口编程，而不是面向于实现，这样能够让我轻松的迭代，所以我采取Strategy、Evaluation两个接口实现（采取<strong>策略模式</strong>，同时又方便我随时转换调度器评价方式与电梯运行策略</p>
<ul>
<li>第一次作业就先不利用Elevator接口了，后面有横向电梯再用（但是没有，呜呜呜。。。</li>
</ul>
</li>
<li><p>上面是任务清单，可能比较的模糊，可以看下面的架构~</p>
</li>
</ul>
<h3 id="整体架构与uml“类”类图"><a href="#整体架构与uml“类”类图" class="headerlink" title="整体架构与uml“类”类图"></a>整体架构与uml“类”类图</h3><ul>
<li>在总体上，我实现了以<strong>生产者消费者模型为主体的架构</strong>，架构示意图大体如下（仅表意，不是严格的类图）：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher1.0/%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher1.0/%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="架构示意图"></li>
</ul>
<h4 id="整体架构模式"><a href="#整体架构模式" class="headerlink" title="整体架构模式"></a>整体架构模式</h4><ul>
<li>我们可以看到，输入线程和dispatch线程共享一个Request的对象（我们后续称之为<strong>总表</strong>），这是一个生产消费的模型。而且dispatch线程又分别和每一个电梯的运行线程共享一个Request的对象（称为<strong>分表</strong>），这也分别是生产消费的模型。<strong>dispatch线程既是总表的消费者，又是分表的生产者</strong>。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher1.0/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher1.0/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="生产消费模型"></li>
<li>然后我们可以看到，在课上有同学提到的<strong>master-worker模型</strong>，在这里也有体现，我们可以看到，dispatcher<strong>统一管理</strong>所有的电梯，它是master将任务分派给不同的worker，像是一个分布式的计算集群（当然我们这里是服务处理集群）。</li>
<li>但这里需要重点辨析的一点是，在这里<strong>电梯对象存在线程不安全的问题</strong>，是一个由check-then-act引起的<strong>读取不到最新结果</strong>的问题，因为dispather需要对每部电梯的运行状态进行评估分派，所以需要读电梯的数据，但与此同时，电梯的数据是在改变的，所以线程不安全。也就是说，这里电梯这个类的对象，是电梯线程和dispatch线程的共享对象！！！<ul>
<li>说到这就不得不提一嘴<strong>线程和类之间的关系</strong>了，这一点助教在课上有提过一下，我的理解是线程并不属于类，类里面的<strong>run方法只是一个线程的入口</strong>，像main也是一个入口而已。所以类可以被自己创造的线程访问，在我们这，电梯是一个共享对象，它被dispatch行为的线程和elevate行为的线程给共享访问了。</li>
<li>我怎么解决这个问题呢，嘿嘿，我第一作业没有解决这个问题（摆手，因为我觉得给电梯加锁的行为不太可取，它会显式的阻塞电梯线程的运行，会拖慢我的速度，而且我也是第二次作业才发现这个问题）<ul>
<li>剧透一点，在第二次迭代的博客里，我会重点介绍一些<del>歪门邪道</del>，能够解决这个问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>再剧透一点，这其实很适用于第二次的迭代，因为电梯要maintain把请求放回去，其实也就是电梯线程也变成了总表的生产者（图中标为new的曲线），这又增加了一层生产消费的模型。</p>
</blockquote>
<h4 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h4><ul>
<li>我们直观上来看，有两个地方需要用到策略：<strong>分派策略</strong>，<strong>运行策略</strong>。</li>
<li>所以我们可以使用策略模式，策略模式中，需要用到策略的对象拥有一个策略的属性，这个属性是一个<strong>策略的接口</strong>，然后具体的策略我们只需要用一个策略类去实现这样一个接口，而且我们注意到，这个接口甚至只需要一个方法，就是<code>getStrategy(...)</code>。后续需要<strong>变更方法或者增量开发</strong>的时候只需要将<strong>接口的实现切换</strong>就行。</li>
<li>与之对比的是，用不同具体方法的分派器的类去继承分派器的类，读者可以自行体会一下这两者之间的差异，体会一下<strong>面向接口</strong>编程的优点。</li>
<li>如下图，在我们这次作业中电梯可以有运行策略，分派器可以有分派策略：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher1.0/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher1.0/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="策略模式"></li>
</ul>
<blockquote>
<p>所以你甚至可以设想给<strong>不同的电梯装载不同的策略</strong>，然后调度的时候结合不同的策略的特点来调度。或者说在不同的情况下，应用分派器相应的不同的分派策略。十分的灵活十分的好玩，而且迭代加功能的时候，面向接口有不同的实现就行了。（但是我没有实现，懒orz）</p>
</blockquote>
<h3 id="电梯运行策略的选择——LOOK"><a href="#电梯运行策略的选择——LOOK" class="headerlink" title="电梯运行策略的选择——LOOK"></a>电梯运行策略的选择——LOOK</h3><ul>
<li>这里主要用的是LOOK的策略<ul>
<li>LOOK需要考虑前面的请求也是和运行同一方向的</li>
<li>但其实其他同学（包括往届学长的博客里对LOOK的策略解读的比较的全面了，所以我就不对具体策略进行解读了，下面是伪代码的实现（我觉得这样可能更加直观，<strong>每走一步获取一下strategy</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LookStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Status <span class="title function_">getStrategy</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        <span class="comment">//判断电梯是否需要开门</span></span><br><span class="line">        <span class="keyword">if</span> (canOpenForIn() || canOpenForOut())</span><br><span class="line">            <span class="keyword">return</span> OPEN;</span><br><span class="line">        <span class="comment">//判断电梯是否有人·</span></span><br><span class="line">        <span class="keyword">if</span> (!elevator.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> MOVE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//请求队列中是否有人</span></span><br><span class="line">            <span class="keyword">if</span> (!passengerQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//人在原方向还是反方向</span></span><br><span class="line">                <span class="keyword">if</span> (pasInSameDir())</span><br><span class="line">                    <span class="keyword">return</span> MOVE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> REVERSE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//请求队列输入是否结束</span></span><br><span class="line">                <span class="keyword">if</span> (passengerQueue.isEnd())</span><br><span class="line">                    <span class="keyword">return</span> END;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> WAIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对满员状态的处理：应该不停，不要浪费时间</li>
<li>用ArrayList&lt; ArrayList&lt; Passenger &gt; &gt;来将<strong>所有楼层一样</strong>的乘客放到一起，在RequestTable中把同一<strong>fromFloor</strong>的乘客放在一起，在Elevator中，把<strong>toFloor</strong>一样的乘客放在一起。他们是同一类人，<strong>方便索引</strong>。</li>
</ul>
<h3 id="调度器的实现"><a href="#调度器的实现" class="headerlink" title="调度器的实现"></a>调度器的实现</h3><ul>
<li>我应该设置一个对<strong>全局展开调度</strong>的东西，毕竟我们是六个电梯共享相同的需求，为了<strong>用电量的考虑</strong>，我每个请求只能让一个电梯去动！<ul>
<li>感觉自由竞争调度<strong>不太妥当</strong>，会使其浪费电量，最后发现自由竞争其实可以拿到90+的分数，但是不会太高。</li>
<li>所以我的策略是，在电梯和需求表之间插上一个<strong>Dispatcher</strong>，Dispatcher将一张大的需求表分成<strong>小部分分派</strong>给各个电梯，各个电梯之间独立运行（不知道其他电梯是个什么状态），</li>
<li>调度器分配出去就不能反悔了（所以<strong>可以在总表中删除了，如果可以反悔，那不就是自由竞争嘛</strong>！）</li>
</ul>
</li>
<li>初步调度策略是<strong>最近的一个</strong>，如果反向就加上距离<ul>
<li>但是有弊端，就是全都同一时间输入，更有甚者都在同一个楼层向上走，那会乱<ul>
<li>所以解决方法，必需加入<strong>对于人数的考虑</strong>，人满了就不接了，或者说哪个人少让哪个去</li>
</ul>
</li>
<li>然后还可以考虑<strong>等待队列的长度</strong>，等的人越多就分数低</li>
<li>所以综合考虑下来，形成了我的DistanceEva的评价接口的实现。</li>
<li>下面细说：</li>
</ul>
</li>
</ul>
<h4 id="调度策略的选择——DistanceEva-自创偷懒评价"><a href="#调度策略的选择——DistanceEva-自创偷懒评价" class="headerlink" title="调度策略的选择——DistanceEva(自创偷懒评价)"></a>调度策略的选择——DistanceEva(自创偷懒评价)</h4><ul>
<li>与其说是一种Distance评价法，其实不如说是一种<strong>综合评价法</strong>，因为我后续加入了许许多多的指标，在调参之后，能够达到接近影子电梯（这个第二次博客有谈到）的水平。</li>
<li>我假设电梯是一个<strong>最高层（或者最底层）到它现在要到的最底层（或者最高层）的一个来回工作的圈</strong>，计算还要走多少楼，电梯才能接到这个乘客<ul>
<li>比如，我在7楼要下行，但是这个电梯现在在6楼下行到2楼，那它现在就需要先到2楼，再上行到11楼，再下行到7楼，才能接到我。算出来Distance是4+9+4=17。</li>
</ul>
</li>
<li>然后考虑到<strong>几个会影响电梯的评分的指标</strong>，经过调参之后，最后评价方式变成了这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) (<span class="number">22</span> - distance - elevator.getPassengerQueue().getPassengerNum() * <span class="number">2.2</span> - elevator.getPassengerNum() * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="强扭的瓜不甜，你可以找到更好的-调度的考虑"><a href="#强扭的瓜不甜，你可以找到更好的-调度的考虑" class="headerlink" title="强扭的瓜不甜，你可以找到更好的(调度的考虑)"></a>强扭的瓜不甜，你可以找到更好的(调度的考虑)</h4><ul>
<li>但是回到了最开始的一个的问题，如果一下子输入许许多多的请求，dispatcher就把它们全都分配出去了！然后发现随着电梯的运行，有些电梯装不下了，有的乘客可能一开始<strong>遇上的不是对的电梯</strong>。<ul>
<li>所以，强扭的瓜不甜。如果每个电梯的评价<strong>都不是很高</strong>，那我们就<strong>先不分配</strong>，让它<strong>留在总表里</strong>，等待分配的时机。</li>
<li>然后，递归下去<strong>查另一个人的情况</strong>。</li>
</ul>
</li>
<li>所以我们必须知道分配有没有成功，如果一个人都没分配出去，说明现在<strong>所有电梯都不适合增加任何一个请求</strong>。<ul>
<li>所以dispatch的方法需要带上返回值！</li>
<li>然后如果<strong>返回false，需要阻塞，避免轮询</strong>。<ul>
<li>可以通过wait电梯的同步块的请求，但是我没有给电梯设同步块。</li>
<li>所以我是<strong>简单的sleep</strong>，我发现sleep(50)的时候，效果最好。</li>
</ul>
</li>
</ul>
</li>
<li>下面是dispatch递归分配结构的<strong>伪代码实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">dispatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> requestTable.getAndRemovePas();</span><br><span class="line">    <span class="keyword">if</span> (passenger == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    bestEle = getBestEle(passenger);</span><br><span class="line">    <span class="comment">//没有合适的就返回null,继续递归寻找下一个，return后再把现在那个给加回去</span></span><br><span class="line">    <span class="keyword">if</span> (bestEle == <span class="literal">null</span>) &#123;</span><br><span class="line">        isDisped = dispatch();</span><br><span class="line">        requestTable.add(passenger);</span><br><span class="line">        <span class="keyword">return</span> isDised;</span><br><span class="line">    &#125;</span><br><span class="line">    bestElePasQueue.add(passenger);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="最后最需要注意的——结束条件"><a href="#最后最需要注意的——结束条件" class="headerlink" title="最后最需要注意的——结束条件"></a>最后最需要注意的——结束条件</h3><ul>
<li>第一次作业的结束条件还比较的简单，但后续几次迭代的时候，如果发现<strong>电梯死锁了</strong>，电梯<strong>有请求没有处理</strong>，分派器<strong>有请求没有分配出去</strong>等等问题，那就要好好思考一下是不是<strong>提早结束了，或者还没结束</strong>。</li>
<li>给请求队列加上passengerNum的属性，这样判断empty就不需要遍历了。</li>
</ul>
<h2 id="一些未实现的优化思路"><a href="#一些未实现的优化思路" class="headerlink" title="一些未实现的优化思路"></a>一些未实现的优化思路</h2><ul>
<li><strong>单例模式</strong>实现一些东西（规范！</li>
<li>用<strong>读写锁</strong>灵活实现互斥与同步控制</li>
<li>增加<strong>调度及运行策略</strong>（灵活选择！</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>电梯</tag>
        <tag>第二单元</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】ElevatorDispatcher2.0</title>
    <url>/2023/04/02/BUAA-OO-ElevatorDispatcher-2-0/</url>
    <content><![CDATA[<p>北航面向对象与程序设计第二单元课程作业，电梯调度器ElevatorDispatcher 2.0。<br>为1.0的迭代，新增需求：</p>
<ol>
<li>动态增加自定义电梯。</li>
<li>电梯日常维护请求。</li>
</ol>
<span id="more"></span>
<h1 id="hw6-log"><a href="#hw6-log" class="headerlink" title="hw6_log"></a>hw6_log</h1><h2 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h2><ul>
<li>掌握<strong>线程安全</strong>知识并解决线程安全问题，同时在架构上围绕线程之间的协同设计层次架构。</li>
<li>默认有六部电梯，六部电梯参数固定，但是后续可以<strong>增加电梯</strong>（后续增加的电梯可以半自定义ID，起始楼层，满载人数，移动时间），电梯数量不超过12。</li>
<li>日常<strong>维护请求</strong>，即停掉电梯（在两次移动操作之内停下），保证不会再开启电梯，但下次迭代可能就<strong>指定维护时间</strong>了（又预测失败了，呜呜呜</li>
</ul>
<h2 id="坑点分析-amp-需求实现"><a href="#坑点分析-amp-需求实现" class="headerlink" title="坑点分析&amp;需求实现"></a>坑点分析&amp;需求实现</h2><ul>
<li>刚新增就维护的情况</li>
<li>一下增加几部电梯的情况</li>
<li>一下维护几部电梯的情况</li>
<li>输入结束了，但是电梯还在维护下客的过程中</li>
<li><p>考虑如果电梯太快了，然后我在分派里面派Maintain太慢了，它已经移动了两层怎么办捏（（</p>
</li>
<li><p>我们要考虑上述新增需求<strong>需要谁来做到</strong>，整体来说这一周的增量开发的幅度不大</p>
<ul>
<li>虽说幅度不大，但是我在实现maintain的过程中还是<strong>遇上了不少的线程安全的问题</strong>，在这些碰壁中加深了我对线程安全的理解。</li>
<li>详细请看<a href="#线程安全的分析">线程安全分析一节</a></li>
</ul>
</li>
<li>增加电梯就直接在<strong>分派器里面操作</strong>就行了，然后自定义电梯的构造可以给出<strong>构造重载</strong>（也可以用<strong>工厂模式</strong>，但我个人感觉没必要<ul>
<li>有自定义量之后会有一个比较大的问题，分派策略需要发生变化，我的distanceEva可能需要<strong>增加更多的指标</strong>了</li>
<li>有时间其实可以实现一下<strong>影子电梯</strong>（后面细说）。</li>
</ul>
</li>
<li>关于日常维护，可以作为<strong>电梯的一种状态</strong>，这样既符合现实，又有利于迭代。<ul>
<li>维护的电梯不参与分派就好了。</li>
</ul>
</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li><p>由于需求增量不大，据我后面的分析，我并<strong>不需要增加类</strong>，所以类图还是上一次的实现。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher2.0/uml.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher2.0/uml.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="uml"></p>
</li>
<li><p>至于要如何将<strong>需求融合进上一次的架构</strong>，且听下面分解！</p>
</li>
</ul>
<h3 id="新增电梯实现"><a href="#新增电梯实现" class="headerlink" title="新增电梯实现"></a>新增电梯实现</h3><ul>
<li><p>先初始化input类，按照不同的请求类型做不同的操作：</p>
</li>
<li><p>关于如何<strong>增加电梯请求与维护请求</strong>：我想到了两种实现。</p>
<ul>
<li><strong>输入线程</strong>直接的操作<ul>
<li>输入线程直接对分派器增加请求，可以<strong>实时增加电梯</strong>。</li>
<li>输入线程直接对电梯进行操作，<strong>实时maintain电梯</strong>。</li>
</ul>
</li>
<li>RequestTable增加除了人请求之外的<strong>其他两个请求</strong>的ArrayList，dispatcher还是在它这<strong>取东西</strong>（我选择这个，这是一种<strong>归一化的处理</strong>。</li>
</ul>
</li>
<li>然后在Elevator类中<strong>增加属性</strong>，并实行相应的默认值替换。</li>
<li>在Dispatcher类中，每一次run，需要<strong>判定三个东西</strong>，有没有<strong>maintainReq</strong>、有没有<strong>加电梯的指令</strong>、<strong>有没有人</strong>。如果有的话进行相应的处理就行（怎么实现maintain的处理，请看下文。</li>
</ul>
<h3 id="maintain的实现"><a href="#maintain的实现" class="headerlink" title="maintain的实现"></a>maintain的实现</h3><ul>
<li>maintain通过在passengerQueue里实现增加请求来实现，即分派器在总表里面拿到maintain的请求，就把它放到分表里面，让elevator自行取请求（所以可以走两楼这个界限我还是别去碰了，这里本来就有延迟了</li>
<li><p>Elevator MAINTAIN后意味着需要把人都送回requestTable，怎么界定访问，难道要在Elevator里加上总表的属性？</p>
<ul>
<li>这样其实也就相当于Elevator也是一个生产者了，合理的。！！！可以看下图示意：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher2.0/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher2.0/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="生产消费模型"></li>
</ul>
</li>
<li><p>maintain之后<strong>还可以走两步</strong>，<del>这两步是尽量要走完的</del>，所以我加了一个maintain倒计时（为2），倒计时开始前先释放一波叭（等待队列里的超过两楼的都可以放掉），倒计时结束进入maintain函数，释放所有的等待队列及电梯上的乘客。</p>
<ul>
<li>可能从刚刚move完，到了maintain这一步，这样你就需要下客，感觉maintain之后走的这两步会引发不少问题，要不<strong>干脆别走了罢</strong>，<strong>直接放了省时省力</strong>。</li>
</ul>
</li>
<li>但是我得想怎么把maintain的电梯停下来，以至于让他不轮询。<ul>
<li>简易的办法是<strong>直接return</strong>。</li>
<li>怎么留下拓展性，这里我们可以考虑可能有两个<strong>增量的方法</strong>，一个就是可以<strong>输入维修时间</strong>，那简单，直接sleep就行，害有一种就是<strong>再次输入维修完成的请求</strong>，那就可以waitRequestTable来请求。（但是最后没有用到！！！</li>
</ul>
</li>
</ul>
<h3 id="DistanceEva的更新"><a href="#DistanceEva的更新" class="headerlink" title="DistanceEva的更新"></a>DistanceEva的更新</h3><ul>
<li>在DistanceEva中增加了<strong>fullPasNum, speed</strong>两项指标</li>
<li>最终的参数调整出来是这样的，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ((<span class="number">33</span> - distance - pasReqNum * <span class="number">2.5</span> - passengerNum * <span class="number">2.5</span> + fullPasNum * <span class="number">1.3</span> - speed * <span class="number">17</span>) / (speed * speed));</span><br></pre></td></tr></table></figure>
<ul>
<li>是不是很奇怪，但它确实是最快的！</li>
<li>有同学可能会疑惑，为啥speed除去了一次平方，还要<strong>减去一个</strong>呢？<ul>
<li>这里我的主要考虑是结合我的“<strong>不强扭瓜</strong>”的分派方式，根据得分是否低于0分来决定是不是合适的，如果不给减去speed的量，那么speed就<strong>不能改变正负，只能改变大小</strong>。所以需要减去一个，<strong>实测减去一个确实更优</strong>！</li>
</ul>
</li>
</ul>
<h3 id="结束条件的改变"><a href="#结束条件的改变" class="headerlink" title="结束条件的改变"></a>结束条件的改变</h3><ul>
<li>当电梯成为生产者，那<strong>总表的end</strong>就需要另外考虑了，可能最后一条指令mantian后，电梯给总表加了人，但是此时dispatcher停了！我们需要<strong>重新考虑结束的条件</strong>。</li>
<li>最后找到了一个方法，灵感源自<strong>zbygg提醒</strong>。想到反正电梯都可以访问到总表了，我可以维护一个maintain请求的数量，<strong>在maintain来到总表的时候++</strong>，在elevator<strong>完成maintain的最后—</strong>，这样就能够保证这整个周期外，电梯不会再放人。<ul>
<li>这样，dispatcher结束的标志就是<code>requestTable.isPasEmpty() &amp;&amp; requestTable.isInputEnd() &amp;&amp; requestTable.MaintainFinish()</code></li>
<li>可以保证满足上述条件之后，<strong>总表中不会有新请求</strong>。</li>
</ul>
</li>
</ul>
<h2 id="线程安全的分析"><a href="#线程安全的分析" class="headerlink" title="线程安全的分析"></a>线程安全的分析</h2><ul>
<li>在这一次的迭代中，虽然迭代的力度不大，但是电梯成为了总表的生产者，这个会引起一些问题。<ul>
<li>一个类线程安全就是多个线程访问一个类的<strong>次序不影响结果</strong>。</li>
</ul>
</li>
<li><p>为了线程安全，我们尽量不能让dispatcher直接写elevator，得让它访问他们之间的共享对象passengerQueue，所以<strong>maintain传递的考虑</strong>就是这么来的。</p>
</li>
<li><p>不安全问题的表征：</p>
<ul>
<li>多个修改发生覆盖，<strong>Read-modify-write</strong></li>
<li>读取不到最新的结果，<strong>check-then-act</strong></li>
</ul>
</li>
<li>这两种不安全在作业里都有体现，因为dispatcher的评分需要读取elevator，所以elevator其实是一个共享对象，所以我们面临一个就是dispatch的评估在跑着，elevate也在跑，但是可能在取到数据评估的时候，elevate改变了elevator对象的属性，怎么保证得到的是最新的数据？<ul>
<li>电梯类的对象也是共享对象，这里我们就要理解线程和类之间的关系了，线程并不属于类，类里面的run方法只是一个线程的入口，比如main也是一个入口而已。所以类可以被自己创造的线程访问，在我们这，电梯是一个共享对象，它被dispatch行为的线程和elevate行为的线程给共享访问了。<ul>
<li>使用读写锁，来给写的时候的读的行为加锁（因为我认为可以去阻塞dispatcher，但是绝对不能阻塞elevator）。</li>
<li>但是如果给elevator的同步块过大的话，也会出问题，因为这样dispatcher就要被迫等elevator很长的时间sleep的时候也得等。</li>
<li>然后就是关于我需要等分派器给电梯评完分再动？难搞，为了最终的性能考虑，毕竟这种情况本身就是少数情况（因为评分的这个尺度与电梯运行的尺度相比，差距太小了），所以我还是选择不给电梯加锁，而选择<strong>双重验证</strong>的方法。具体请看</li>
</ul>
</li>
</ul>
</li>
<li>然后就是requestTable这一个共享的类，对于总表这一共享对象，一个Input和六个电梯是他的输入线程，然后由dispatcher访问。分表不多说。<ul>
<li>这个线程安全问题的解决可以用synchronized块，也可以用读写锁实现单写多读的灵活控制。</li>
</ul>
</li>
</ul>
<h2 id="歪门邪道的优化策略"><a href="#歪门邪道的优化策略" class="headerlink" title="歪门邪道的优化策略"></a><del>歪门邪道</del>的优化策略</h2><h3 id="弹射起步"><a href="#弹射起步" class="headerlink" title="弹射起步"></a>弹射起步</h3><ul>
<li>这一点是yt带我大开眼界，因为电梯运行时间是根据两个arrive之间的时间来考虑的。</li>
<li>所以每个电梯的第一个arrive，它没有参照物！！！它不需要sleep！！！</li>
</ul>
<h3 id="影子电梯"><a href="#影子电梯" class="headerlink" title="影子电梯"></a>影子电梯</h3><ul>
<li>这应该算得上是效率最优的分派方式了，不同于我实现的distanceEva方法，影子电梯是一种全模拟。</li>
<li>虽然我没有实现，但是我大致构想了一下实现的思路，希望能提供一种参考。<ul>
<li>首先肯定不能让模拟电梯真的sleep，你只需要给一个时间参量，一次+400就行。</li>
<li>然后就是关于怎么读取电梯的信息。<ul>
<li>一种方法就是深克隆，但是我总感觉代价太大了，因为深克隆电梯你还得深克隆请求队列啥的。</li>
<li>另一种方法就是只提取有效信息，就是用一张表，记录下需要在哪一层停（为了接客和下客都不用管），然后来模拟运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="双重验证"><a href="#双重验证" class="headerlink" title="双重验证"></a>双重验证</h3><ul>
<li>这是我为了不给电梯加锁来解决这次电梯类的线程不安全问题的一种折中的办法。（我不想给电梯加锁，因为我觉得还是有点怪的）</li>
<li>所以我考虑到，对于一部电梯而言，它状态改变的周期至少是200ms，而我dispatch线程中访问电梯属性的方法的执行肯定用不了200ms。</li>
<li>所以我在访问开始前存下来电梯在此时的状态，然后在评价完返回结果之前，判断一下，电梯现在的状态与开始的状态是否一致。若不一致，则再次评价。（而且我能保证，再次评价状态肯定不会有变化，因为电梯来不及变化）</li>
<li>大致示意如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">curFloor</span> <span class="operator">=</span> elevator.getCurFloor();</span><br><span class="line"><span class="type">int</span> <span class="variable">passengerNum</span> <span class="operator">=</span> elevator.getPassengerNum();</span><br><span class="line"><span class="type">int</span> <span class="variable">requestNum</span> <span class="operator">=</span> ElePasQueues.getPassengerNum();</span><br><span class="line"><span class="comment">//评价中。。。。。</span></span><br><span class="line"><span class="keyword">if</span> (!isSameEle(elevator, curFloor, passengerNum, requestNum)) &#123;</span><br><span class="line">    score = eleEvaluation.getScore(elevator, passenger);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> score;</span><br></pre></td></tr></table></figure>
<h3 id="时间骗子（好像管这叫量子电梯"><a href="#时间骗子（好像管这叫量子电梯" class="headerlink" title="时间骗子（好像管这叫量子电梯"></a>时间骗子（好像管这叫量子电梯</h3><ul>
<li>这才是真的歪门邪道哇！</li>
<li>就是说，根本不用像我上面那样纠结给电梯加锁还是双重验证了。</li>
<li>因为电梯的运行时间是通过arrive之间的时间，所以不需要老老实实的sleep(moveTime)<ul>
<li>我们可以在电梯里维护一个curTime的long值，在每个操作之前，利用System获取当前时间得到stepTime，刷新一下curTime。</li>
<li>然后你就只需要sleep(moveTime - stepTime)了！！！</li>
</ul>
</li>
<li>当然为了保险，你可以给stepTime一个处罚阈值，以防移动太快的wa。</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>电梯</tag>
        <tag>第二单元</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】ElevatorDispatcher3.0</title>
    <url>/2023/04/14/BUAA-OO-ElevatorDispatcher-3-0/</url>
    <content><![CDATA[<p>北航面向对象与程序设计第二单元课程作业，电梯调度器ElevatorDispatcher 3.0。<br>为2.0的迭代，新增需求：</p>
<ol>
<li>限制同楼层服务电梯。</li>
<li>电梯可达楼层属性限制。</li>
</ol>
<span id="more"></span>
<h1 id="hw7-log"><a href="#hw7-log" class="headerlink" title="hw7_log"></a>hw7_log</h1><h2 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h2><ul>
<li>调度上有一点变化，限制了<strong>楼层停靠电梯的数量</strong></li>
<li>电梯可达性分析，一部电梯不一定能在所有的楼层停靠，所以需要考虑<strong>换乘的问题</strong>。（这一点的跨度很大，所以得好好分析需求</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>限制同楼层<strong>服务中电梯的个数</strong>与<strong>只接人电梯的个数</strong><ul>
<li>这其实是对openAndClose做出的限制，而且<strong>满了的话也只好阻塞一下</strong>，等别的电梯退出服务状态再运行，没有什么好的优化办法（总不能说不下客了叭）。</li>
<li>这个请求我想到的是交给总表来解决，因为电梯可以访问到总表，所以每一次开门和关门的时候都让<strong>总表的标志位+1-1</strong>就行了<ul>
<li>说到这，我觉得requestTable其实承担了太多的责任，这样<strong>其实是不好的</strong>，不符合单一责任的原则。</li>
<li>我给我的RequestTable类<strong>改名为KanbanBoard</strong>，这样感觉更加贴切。</li>
</ul>
</li>
<li>后来我知道了一个<strong>信号量</strong>的做法，挺好用的，但是来不及实现了。</li>
</ul>
</li>
<li>对于电梯的可达性，这是电梯的一个final性质。<ul>
<li>我觉得可以在dispatcher里<strong>动态维护一个电梯可达图</strong>，在addEle与maintain的时候对它做出改变。（但是我最终没有实现。</li>
<li>我选择在每一次需要获取从某层到某层的距离的时候，直接使用<strong>电梯的canAccess</strong>方法。</li>
</ul>
</li>
<li>给乘客加上<strong>乘坐路径的属性</strong>，然后原来的直接去的楼层属性改为<strong>destination</strong>。</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>第三次作业结束了，uml类图如下，由于一个比较好的架构，三次作业我只增加了一个类，就是关于<strong>路径规划</strong>的类：</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/uml.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/uml.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="uml"></p>
<h3 id="同楼层服务电梯的数量限制"><a href="#同楼层服务电梯的数量限制" class="headerlink" title="同楼层服务电梯的数量限制"></a>同楼层服务电梯的数量限制</h3><ul>
<li>这个比较好实现，按照我上面需求分析的做法做就好了在每次开关门的时候都<strong>请示一下KanbanBoard</strong>。</li>
<li>但是我在这个地方出了一个<strong>很傻的bug</strong>！！！<ul>
<li>因为我在maintain之后电梯的开关门是自行实现的，而不是调用的openAndClose方法，所以我在<strong>maintain的时候没有请示</strong>。</li>
<li>这导致强测WA了两个点，呜呜呜呜呜。</li>
</ul>
</li>
</ul>
<h3 id="可达性分析（路径规划"><a href="#可达性分析（路径规划" class="headerlink" title="可达性分析（路径规划"></a>可达性分析（路径规划</h3><ul>
<li><p>在做这个可达性分析的时候，我非常的纠结，有过想大改的冲动，但是在<strong>一点一点的摸索</strong>中也探寻到了一个较好的方法。（从下面这幅图就能够看出来我有多纠结了。。。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/%E7%BA%A0%E7%BB%93ing.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/%E7%BA%A0%E7%BB%93ing.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="纠结ing"></p>
</li>
<li><p>所以确实现实不太允许我去这么做了，所以我的策略还是对于每一个需要dispatch出去的乘客，我先对他<strong>进行可达性分析</strong>，决定他<strong>下一步要去往哪一层</strong>，然后就<strong>照常分派</strong>，到不了那一层的电梯，我就直接不考虑就行。</p>
<ul>
<li>所以这样我就抽象出来了两条，<strong>路线规划</strong>与<strong>电梯选择</strong>，电梯选择我早就用<strong>Evaluation接口</strong>做好了。路线规划我也采取一种<strong>综合评价的方法</strong>，也采用<strong>策略模式，接口命名为PathPlanning</strong>，首先是一定要<strong>可达</strong>，可达的其次是可选择的<strong>电梯数量</strong>，这条路径上<strong>人多不多</strong>，<strong>电梯的属性</strong>。。。</li>
<li>这些属性将在哪体现，这就涉及到我们探究可达路径的方法，其实无论是<strong>dfs还是floyd还是dijstra</strong>，只需要注意<strong>加权路径的权重怎么给</strong>，就可以灵活的解决我们这个规划最短路径的问题了。</li>
</ul>
</li>
<li>另外需要给乘客加上乘坐路径的属性<ul>
<li>这个属性是dispatcher给他规划的，所以对于电梯而言，只需要看路程属性即可。不需要关注目的地。</li>
</ul>
</li>
<li>所以电梯又多出来一个生产的途径，要多多考<strong>虑一下结束条件</strong>了。</li>
</ul>
<h4 id="路径规划及权重考虑"><a href="#路径规划及权重考虑" class="headerlink" title="路径规划及权重考虑"></a>路径规划及权重考虑</h4><ul>
<li>路径规划的实现：（<strong>自定义边权重</strong>）dijstra算法</li>
<li>关于dijstra算法的具体实现我这里就具体，网上的板子挺多的，可以选取一个单源dijstra算法实现抄一抄。我这里也给出大致的实现（<strong>仅仅表意</strong>，请根据自己的需要改编）。</li>
<li>但注意由于我不是一种纯静态的实现，所以我把<strong>路径整个都记录了下来</strong>（很简单，用一个数组记录前驱节点即可）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Passenger <span class="title function_">planPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//初始化三个数组</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * result: 存起点到每个点的当前的最短路径</span></span><br><span class="line"><span class="comment">      * visited: 记录下这个点的最短路径是否已经找到</span></span><br><span class="line"><span class="comment">      * prevs: 记录下找到这个点的前驱节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">11</span>];</span><br><span class="line">    <span class="type">int</span>[] prevs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">//初始化，没有找到前驱节点的点数组值为-2，初始点前驱节点为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        result[i] = Integer.MAX_VALUE;</span><br><span class="line">        prevs[i] = -<span class="number">2</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prevs[fromFloor] = -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curFloor</span> <span class="operator">=</span> fromFloor;</span><br><span class="line">    result[curFloor] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环寻路</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//此楼层的最短路径已找到，如果这个楼层是目的地，则退出</span></span><br><span class="line">        visited[curFloor] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (curFloor == destination) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历这个点到每个未访问点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> getVirtualDistance(curFloor, i);</span><br><span class="line">                <span class="keyword">if</span> (distance != Integer.MAX_VALUE) &#123;</span><br><span class="line">                     <span class="comment">//如果路径较短，更新result，将此节点记为前驱节点。</span></span><br><span class="line">                     <span class="keyword">if</span> (result[i] &gt; result[curFloor] + distance) &#123;</span><br><span class="line">                         result[i] = result[curFloor] + distance;</span><br><span class="line">                         prevs[i] = curFloor;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找所有已有的result中的最短距离,更新所在楼层</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i] &amp;&amp; result[i] &lt;= minLen) &#123;</span><br><span class="line">                curFloor = i;</span><br><span class="line">                minLen = result[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到destination距离最大，不可达，数据的问题，报错</span></span><br><span class="line">    <span class="keyword">if</span> (result[destination] == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;passenger &quot;</span> + passenger.getId() + <span class="string">&quot; can&#x27;t reach destination&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在给前驱数组压栈，找到前驱为-1，则当前点就是要去的楼层，这里是我的实现（用栈的结构来表示乘客下一个要去的地方。</span></span><br><span class="line">    <span class="keyword">while</span> (prevs[prevs[curFloor]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        passenger.pushToFloor(curFloor + <span class="number">1</span>);</span><br><span class="line">        curFloor = prevs[curFloor];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    passenger.pushToFloor(curFloor + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> passenger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写了这么一大堆dijstra，其实最重要最关键最灵活的是<strong>路径权重的选取</strong>，也就是<code>int distance = getVirtualDistance(curFloor, i)</code>这一句。<ul>
<li>路径权重可以考虑的有<strong>距离，换乘次数，最合适的电梯的评分</strong>（可能这条路上没有合适的电梯）。。。</li>
<li>这是最为灵活的，如果你想<strong>尽量少换乘</strong>，就可以每一次getDistance的时候就<strong>加上一个巨大的权重</strong>，让它能够忽略其他的值。</li>
<li>如果你想要让<strong>适当的换乘</strong>来分担直达电梯的压力（可能有只留了一部直达电梯，其他都要换乘的情况），可以选择权衡一下<strong>换乘次数</strong>与<strong>电梯状况</strong>的影响路径权重的配比。</li>
</ul>
</li>
</ul>
<h4 id="动态还是静态？有一点折中"><a href="#动态还是静态？有一点折中" class="headerlink" title="动态还是静态？有一点折中"></a>动态还是静态？有一点折中</h4><ul>
<li>关于<strong>动态</strong>的给乘客规划路径（即乘客每走过一程就重新规划一下），<strong>还是静态</strong>规划（即一开始就给乘客规定好，后面就按照这条路径走，有maintain的时候另说）。我觉得都有其优缺点。<ul>
<li>我这里采取的<strong>不是动态规划</strong>的方式，是因为我的加权路径计算比较的复杂，会遇上一个乘客<strong>在相邻两楼之间来回穿梭</strong>的bug。</li>
<li>但是我采用的也<strong>不是静态</strong>的规划，因为很难假定乘客走完这一程之后<strong>电梯是否发生了天翻地覆的变化</strong>。</li>
</ul>
</li>
<li>还记得我说过我的“<strong>不强扭瓜</strong>”的<strong>分派方式</strong>嘛，我这里可以与这种分派方式做<strong>一个适配</strong>。<ul>
<li>即：一开始给乘客<strong>规划好所有的路径</strong>，然后每次乘客回到总表中重新分派的时候，如果<strong>有合适的电梯</strong>能够满足他的下一个需求的话，<strong>就使用</strong>这部电梯。<strong>如果没有</strong>！那就给这个乘客<strong>重新规划路径</strong>。这是一种<strong>半动态的方式</strong>。</li>
</ul>
</li>
</ul>
<h3 id="DistanceEva！改改还能用"><a href="#DistanceEva！改改还能用" class="headerlink" title="DistanceEva！改改还能用"></a>DistanceEva！改改还能用</h3><ul>
<li>distance只需要改动两点，就能够在这一次的迭代中，达到可观的效果。</li>
<li>一点是考虑到<strong>电梯的可达性</strong>，我再假定从1楼到11楼不合理了，应该是<strong>从可达的最低楼层到最高楼层</strong></li>
<li>另外的一点新的考虑是，其实对于<strong>电梯里的人与请求的人</strong>的考虑，我认为，<strong>不应该是线性的</strong>了！！！！！<ul>
<li>电梯剩余可载人数有三人和有五人有什么区别嘛？至少<strong>对于一个人</strong>是否<strong>能上这部电梯</strong>是没有区别的！！！</li>
<li>所以我对于人数上的分数有一定的调整。</li>
</ul>
</li>
<li>经过参数调优之后，结果如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ((<span class="number">33</span> - distance - elevator.passengerStatus() - speed * <span class="number">17</span> - accessNum) / (speed * speed * accessNum));</span><br><span class="line"><span class="comment">//其中，电梯类的passengerStatus方法实现如下(可以看到是个阶梯状)：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">passengerStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">busyIndex</span> <span class="operator">=</span> fullPasNum * <span class="number">1.3</span> - passengerNum * <span class="number">1.1</span> - passengerQueue.getPassengerNum();</span><br><span class="line">    <span class="keyword">if</span> (busyIndex &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (busyIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (busyIndex &gt; -<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> + (<span class="type">int</span>) (<span class="number">0.5</span> * passengerQueue.getPassengerNum());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> + passengerQueue.getPassengerNum();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束条件"><a href="#结束条件" class="headerlink" title="结束条件"></a>结束条件</h3><ul>
<li>结束条件也需要改动了，因为只要<strong>有电梯在动</strong>，就有可能<strong>有新需求</strong>，所以dispatcher不应该这么早结束。<ul>
<li>结束条件再加一条，所有电梯都是wait或者maintain的状态，分派才结束！</li>
</ul>
</li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><ul>
<li>我用jetbrains自己家的<strong>codeMR插件</strong>（雪牲又<strong>可以白嫖</strong>，快冲）分析了一份结果出来。还挺好看的，但是我有些东西看不太懂，而且它以本地html的形式展现，我懒得弄上net了，就不放上来了，效果如下图：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/codeMR%E5%88%86%E6%9E%90.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/codeMR%E5%88%86%E6%9E%90.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="codeMR分析"></li>
<li><p>其实可以看出，虽然我从一到三次迭代从未重构，还算考虑周全，但是确实<strong>最后Elevator类，KanbanBoard类</strong>的<strong>复杂度</strong>还是太高了一点，<strong>代码行数</strong>也比较的恐怖，其实也本应该多做一点细分的。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="代码行数"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ElevatorDispatcher3.0/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="复杂度分析"></p>
</li>
<li><p>然后可以看到，圈复杂度比较高的都是些<strong>评价的算法</strong>，这个是因为我的评价体系确实<strong>考虑的太多</strong>了（</p>
</li>
</ul>
<h2 id="小感想"><a href="#小感想" class="headerlink" title="小感想"></a>小感想</h2><ul>
<li>这是我第一次写这么大规模的多线程的程序，教会了我很多分析线程安全问题解决问题的方法，我觉得这不仅是面向对象的程序设计所独有的一些经验。包括多进程的程序设计，并发并行程序设计等等都与这章所学到的知识息息相关。感觉在其中受益匪浅吧。</li>
<li>另外这一章远不只是多线程这么简单，还教会了我使用设计模式，运用规范的面向对象设计原则去展开我的设计。</li>
<li>在分析需求的过程中体会拓展与实现的各种巧思，这一点直接训练在思维能力上。我认为迭代开发中的架构设计稳定，不仅取决于良好的架构与代码风格，而且还取决于对于需求的分析，对于需求实现的发散！</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>电梯</tag>
        <tag>第二单元</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】第一单元Expr_expansion_1.0</title>
    <url>/2023/02/28/BUAA-OO-Expr-expansion-1-0/</url>
    <content><![CDATA[<p>北航面向对象与程序设计课程作业，表达式展开Expr-expansion 1.0，主要设计面向对象的程序设计思想以及递归下降法文法分析的实现。</p>
<span id="more"></span>
<h1 id="BUAA-OO-第一单元"><a href="#BUAA-OO-第一单元" class="headerlink" title="BUAA-OO 第一单元"></a>BUAA-OO 第一单元</h1><ul>
<li>包含主要知识点整理、练习题略解、作业题详解</li>
</ul>
<h2 id="主要知识点-从BNF看面向对象"><a href="#主要知识点-从BNF看面向对象" class="headerlink" title="主要知识点-从BNF看面向对象"></a>主要知识点-从BNF看面向对象</h2><ul>
<li>BNF(Backus Naur Form Notation)表示文法，用于解析字符串，详细内容涉及到编译的知识（俺暂时不是很懂</li>
<li>但是这个文法的规范化表示里，符号可以表示为类，是<strong>数据</strong>，而文法规则定义了<strong>结构</strong>的关系，由非终结符到终结符的结构蕴含着<strong>树的数据结构</strong>以及类的行为结构。</li>
<li>因此我们可以以面向对象的思想去设计结构，用递归来实现这种树状结构。</li>
</ul>
<h2 id="练习题略解"><a href="#练习题略解" class="headerlink" title="练习题略解"></a>练习题略解</h2><h3 id="training-1"><a href="#training-1" class="headerlink" title="training-1"></a>training-1</h3><ul>
<li><p>正则表达式：除了什么命名捕获组，逆过程之外，我们记住几点基础且重要的<strong>限定符</strong>（详细请移步<a href="#reference">菜鸟教程</a>）：</p>
<ul>
<li>*表示匹配前子表达式 $0 \sim + \infty $ 次</li>
<li>+表示 $1 \sim + \infty $ 次</li>
<li>?表示0或1次</li>
<li>{n, m}表示n~m次</li>
</ul>
</li>
<li><p>IDEA有匹配正则表达式的工具，可以实时编辑调试，但好像有很多同学不知道。</p>
<ul>
<li>鼠标移动到正则表达式处，右键点击后，点击第一个“<strong>显示上下文操作</strong>”</li>
<li>然后点击“<strong>检查正则表达式</strong>”，效果如图：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83Expr-expansion1.0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83Expr-expansion1.0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="正则表达式检查"></li>
</ul>
</li>
<li><p>java在正则表达式中匹配*，注意<strong>转义</strong>“\*“</p>
</li>
<li><p>training-1向我们展示了用正则表达式做这题的思路，但实现起来同学会发现比较的麻烦。而且考虑到后续迭代，所以推荐<strong>递归下降法</strong>。</p>
</li>
</ul>
<h3 id="training-2"><a href="#training-2" class="headerlink" title="training-2"></a>training-2</h3><ul>
<li>用到递归下降了</li>
<li>注意文法表述的优先级，比如，Expr-&gt;Term | Expr ‘+’ Term， 先调用Term（结束符的方向），在考虑循环加Term，更符合我们<strong>实现的结构</strong>，自己看着也会舒服点。</li>
<li>博主接下来的作业就是以training-2作为基本架构的。</li>
</ul>
<h2 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h2><h3 id="形式化表述"><a href="#形式化表述" class="headerlink" title="形式化表述"></a>形式化表述</h3><ul>
<li>表达式 → 空白项 [加减 空白项] 项 空白项 | 表达式 加减 空白项 项 空白项</li>
<li>项 → [加减 空白项] 因子 | 项 空白项 \’*’ 空白项 因子</li>
<li>因子 → 变量因子 | 常数因子 | 表达式因子</li>
<li>变量因子 → 幂函数</li>
<li>常数因子 → 带符号的整数</li>
<li>表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]</li>
<li>幂函数 → (‘x’ | ‘y’ | ‘z’) [空白项 指数]</li>
<li>指数 → ‘**’ 空白项 [‘+’] 允许前导零的整数 (注：指数一定不是负数)</li>
<li>带符号的整数 → [加减] 允许前导零的整数</li>
<li>允许前导零的整数 → (‘0’|’1’|’2’|…|’9’){‘0’|’1’|’2’|…|’9’}</li>
<li>空白项 → {空白字符}</li>
<li>空白字符 → （空格） | \t</li>
<li>加减 → ‘+’ | ‘-‘</li>
</ul>
<blockquote>
<p>看着挺复杂的，咱们<strong>化简</strong>一下叭</p>
</blockquote>
<ul>
<li>其实主体很简单：有三个最重要，<strong>表达式、项、因子</strong></li>
<li>空白项很好处理，我们简化里就不写出了</li>
<li>下面就基本上是我们<strong>要设置的类</strong>和其中的<strong>元素的关系</strong>了，但是Num显然不需要设立一个类（这里只是为了简化表示）</li>
<li>Expr    -&gt; [±] Term    | Expr ‘±’ Term</li>
<li>Term    -&gt; [±] Factor  | Term ‘*‘ Factor</li>
<li>Factor  -&gt; PowFunc | ConNum | ExprFactor</li>
<li>PowFunc -&gt; (‘x’ | ‘y’ | ‘z’) [‘**‘ [‘+’] Num]</li>
<li>ConNum  -&gt; [±] Num</li>
<li>ExpFa   -&gt; ‘(‘ Expr ‘)’ [‘**‘ [‘+’] Num]</li>
<li>Num     -&gt; ( 0 ~ 9 ) { 0 ~ 9 }</li>
</ul>
<h3 id="题目需求解析-amp-坑点汇总"><a href="#题目需求解析-amp-坑点汇总" class="headerlink" title="题目需求解析&amp;坑点汇总"></a>题目需求解析&amp;坑点汇总</h3><ul>
<li><p>保证正确性：</p>
<ul>
<li>表达式因子要<strong>展开</strong></li>
<li>展开后和项中的其他因子<strong>相乘，拆括号</strong></li>
<li>用<strong>new BigInteger(String)</strong>，不要用BigInteger.valueof(long)（会爆</li>
<li>可能会有的情况<ul>
<li>—-ConNum</li>
<li>(-ConNum)**index</li>
</ul>
</li>
</ul>
</li>
<li><p>卷性能：</p>
<ul>
<li>注意<strong>指数为1或0时</strong>，可以化简</li>
<li>注意<strong>系数为1、0、-1时</strong>，可以化简</li>
<li>只有<strong>整数、项、常数因子</strong>前可以有表示符号的加减，所以注意两减也可以合成为一个加，然后按照规则会出现—-、-+-、… 的情况。</li>
<li>前导零，要化简</li>
<li>三项以上的相乘可以化简为乘方，但是<strong>x**2 -&gt; x*x</strong></li>
<li>常数相乘算出来，注意10*10*10*10*10*10<strong>不能写成10**6</strong>，10**6不符合形式化表示，还是算出来1000000</li>
<li>表达式<strong>合并同类项</strong><ul>
<li>最简的情况应该是 $\Sigma ConNum \ast x^a \ast y^b \ast z^c $</li>
</ul>
</li>
<li><strong>把正的放在最前面，比负的放在最前面可以少一个符号（这个博主没有想到orz）</strong></li>
</ul>
</li>
<li>注意表达式和表达式因子不是同一个东西：我们可以在表达式因子中设置<strong>表达式的引用</strong>，这样实现可以保证后续迭代时<strong>多层括号的需求</strong>容易满足</li>
<li>注意我们需要统一标准，调用函数返回时，Lexer指向的是<strong>刚被操作过的位置</strong>或是<strong>还没操作过的位置</strong>，要不然会被Lexer需不需要.next()弄得晕头转向</li>
</ul>
<blockquote>
<p>我们提前思考一下<strong>哪些坑点需要在哪一步填</strong></p>
</blockquote>
<h3 id="uml图"><a href="#uml图" class="headerlink" title="uml图"></a>uml图</h3><ul>
<li>先简单介绍一下Unified Modeling Language，是面向对象设计的建模语言，其中最为常见的就是<strong>类图</strong>，十分的可视化。</li>
<li>类图中的不同符号表示的含义：<ul>
<li>类</li>
<li>抽象类</li>
<li>接口</li>
<li>包</li>
<li>关系<ul>
<li>实现关系(Realization)：类实现了接口</li>
<li>泛化关系(Generalization)：SubClass “is a” SuperClass.</li>
<li>关联关系(Association)：A知道B的public（包含B的引用），一般为单项关联，关联又能具象化成三类<ul>
<li>依赖关系(Dependency)：A “use a” B.<ul>
<li>是一种弱关联关系，表现为四种形式。</li>
<li>B为A的局部变量</li>
<li>A调用了B的static方法</li>
<li>B是A的方法的参数</li>
<li>B是A的方法的返回值</li>
</ul>
</li>
<li>聚合关系(Aggregation)：A “has a” B. eg: school has a student</li>
<li>组合关系(Composition)：A “contains a” B. eg: student contains a brain</li>
<li>聚合和组合在逻辑关系上往往体现不出差别，但是可以在实际意义上区分，聚合是可以分开的，而组合关系的A与B同时存在同时消亡。这一点差别会体现代码实现上。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>“免费”的uml软件</p>
<ul>
<li>wps</li>
<li>亿图图示</li>
<li>staruml（俺用的这个，可以通过一些小手段让他免费，见<a href="#reference">Reference</a>，注意仅供学习</li>
<li>IDEA插件</li>
</ul>
</li>
<li><p>我实现的类图如下（由于课程要求，类图中并<strong>没有给出</strong>的详细方法和属性，但<strong>关系大致明了</strong>）：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83Expr-expansion1.0/hw1_uml.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83Expr-expansion1.0/hw1_uml.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="uml"></p>
</li>
<li><p>我的架构大致分为三个横向的组织：<strong>文法分析</strong>(Parser, Lexer)，<strong>表达式结构</strong>(Expr, Term, Factor)，<strong>多项式运算</strong>(Poly, Mono)</p>
</li>
<li>还记得我们上文中提到的这么多坑吗，我们需要思考在哪填这个坑是最合适的，这样你的需要的<strong>方法和属性</strong>就出现了</li>
<li>我们的大致步骤就是先用parser<strong>解析表达式</strong>，然后再在每一个元素中都加上<strong>转化成Poly类</strong>的方法。在Poly类中实现<strong>多项式相乘相加</strong>的方法。在Expr.toPloy()中，实现所包含的Term.Poly()的相加；在Term.toPoly()中实现所包含的Factor.toPloy()的相乘(也是一个递归的过程)。</li>
<li>详细实现<strong>请看下文</strong>：</li>
</ul>
<h3 id="递归下降分析"><a href="#递归下降分析" class="headerlink" title="递归下降分析"></a>递归下降分析</h3><blockquote>
<p><strong>面向需求</strong>，我们想想要在哪一步干什么事，每一个类里需要包含哪些方法，实现哪些属性。（本文均是博主的个人实现，<strong>不代表最优方法</strong>，仅供参考，<strong>有优化的建议欢迎在评论区指出</strong>。</p>
</blockquote>
<ul>
<li>Lexer需要完成的操作：<ul>
<li>在Lexer就把烦人的空白字符和叠加’±’给扬咯<ul>
<li>可以在<strong>初始化Lexer</strong>时就 <code>replaceAll(&quot;[ |\\t]&quot;, &quot;&quot;)</code>直接<strong>去掉所有的空白字符</strong></li>
<li>然后Lexer.next()方法里遇到’±’就把循环看看<strong>后一个字符</strong>是不是’±’，若是就<strong>合并输出</strong></li>
</ul>
</li>
<li>然后我们的做法是对于不同的因子，我没必要让Parser一个一个字符的去接收然后识别，我把这个工作交给Lexer<ul>
<li>Lexer返回的curToken字符串中，若识别到isLetter或isDigit，就<strong>把这个因子全输出</strong>了</li>
<li>但是对于表达式因子需要特殊处理，需要<strong>交给Parser去调用parseExpr</strong>的方法</li>
<li>另外包括检测<strong>是否有指数</strong>以及将’**‘<strong>与index合并输出</strong>了，这也可以让Lexer来做</li>
</ul>
</li>
</ul>
</li>
<li>所以Lexer.next()可以这么实现(<strong>伪代码</strong>)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c = input.charAt(++pos);</span><br><span class="line"><span class="comment">//加减法压缩</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> | c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    getPOM();</span><br><span class="line">curToken = String.valueOf(c);</span><br><span class="line"><span class="comment">//按不同情况返回一整串因子</span></span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(c)) </span><br><span class="line">    getPowerFunction();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c))</span><br><span class="line">    getConstNum();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    curToken = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    getIndex();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意虽然博主借鉴training-2中的做法，将因子的识别放在Lexer里面，但是识别的终究只是字符串，<strong>Lexer和Factor之间没有关系</strong>（我的类图中Lexer与Factor之间没有连线）。Parser与Lexer本身就是强聚合（组合）关系，这一点<strong>对main是隐藏的</strong>。所以放在Lexer中还是Parser中取决于自己的实现。我这里避免Paser太过于臃肿，放在Lexer中，这样Lexer每次都能直接<strong>返回一个最小化的元</strong>。Parser中需要做的仅仅是<strong>构造</strong>。</p>
</li>
<li><p>Parser类的结构也比较明了了，只需要<strong>判断Lexer返回</strong>的不同的curToken，<strong>调用不同的函数递归下降</strong>即可：</p>
<ul>
<li>想想我们的表达式里的每一个元素<strong>需要什么样的属性</strong>，我们的parser需要给到一些什么属性<strong>用来构造</strong>，至于化简的事，交给后续的<strong>运算类</strong>即可。</li>
<li>但是这里有一个比较有趣的正负号的处理的问题，我们要<strong>把正负号归为谁的属性比较好</strong>呢。<ul>
<li>我的实现是<strong>把正负号作为因子的属性</strong>，因为我们在Lexer中压缩了连在一起的正负号，所以一个<strong>Term的前面只会有一个正负号</strong>。但是这个正负号只能<strong>给Term的第一个因子</strong>，后续因子，若是常数，则有可能自己就带正负号。考虑这个<strong>栗子：1—x<em>-1</em>-2*+1</strong>。三种因子的类中都定义一个<strong>pom(plusOrMinus)的boolean值</strong>，在后续<strong>Term.toPloy()时规范输出</strong>即可。</li>
</ul>
</li>
<li>所以parserExpr(),parseTerm()在解析的时候需要给后一项<strong>传入正负号的参数</strong>。</li>
</ul>
</li>
<li>Parser类的实现大致如下（<strong>伪代码</strong>）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexer lexer;</span><br><span class="line">    Parser(lexer);</span><br><span class="line">    <span class="keyword">public</span> Expression <span class="title function_">parserExpression</span><span class="params">()</span> &#123;</span><br><span class="line">        expression.addTerm(parserTerm(pom));</span><br><span class="line">        <span class="keyword">while</span> (...)</span><br><span class="line">            expression.addTerm(parserTerm(pom));</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Term <span class="title function_">parserTerm</span><span class="params">(pom)</span> &#123;</span><br><span class="line">        term.addFactor(parserFactor(pom));</span><br><span class="line">        <span class="comment">//后面的因子都不受传入的POM的影响了</span></span><br><span class="line">        <span class="keyword">while</span> (...)</span><br><span class="line">            term.addFactor(parserFactor(signChar));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">parserFactor</span><span class="params">(pom)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (...)</span><br><span class="line">            tmpE = parserExpression();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExprFactor</span>(...);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (...)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerFunction</span>(...);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstNum</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>到这我们的表达式解析就可以了，我们在MainClass里也以及得到了一个<strong>包含着所有信息</strong>的Expression的对象了。</li>
<li>接下来就是<strong>运算，化简</strong>（卷性能分）<strong>，字符串输出</strong>的活了。</li>
</ul>
<h3 id="表达式展开运算"><a href="#表达式展开运算" class="headerlink" title="表达式展开运算"></a>表达式展开运算</h3><ul>
<li>本来博主为了说不弄折磨多类，简洁我的结构，把<strong>运算和化简、toString</strong>都在各个元素的类里面实现，但是后来发现不同类的属性差异巨大，我得转化成String，再运算，再转回String输出，我的<strong>类变得又臭又长</strong>（</li>
</ul>
<blockquote>
<p>我原本想一类多用，是不是很大胆，我一直在做一类多用简洁结构的准备，我刚开始coding的时候，我对他们说，我要一类多用，你们只需要给我20天，或者是25天，我就把程序给码完了，什么同学啊助教啊老师都很兴奋（emo歪头.jpg</p>
</blockquote>
<ul>
<li>最后我在网上搜寻一些资料，找到了往年学长的博客，看到它们的实现，感觉<strong>茅塞顿开</strong>，<strong>学长博客</strong>见<a href="#reference">Reference</a></li>
<li>我们设置两个类当作<strong>运算类</strong>，<strong>Poly</strong>(多项式)&amp;<strong>Mono</strong>(单个的项，作为Poly的<strong>组成元素</strong>)，我们把所有的<strong>表达式元素都转化成Poly类</strong>（单个的<strong>因子可以作为只有一个Mono的Poly</strong>，表达式因子我们可以在toPoly()中运算展开成一个大的Poly）。<ul>
<li>我们上文说最后<strong>最简的结构</strong>都会是 $\Sigma ConNum \ast x^a \ast y^b \ast z^c $，所以我们的<strong>Mono的属性</strong>就一目了然了。</li>
</ul>
</li>
<li><strong>方法的设置</strong>上：<ul>
<li>我们在Poly类中设置运算的方法，这个方法可以是<strong>static的并且返回一个Poly类的</strong>，也可以是<strong>只传入一个参数然后与调用方法的对象做运算但是无返回值void的</strong>。</li>
<li>设置一个<strong>addPoly()</strong>（可以做合并同类项啦），一个<strong>multiPoly()</strong>（乘方可以循环调用乘法来做），然后设置一个<strong>negPoly()</strong>（来给Poly取反）。然后每个元素的<strong>toPoly()来调用这些方法</strong>即可.</li>
</ul>
</li>
<li>伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poly</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Mono&gt; monoArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMono</span><span class="params">(Mono mono)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Mono&gt; <span class="title function_">getMonoArrayList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Poly <span class="title function_">addPoly</span><span class="params">(Poly poly1, Poly poly2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Poly <span class="title function_">multiPoly</span><span class="params">(Poly poly1, Poly poly2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Poly <span class="title function_">negPoly</span><span class="params">(Poly poly)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>值得一提的两个问题：</p>
<ul>
<li><strong>mono的属性设置</strong>，虽说这一次作业只有三个变量xyz，但是我们要做好下一次作业就不一定了的迭代的空间。所以我们想到，一个项可以由<strong>系数，变量及其对应的指数</strong>来表示，所以系数可以作为<strong>一个单独的属性</strong>，变量和对应的指数我们可以通过<strong>HashMap</strong>&lt; String, Integer &gt;来管理。</li>
<li>另一个关于<strong>Poly运算方法的克隆问题</strong>，如果像我一样采取static方法来实现运算的话，我们需要保证<strong>尽量不改变</strong>传入的两个对象参数，所以我们若要采取新建一个对象，则一定需要对<strong>传入的参数进行深克隆</strong>，<strong>不然不是很安全，容易出问题</strong>。</li>
</ul>
</li>
<li><p>最后，我们只需要在Poly和Mono类中<strong>实现toString()</strong>的方法，然后<strong>Poly.toString()中递归的调用Mono.toString()</strong>就行了，然后注意要<strong>卷性能分</strong>的话就得好好在这里输出了，比如<strong>特判系数或者指数为1时</strong>，隐藏，不输出。</p>
</li>
</ul>
<h3 id="testing-数据制造（军备竞赛）-amp-自动化测试"><a href="#testing-数据制造（军备竞赛）-amp-自动化测试" class="headerlink" title="testing 数据制造（军备竞赛）&amp; 自动化测试"></a>testing 数据制造（军备竞赛）&amp; 自动化测试</h3><blockquote>
<p>wj老师：人脑是有极限的，不可能在写代码的时候就把所有的情况都考虑到，所以测试很有必要<br>我：自动化测试对于无论是<strong>自己测试</strong>，还是<strong>刀人</strong>，都及其有意义（doge保命</p>
</blockquote>
<ul>
<li>一部分数据可以手搓，对于上文中整理的<strong>坑点</strong>，一个一个的<strong>对应着造出数据</strong>来，看看自己有没有问题，还可以对<strong>一些边界情况造出来</strong>，这是能够填补自动化测试的空白的。<ul>
<li>比如：0，9999999e50（这个数据就刀中了人，虽然不是我刀的（泪）），—-0，。。。。</li>
</ul>
</li>
<li>自动化测试的数据生成策略也可以按照文法通过<strong>递归下降来构造</strong>，<strong>概率生成不同的元素</strong>。</li>
<li>python有可以<strong>检测表达式是否相等</strong>的库可以调用，命令行输入 <code>pip install sympy</code><ul>
<li>我们检测结果的正确性只需要检查<strong>是否有括号</strong>&amp;<strong>表达式相等</strong>即可。</li>
<li>至于性能分析，<strong>没有参照，暂时没办法做</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>自动化测试由zbygg（佬！）和我一起完成，<strong>zbygg完成了data，simplify，getTest框架的搭建。（zbygg应该也会出博客，大家可以到移步友链，后续我会把它加入到Reference</strong><br>我的贡献主要是<strong>递归去除了嵌套的括号</strong>，加上了不断的<strong>循环测试</strong>，<strong>脚本化</strong>，以及后期刀人阶段的<strong>数据增强</strong>。</p>
</blockquote>
<ul>
<li>生成<strong>数据的大致架构</strong>如下（至于导出jar包测试，python表达式包的使用，循环测试，脚本化，请问度娘或者chatgpt）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用这个全局标志来消除嵌套括号的影响</span></span><br><span class="line">hasBrackets = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指数（0~8）可修改概率分布，可以想想怎么调整概率分布会更难，我的选择是，两头多，中间少</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_index</span>():</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机整数，可以包含前导零，这个也得加一定的概率分布，不然数据太过随机，我这里也是两头多，中间少</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_int</span>():</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成带符号整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_signed_int</span>():</span><br><span class="line">    sign + rand_int()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成幂函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_power</span>():</span><br><span class="line">    base + space + index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成表达式因子</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_expr_factor</span>():</span><br><span class="line">    <span class="keyword">global</span> hasBrackets</span><br><span class="line">    hasBrackets = <span class="literal">True</span></span><br><span class="line">    expr = rand_expr()</span><br><span class="line">    hasBrackets = <span class="literal">False</span> <span class="comment"># 这里能够消除嵌套括号，想想为啥</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &lt; <span class="number">0.4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + expr + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + expr + <span class="string">&#x27;) &#x27;</span> + index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成常数因子或变量因子</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_const_or_var</span>():</span><br><span class="line">    <span class="keyword">if</span> random...:</span><br><span class="line">        <span class="keyword">return</span> rand_signed_int()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rand_power()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成因子，这里的...的取值可以调整数据的难度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_factor</span>():</span><br><span class="line">    <span class="keyword">if</span> ran_num &lt; ... <span class="keyword">and</span> <span class="keyword">not</span> hasBrackets: <span class="comment"># 消括号操作</span></span><br><span class="line">        <span class="keyword">return</span> rand_expr_factor()</span><br><span class="line">    <span class="keyword">elif</span> ran_num &lt; ...:</span><br><span class="line">        <span class="keyword">return</span> rand_signed_int()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rand_power()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成项</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_term</span>():</span><br><span class="line">    final_term = rand_factor()</span><br><span class="line">    <span class="keyword">for</span>:</span><br><span class="line">        final_term = final_term + <span class="string">&quot;*&quot;</span> + space + rand_factor()</span><br><span class="line">    <span class="keyword">return</span> op + final_term</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数，生成表达式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rand_expr</span>():</span><br><span class="line">    term = rand_term()</span><br><span class="line">    <span class="keyword">return</span> term + <span class="string">&#x27; &#x27;</span> + op + space + rand_term()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_expr</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        expr = rand_expr()</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(expr) &lt; ...: <span class="comment"># 填上你想要的最短数据长度</span></span><br><span class="line">            expr += <span class="string">&#x27; &#x27;</span> + rand_term()</span><br><span class="line">        f.write(expr + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>自动化造军火效果如下（有种<strong>挖矿的美</strong><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83Expr-expansion1.0/hack-test.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83Expr-expansion1.0/hack-test.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="auto-hacker 1.0"></li>
</ul>
<p><a name="reference"></a></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.runoob.com/regexp/regexp-tutorial.html">菜鸟教程：正则表达式</a></li>
<li><a href="https://blog.csdn.net/songtianlun/article/details/115496022">CSDM：三步激活 StarUML V4.0.1 (WIN10) | 仅供学习</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/109655171">知乎：30分钟学会UML类图</a></li>
<li><a href="https://hyggge.github.io/2022/03/24/oo/oo-di-yi-dan-yuan-zong-jie/">学长的博客：Poly运算类的灵感来源，推荐一看</a></li>
<li>zbygg的博客：（害没有，关注友链<a href="https://augetyvolta.github.io/">AugetyVolta’s Blog</a>，有了的话第一时间放上来</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>表达式</tag>
        <tag>第一单元</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】Expr_expansion2.0</title>
    <url>/2023/03/10/BUAA-OO-Expr-expansion2-0/</url>
    <content><![CDATA[<p>北航面向对象与程序设计课程作业，表达式展开Expr-expansion 2.0，对1.0的迭代开发。<br>新增需求：嵌套括号，三角函数，自定义函数</p>
<span id="more"></span>
<h1 id="BUAA-OO-hw2"><a href="#BUAA-OO-hw2" class="headerlink" title="BUAA-OO hw2"></a>BUAA-OO hw2</h1><h2 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h2><ul>
<li>多层括号（已完成</li>
<li>三角函数因子</li>
<li>自定义函数因子，自定义函数不会复合（但是要做好<strong>迭代的准备</strong></li>
</ul>
<h2 id="形式化表述"><a href="#形式化表述" class="headerlink" title="形式化表述"></a>形式化表述</h2><p>表达式 → 空白项 [加减 空白项] 项 空白项 | 表达式 加减 空白项 项 空白项<br>项 → [加减 空白项] 因子 | 项 空白项 ‘*‘ 空白项 因子<br>因子 → 变量因子 | 常数因子 | 表达式因子<br>变量因子 → 幂函数 | 三角函数 | 自定义函数调用<br>常数因子 → 带符号的整数<br>表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]<br>幂函数 → 自变量 [空白项 指数]<br>自变量 → ‘x’ | ‘y’ | ‘z’<br>三角函数 → ‘sin’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数] | ‘cos’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数]<br>指数 → ‘**‘ 空白项 [‘+’] 允许前导零的整数 (注：指数一定不是负数)<br>带符号的整数 → [加减] 允许前导零的整数<br>允许前导零的整数 → (‘0’|’1’|’2’|…|’9’){‘0’|’1’|’2’|…|’9’}<br>空白项 → {空白字符}<br>空白字符 → （空格） | \t<br>加减 → ‘+’ | ‘-‘</p>
<p>自定义函数定义 → 自定义函数名 空白项 ‘(‘ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项]] ‘)’ 空白项 ‘=’ 空白项 函数表达式<br>自定义函数调用 → 自定义函数名 空白项 ‘(‘ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项]] ‘)’<br>自定义函数名 → ‘f’ | ‘g’ | ‘h’<br>函数表达式 → 表达式 (注：本次作业中函数表达式保证不会调用自己或其他自定义函数)</p>
<blockquote>
<p>老规矩，空白字符对我们已经构不成威胁，所以我们去除空白字符，然后去除基元，简单表示。</p>
</blockquote>
<ul>
<li><p>下面是省流版的形式化表示(<strong>与上次的不同已加粗</strong>)</p>
</li>
<li><p>Expr    -&gt; [±] Term    | Expr ‘±’ Term</p>
</li>
<li>Term    -&gt; [±] Factor  | Term ‘*‘ Factor</li>
<li>Factor  -&gt; <strong>Variable</strong> | ConNum | ExprFactor</li>
<li><strong>Variable-&gt; PowFunc | TriFunc | DefFunc</strong></li>
<li>PowFunc -&gt; indepVar index</li>
<li>ConNum  -&gt; [±] Num</li>
<li>ExpFac  -&gt; ‘(‘ Expr ‘)’ index</li>
<li><strong>TriFunc -&gt; ‘sin’ ‘(‘ Factor ‘)’ index | ‘cos’ ‘(‘ Factor ‘)’ index</strong></li>
<li><p><strong>DefFunc -&gt; (‘f’|’g’|’h’) ‘(‘ Factor[<em>\times</em> 3] ‘)’</strong></p>
<ul>
<li><strong>(‘f’|’g’|’h’) ‘(‘ indepVar[<em>\times</em> 3] ‘)’ = Expr</strong></li>
</ul>
</li>
<li><p>Num     -&gt; ( 0 ~ 9 ) { 0 ~ 9 }</p>
</li>
<li>indepVar-&gt; (‘x’ | ‘y’ | ‘z’)</li>
<li>index   -&gt; [‘**‘ [‘+’] Num]</li>
</ul>
<h2 id="分析需求-amp-坑点汇总"><a href="#分析需求-amp-坑点汇总" class="headerlink" title="分析需求&amp;坑点汇总"></a>分析需求&amp;坑点汇总</h2><ul>
<li>展开括号以及<strong>自定义函数</strong></li>
<li>尽可能短</li>
</ul>
<h3 id="关于三角函数"><a href="#关于三角函数" class="headerlink" title="关于三角函数"></a>关于三角函数</h3><ul>
<li>三角函数里的x**2一定要注意，如果直接修改为x*x要加括号，但是<strong>显然不好</strong>。<ul>
<li>就是说要注意TriFunc里面是<strong>Factor</strong></li>
</ul>
</li>
<li>三角函数除了展开内部的因子外，如何化简？</li>
<li>三角函数：<ul>
<li>判断相等：<ul>
<li>重载<strong>hashcode比较</strong>。</li>
<li>判断因子的<strong>poly相等</strong>。</li>
<li><strong>字符串</strong>排序对比。</li>
</ul>
</li>
<li>化简：<ul>
<li>cos(0),sin(0)</li>
<li>同类项合并。</li>
<li>平方项合并。(博主没时间做，只实现了最简单的合并)</li>
<li>倍角合并</li>
<li>先都把倍角展开成一倍角，再进行合并，最后进行化简</li>
<li>cos里有个负号可以省去，注意cos(-1), cos((-1))的不同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于函数定义与调用"><a href="#关于函数定义与调用" class="headerlink" title="关于函数定义与调用"></a>关于函数定义与调用</h3><ul>
<li>怎么储存函数的定义？<strong>存字符串</strong>还是<strong>存表达式</strong>？</li>
<li>怎么解决函数的调用问题，需要一个新的函数类，在<strong>构造的时候</strong>解决函数调用的问题？或者说在<strong>toPoly的时候</strong>解决掉调用的问题？</li>
<li>函数：<ul>
<li>定义：正则表达式分成两份。一份字符串处理，另一份<strong>表达式打表储存</strong>。<ul>
<li>在处理函数定义的时候，只记录形式参数的位置，就用uvw替换掉乱序的xyz。（<strong>可以这么去考虑</strong>，也可以建立起形参实参彼此之间的关系</li>
</ul>
</li>
<li>调用：<ul>
<li>方法一：<strong>字符串替换</strong>，但是得加上括号作为表达式，兼顾x**2中用y**2替换x的问题（我不是这么实现的，<strong>不丁真，而且不推荐</strong></li>
<li>方法二：扫到形参调用实参的Factor，每个类都加上substitute的方法，<strong>递归调用</strong>，最后都把自变量替换为表达式因子（也不一定是表达式因子，可以有其他的调用）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="uml类图及简述"><a href="#uml类图及简述" class="headerlink" title="uml类图及简述"></a>uml类图及简述</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion2.0/uml.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion2.0/uml.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="uml"></p>
<ul>
<li>以上是我本次作业的类图（只放出了核心的方法与关系</li>
<li>我继承自第一次作业的架构，其中分为了三个纵向的层次结构，parse层次，Expr层次，Poly层次</li>
<li>其中比较亮点的地方在于toPoly，toString，substitute，deepClone等方法，我均通过<strong>上层调用下一层的递归实现</strong>，体现了层次化的思想。</li>
<li>具体细节请看下文。</li>
</ul>
<h3 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h3><ul>
<li>首先要强调的一点仍然是parser的实现，我们需要规定调用时，lexer指在要处理位置；退出调用时，lexer停在处理完的位置（Term调因子的时候）。这样在能过统一上层调用的实现。</li>
<li>然后就是在Expr类的设置上，我<strong>新增DefFunc类与TriFunc类</strong>实现Factor的接口（注意虽然在形式化的表述上Factor是他俩的爷爷辈，但是Variable符号并没有被整体引用过，所以让他俩直接实现Factor也是一样的）</li>
<li>然后就是关于Poly类的兼容问题，第二次作业中新增了三角函数类，所以Poly的最终形式中会多出来三角函数的item所以我<strong>将Mono改名Item</strong>，并将其<strong>一分为二</strong>，下设<strong>MonoItem与TriItem</strong>，但是他们内部的权限开到最高，只是为了方便输出与合并而已（做出了一个违背祖宗的决定。</li>
<li>化简的最终形式应该是 $\Sigma ConNum<em>x^a</em>y^b<em>z^c</em>\Pi \sin(Factor)^{d_i} * \Pi \cos(Factor)^{e_j} $ 所以Item的属性如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//item的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MonoItem monoItem;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;TriItem&gt; triItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>下面具体实现三件事：<ul>
<li><strong>函数定义与调用，深克隆，三角函数化简</strong></li>
</ul>
</li>
</ul>
<h4 id="函数定义与调用的实现"><a href="#函数定义与调用的实现" class="headerlink" title="函数定义与调用的实现"></a>函数定义与调用的实现</h4><ul>
<li><strong>函数定义</strong>，新建静态类FuncDefinition<ul>
<li>睿睿说：在函数定义的时候把第一二三个位置的形参都换成u，v，w，这样我就不需要考虑实参和xyz的对应关系了<ul>
<li>俺觉得<strong>很有道理</strong>。</li>
</ul>
</li>
<li>但是要直接字符串替换要考虑<strong>后续迭代</strong>中的冲突问题，如果后续添加的函数中包含xyz，uvw等字符，那就需要换或者另找办法了<ul>
<li>所以为了可拓展性，我还是修改了策略，传入实参后，弄一个<strong>hashmap形成形参实参的映射</strong>。</li>
</ul>
</li>
<li>而关于存字符串还是存表达式的问题，由于我的函数调用的实现是substitute()方法的<strong>递归调用替换</strong>，另外为了性能效率(每一次用表达式还得重新Parse一遍)，<strong>构造Def对象时</strong>就展开成表达式。后续<strong>直接调用</strong>即可（但是得<strong>注意深克隆</strong>，毕竟静态函数表中的表达式我们不可以去改变他）。</li>
</ul>
</li>
<li>关于<strong>函数调用</strong>：<ul>
<li>要代入的话，Expr这些类就需要对外提供<strong>查询修改</strong>的接口，要尽量对外隐藏细节，我只能把形参传入，然后递归的调用下去了。我在每个类都设置了substitute的方法，递归调用，直到Factor层面（Factor有返回值Factor），遇到在实参形参映射表中的变量就替换（所以我们知道<strong>调用的叶节点</strong>就是<strong>PowFunc和ConNum</strong>）</li>
</ul>
</li>
<li>关于<strong>调用的返回值</strong>，可以一劳永逸的套个<strong>带指数的ExprFactor</strong>（但是这样会增加递归调用层数，增大代价以及debug的难度），也可以<strong>分情况返回不同的Factor</strong>，如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以分情况写成：</span></span><br><span class="line"><span class="type">Factor</span> <span class="variable">defFactor</span> <span class="operator">=</span> varMap.get(varName).deepClone();</span><br><span class="line"><span class="keyword">if</span> (defFactor <span class="keyword">instanceof</span> ConstNum)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstNum</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (defFactor <span class="keyword">instanceof</span> PowFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowFunc</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (defFactor <span class="keyword">instanceof</span> ExprFactor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExprFactor</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (defFactor <span class="keyword">instanceof</span> DefFunc) &#123;</span><br><span class="line">    <span class="comment">//DefFunc可以转化为ExprFactor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExprFactor</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (defFactor <span class="keyword">instanceof</span> TriFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TriFunc</span>();</span><br><span class="line">&#125;       </span><br><span class="line"><span class="comment">//也可以一劳永逸的写成</span></span><br><span class="line"><span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Expr</span>();</span><br><span class="line"><span class="type">Term</span> <span class="variable">term</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Term</span>();</span><br><span class="line">term.addFactor(varMap.get(varName).deepClone());</span><br><span class="line">expr.addTerm(term);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExprFactor</span>(expr, index);</span><br></pre></td></tr></table></figure>
<h4 id="关于深克隆的实现"><a href="#关于深克隆的实现" class="headerlink" title="关于深克隆的实现"></a>关于深克隆的实现</h4><ul>
<li>深克隆很重要，函数调用一定要使用深克隆，所以我们需要在类中提前实现深克隆的方法</li>
<li>不过深克隆也可以采取递归的结构来克隆类中的<strong>每一个属性</strong>。</li>
<li>最后的<strong>叶节点也会是PowFunc与ConNum</strong>。</li>
<li>相信不会很难，按部就班写好即可。</li>
</ul>
<h4 id="三角函数的存放与化简"><a href="#三角函数的存放与化简" class="headerlink" title="三角函数的存放与化简"></a>三角函数的存放与化简</h4><ul>
<li>先写出toPloy的方法。</li>
<li>然后需要写一个<strong>判断Poly相等</strong>的方法，来实现三角函数合并。<ul>
<li>判断因子相等，有两个方法，一个是调用factor.equals，另一个是调用Poly.equals</li>
<li>equals的方法也是<strong>递归的实现</strong>。</li>
</ul>
</li>
<li>若加入三角函数化简公式，在<strong>addpoly与multipoly</strong>中改即可（item中处理维度不高）。可以添加item中的方法使poly获取到mono|tri的信息然后<strong>判断是否可以合并</strong>。</li>
<li>判定三角函数里是否需要括号的准则是不出现不在poly.toString首的正负号，可以用<strong>字符串匹配</strong><ul>
<li>但是有误，后来换成<strong>判断Poly中的元素个数</strong>（更加的可靠</li>
</ul>
</li>
</ul>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><ul>
<li>第二次作业这一周太忙了，本来不打算弄自动化测试的，但是得到了睿睿的帮助（大家可以移步友链<a href="https://toby-shi-cloud.github.io">toby’s Bolg</a>），睿睿负责了<strong>评测</strong>，我设计了<strong>数据生成</strong>器。</li>
<li>第二次的数据生成器并不能像第一次那样<strong>无脑</strong>的随机递归下降，如果这样，生成的数据的<strong>复杂度直接起飞</strong>，但是又不能卡定生成概率，让数据变得很弱。</li>
<li>所以我有一点核心设计是增加了<strong>一个（或者几个）全局的难度指标</strong>，随着难度的增加去<strong>影响不同分支的生成概率</strong>。设计示意如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ran_num = random.random()</span><br><span class="line"><span class="keyword">if</span> ran_num &lt; <span class="number">0.25</span> - <span class="number">0.03</span>*difficulty:</span><br><span class="line">    difficulty += <span class="number">1</span></span><br><span class="line">    rand_expr_factor()</span><br><span class="line"><span class="keyword">elif</span> ran_num &lt; <span class="number">0.40</span> + <span class="number">0.03</span>*difficulty:</span><br><span class="line">    rand_signed_int()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    rand_var_factor()</span><br></pre></td></tr></table></figure>
<ul>
<li>另外还有用全局标记来影响<strong>下一个生成分支中的生成概率</strong>的设计，这主要解决的是，<strong>函数定义的复杂度</strong>与<strong>表达式的复杂度之间</strong>有差异，函数调用的<strong>实参因子的复杂度不宜过高</strong>的这些问题。设计的大致示意如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expr_used = <span class="literal">True</span></span><br><span class="line">expr = rand_expr()</span><br><span class="line">expr_used = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="第二次作业的问题总结"><a href="#第二次作业的问题总结" class="headerlink" title="第二次作业的问题总结"></a>第二次作业的问题总结</h2><ul>
<li>在第二次作业的这一周里，博主忙东忙西，每天睡眠时间平均4小时不到，其中OO的代码我熬了一晚上优化，但是优化坏了，而且<strong>代码风格遭到了严重的破坏</strong>（这告诉我们<strong>一定要规律作息</strong>，不要熬夜打代码！！！</li>
<li>不过我也感谢我急急忙忙的第二次作业的经历，在第二次的跨越式迭代之后，我对于层次化的理解又更近了一步。并且我在第二次作业过后再来审视我的石山代码，<strong>得到了不少的教训</strong>。</li>
<li>优化了许多，最后形成了ExprExpansion2.1(EE2.1)，具体请看下一次博客。</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>表达式</tag>
        <tag>第一单元</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】Expr_expansion3.0_and_2.1</title>
    <url>/2023/03/10/BUAA-OO-Expr-expansion3-0-and-2-1/</url>
    <content><![CDATA[<p>北航面向对象与程序设计课程作业，表达式展开Expr-expansion 3.0，对2.1的迭代开发。<br>插曲：对2.0的代码风格进行美化及debug。形成Expr-expansion 2.1。<br>新增需求：自定义函数嵌套，求导。<br>这一次的博客主要是向大家展示架构，就不做过多的细节论述了，相信大家经过前几次的迭代，已经具备了一定的结构抽象的能力，不必局限于具体的细节呈现了。</p>
<span id="more"></span>
<h1 id="hw3-log"><a href="#hw3-log" class="headerlink" title="hw3_log"></a>hw3_log</h1><h2 id="对hw-2的教训的整理以及策略的变化（2-1）"><a href="#对hw-2的教训的整理以及策略的变化（2-1）" class="headerlink" title="对hw_2的教训的整理以及策略的变化（2.1）"></a>对hw_2的教训的整理以及策略的变化（2.1）</h2><ul>
<li>使用<strong>泛型</strong>写<strong>静态方法</strong>对于ArrayList容器进行<strong>不考虑顺序判等</strong>（我把这个作为静态方法放置在MainClass中。</li>
<li>当然已经有不少同学在第三次的作业中开始使用<strong>HashMap高效率的索引合并</strong>，这种方法值得借鉴。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isCollectionMatch</span><span class="params">(Collection&lt;T&gt; list1, Collection&lt;T&gt; list2)</span> &#123;</span><br><span class="line">    <span class="comment">//pre - judge</span></span><br><span class="line">    <span class="keyword">if</span> (list1 == list2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1.size() != list2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//judge</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; list1Clone = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1);</span><br><span class="line">    <span class="keyword">for</span> (T item:</span><br><span class="line">         list2) &#123;</span><br><span class="line">        Iterator&lt;T&gt; iterator = list1Clone.iterator();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">listEq</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.equals(iterator.next())) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                listEq = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!listEq) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//all_match</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hw2的失败来自于在<strong>poly部分的计算复杂化</strong>以及<strong>toPoly.toString()的复用</strong>（大家一定要保持良好的代码风格呀！！！<ul>
<li>每一次的toPoly都是一次巨大的开销，我还去反复调用（（</li>
<li>因为toString的方法里也会调用toPoly，所以我们也需要<strong>去除toString的重复调用</strong></li>
<li>我为了优化打了许多的特判，然后代码风格上出现了问题（我在每一个判断的<strong>if条件语句</strong>中重复调用了toPoly或者toString的方法，导致性能开销极大。<ul>
<li>所以我去掉了条件里的重复调用，只用了一个toPoly()，如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//before optimize</span></span><br><span class="line"><span class="keyword">if</span> (factor.toPoly().toString().equals(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (factor.toPoly().toString().equals(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//after optimize</span></span><br><span class="line"><span class="type">String</span> <span class="variable">factorStr</span> <span class="operator">=</span> factor.toPoly().toString();</span><br><span class="line"><span class="keyword">if</span> (factorStr.equals(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (factorStr.equals(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//一定要引以为戒呜呜呜</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>我的Poly包与Expr包之间要有一个比较明显的<strong>界限分离</strong>，即在Poly类中不应该再调用类的toPoly的方法，也不应该含有Expr包的属性。在Expr中，也只在最后才使用到toPoly的方法。</p>
<ul>
<li>类与类之间的<strong>数据太共享</strong>不是一个好事！！！</li>
<li>所以我把三角函数的单独元TriItem中存入一个 <strong>factorPoly=factor.toPoly()</strong> 作为属性，而不是以factor作为属性（这其实也解决了我的上一个问题。</li>
</ul>
</li>
<li><p>然后就是对于Poly类中的二元运算，因为需要<strong>避免改变传入值的值</strong>，所以我每一次运算都会进行一次深克隆</p>
<ul>
<li>所有的二元运算的静态方法都变成了<strong>改变this的一元运算</strong>，防止每一次都深克隆带来巨大的开销。（只需要保证方法不改变传入值即可</li>
</ul>
</li>
<li><p>ExprExpansion2.1是一次在代码风格上的巨大升级，优化后的代码行数直接由2.0的1300多行来到了1100多行</p>
</li>
<li>而且在优化以后，方法的复杂度大大降低，详细见下图（只给出复杂度超标的方法）：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE2.0.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE2.0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EE2.0"></li>
<li>优化后：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE2.1.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE2.1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EE2.1"></li>
<li>EE2.0(ExprExpansion2.0)的时候那些用到了<strong>ArrayList判等的Equals方法</strong>全都暴雷，原因就是<strong>重复造了很多轮子</strong>。</li>
<li>其余的复杂度也有所下降。</li>
</ul>
<h2 id="hw3新增需求"><a href="#hw3新增需求" class="headerlink" title="hw3新增需求"></a>hw3新增需求</h2><ul>
<li>自定义函数定义中可以包含自定义函数（保证不会递归调用）和求导算子（先求导后代入）（既任意因子）</li>
<li>表达式增加<strong>求导算子</strong>（最多<strong>只能出现一次</strong>,也就是不会有高阶导）</li>
</ul>
<h2 id="形式化表述"><a href="#形式化表述" class="headerlink" title="形式化表述"></a>形式化表述</h2><ul>
<li>详细的形式化表述就不给出了，变化就是因子增加了求导因子，然后自定义函数中可以调用自定义函数</li>
<li><p>下面是省流版：</p>
</li>
<li><p>Expr    -&gt; [±] Term    | Expr ‘±’ Term</p>
</li>
<li>Term    -&gt; [±] Factor  | Term ‘*‘ Factor</li>
<li>Factor  -&gt; Variable | ConNum | ExprFactor | <strong>Deriv</strong></li>
<li>Variable-&gt; PowFunc | TriFunc | DefFunc</li>
<li>PowFunc -&gt; indepVar index</li>
<li>ConNum  -&gt; [±] Num</li>
<li>ExpFac  -&gt; ‘(‘ Expr ‘)’ index</li>
<li>TriFunc -&gt; ‘sin’ ‘(‘ Factor ‘)’ index | ‘cos’ ‘(‘ Factor ‘)’ index</li>
<li>DefFunc -&gt; (‘f’|’g’|’h’) ‘(‘ Factor[<em>\times</em> 3] ‘)’<ul>
<li>(‘f’|’g’|’h’) ‘(‘ indepVar[<em>\times</em> 3] ‘)’ = Expr</li>
</ul>
</li>
<li><p><strong>Deriv   -&gt; operator ‘(‘ Expr ‘)’</strong></p>
<ul>
<li><strong>operator -&gt; d indepVar</strong></li>
</ul>
</li>
<li><p>Num     -&gt; ( 0 ~ 9 ) { 0 ~ 9 }</p>
</li>
<li>indepVar-&gt; (‘x’ | ‘y’ | ‘z’)</li>
<li>index   -&gt; [‘**‘ [‘+’] Num]</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="uml类图以及简述"><a href="#uml类图以及简述" class="headerlink" title="uml类图以及简述"></a>uml类图以及简述</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE3uml.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE3uml.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EE3uml"></p>
<ul>
<li>第三次的迭代<strong>跨度不是很大</strong>，架构比较完整合适的话基本上半天能够码完</li>
<li>但是毕竟三次迭代过去了，我把完整类图放出来应该问题也不大的，但是我发现可能有点乱了，所以加了一些颜色做了<strong>横向层次上的区分</strong>（图可以放大看。</li>
<li>除了纵向的递归的层次之外，从类图中我们可以明显的看出，分为<strong>解析类，表达式类，化简多项式类</strong>。</li>
<li>三者之间结构的关系相信1.0和2.0的博客已经说的很清楚了，这里就不再赘述了。<ul>
<li>我们面临的主要问题是如何按照<strong>开闭原则</strong>最小修改的对这次的程序迭代开发：</li>
<li>这一次的博客主要是向大家<strong>展示架构</strong>，就不做过多的细节论述了。</li>
</ul>
</li>
</ul>
<h3 id="迭代需求实现的细节"><a href="#迭代需求实现的细节" class="headerlink" title="迭代需求实现的细节"></a>迭代需求实现的细节</h3><h4 id="函数调用函数的问题"><a href="#函数调用函数的问题" class="headerlink" title="函数调用函数的问题"></a>函数调用函数的问题</h4><ul>
<li>我先实现函数调用调用自定义函数的问题<ul>
<li>关键还是在DefFunc类中也<strong>实现substitute的方法</strong>。（这应该是这个接口的共同的方法，</li>
<li>但是我们<strong>不需要对Def类中的实参也进行实参的替换</strong>，因为在构造DefFunc时，我就已经将其中的函数全都替换成了表达式，所以我们要做的工作仅仅只是调用Expr.substitute()！非常的简单。<ul>
<li>所以这样，在函数定义完之后，函数类的核心的<strong>属性是它展开后的表达式</strong>，函数定义表里面就<strong>不会出现嵌套函数</strong>这个东西了（皮都展开了，什么叫做远见明察呀</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Factor <span class="title function_">substitute</span><span class="params">(HashMap&lt;String, Factor&gt; varMap)</span> &#123;</span><br><span class="line">    defExpr.substitute(varMap);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求导的实现"><a href="#求导的实现" class="headerlink" title="求导的实现"></a>求导的实现</h4><ul>
<li>我认为求导的实现<strong>和函数调用相似</strong>，每个类里都有一个求导的方法derivate()（但是具体实现上有点区别，比如考虑到<strong>Term的乘法求导法则</strong>，我们让它的derivate方法返回一个ArrayList&lt; Term &gt;<ul>
<li>然后像函数调用一样递归的调用求导方法，解析展开成一个表达式</li>
</ul>
</li>
<li><strong>不要</strong>想把DefFunc这种的derivate的返回值设成表达式因子，没必要，返回自己怎么啦。<ul>
<li>不要考虑覆写的问题，本来就是一种转换，本来后面不需要用到原版，本来就是一种覆写。</li>
<li>最后都要toPoly，反倒是返回表达式因子会让你在debug的时候十分的难受。</li>
</ul>
</li>
<li>最后的重担落在了<strong>幂函数和三角函数</strong>的身上，为了实现链式求导法则以及幂函数求导的常数等需求，我们使<strong>Factor的derivate方法返回Term</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    Factor <span class="title function_">substitute</span><span class="params">(HashMap&lt;String, Factor&gt; varMap)</span>;</span><br><span class="line"></span><br><span class="line">    Term <span class="title function_">derivate</span><span class="params">(String varName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一定要注意<strong>链式法则与乘法法则的深克隆问题</strong>，不然连着给你改了。</li>
</ul>
<h4 id="结构上的统一性解读"><a href="#结构上的统一性解读" class="headerlink" title="结构上的统一性解读"></a>结构上的统一性解读</h4><ul>
<li>所以其实在结构里，DefFunc，ExprFactor，Deriv都是统一的，他们<strong>内部都有一个Expr属性</strong>，除了生成方法不一致之外，其他都可以比较趋同的实现。对于DefFunc和Deriv我<strong>在构造的时候已经做好了表达式的展开</strong>，保证方法来的时候我的表达式已经准备好了。<ul>
<li>（结构中已经有了两种趋同，一种是<strong>求导方法和代入方法的趋同</strong>（生成方法上的趋同），另一种是上述<strong>三个类在结构实现上的趋同</strong></li>
</ul>
</li>
<li>第三种趋同是<strong>链式求导法则数学的统一性</strong>上，不需要特判是否有指数，表达式因子三角函数因子和变量因子按照链式法则求的方法是有一致性的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Term <span class="title function_">derivate</span><span class="params">(String varName)</span> &#123;</span><br><span class="line">    <span class="type">Term</span> <span class="variable">newTerm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Term</span>();</span><br><span class="line">    <span class="comment">//加入常数，变量名不同，当常数处理</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span> || !varName.equals(<span class="built_in">this</span>.varName)) &#123;</span><br><span class="line">        newTerm.addFactor(<span class="keyword">new</span> <span class="title class_">ConstNum</span>(BigInteger.ZERO, <span class="string">&quot;+&quot;</span>));</span><br><span class="line">        <span class="comment">//指数为0就是常数求导</span></span><br><span class="line">        <span class="keyword">return</span> newTerm;</span><br><span class="line">    &#125;</span><br><span class="line">    newTerm.addFactor(<span class="keyword">new</span> <span class="title class_">ConstNum</span>(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(index)), <span class="string">&quot;+&quot;</span>));</span><br><span class="line">    <span class="comment">//指数减1，加入原函数</span></span><br><span class="line">    index -= <span class="number">1</span>;</span><br><span class="line">    newTerm.addFactor(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> newTerm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gt-但是我有一个问题，链式求导法则的方法大致趋同，需不需要单独设立一个链式法则求导的方法呢，欢迎在评论区探讨！"><a href="#gt-但是我有一个问题，链式求导法则的方法大致趋同，需不需要单独设立一个链式法则求导的方法呢，欢迎在评论区探讨！" class="headerlink" title="&gt; 但是我有一个问题，链式求导法则的方法大致趋同，需不需要单独设立一个链式法则求导的方法呢，欢迎在评论区探讨！"></a>&gt; 但是我有一个问题，链式求导法则的方法大致趋同，需不需要单独设立一个链式法则求导的方法呢，欢迎在评论区探讨！</h2><blockquote>
<p>这次的自动化评测机也只是在前两代的基础上小改一下下，所以就不说了。</p>
</blockquote>
<h2 id="三次迭代架构的度量分析"><a href="#三次迭代架构的度量分析" class="headerlink" title="三次迭代架构的度量分析"></a>三次迭代架构的度量分析</h2><h3 id="码量上"><a href="#码量上" class="headerlink" title="码量上"></a>码量上</h3><ul>
<li>首先最为直观的肯定是<strong>代码行数上的变化</strong>，反映了<strong>代码的规模</strong>，<strong>类的规模</strong>。(首先声明每次作业的代码风格分都是满分</li>
<li>请见下表：</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/Lines.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/Lines.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Lines"></p>
<ul>
<li>首先可以看到，我用<strong>浅红色标出的EE2.0</strong>(ExprExpansion)，代码的长度极其的灾难，其中Item类更是达到了250行左右，但是经过优化之后的EE2.1代码行数上正常了许多。</li>
<li>最后的<strong>码量落到了1300左右</strong>。</li>
</ul>
<h3 id="复杂度上"><a href="#复杂度上" class="headerlink" title="复杂度上"></a>复杂度上</h3><ul>
<li>然后就是方法的复杂度分析（只选取了<strong>部分关键的方法以及复杂度超标的方法</strong>）</li>
<li>下面是对指标的解释：</li>
</ul>
<blockquote>
<p>CogC 是<strong>圈复杂度</strong>的意思，与下面的v(G)一样<br>v(G) 是<strong>圈复杂度</strong>，表示程序中独立路径的数量，也就是测试程序所需的最少路径条数。圈复杂度越大，说明程序越复杂，越容易出错，越难测试和维护。<br>iv(G) 是<strong>模块设计复杂度</strong>，表示程序中结构化程度的高低。模块设计复杂度越大，说明程序越不符合结构化设计原则，越难理解和修改。<br>ev(G) 是<strong>基本复杂度</strong>，表示程序中非结构化成分的多少。非结构化成分指的是那些不遵循顺序、选择、循环三种基本控制结构的语句或语句块。基本复杂度越大，说明程序越不规范，越降低了代码质量和可读性。</p>
</blockquote>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/metrics_metrics.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/metrics_metrics.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="method metrics"></p>
<ul>
<li>下面是EE3.0中<strong>复杂度超标</strong>的部分：</li>
</ul>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE3.0.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OO/ExprExpansion3.0/EE3.0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EE3.0"></p>
<ul>
<li>我们可以看到，对于圈复杂度，只有<strong>Lexer.next()</strong>方法与<strong>TriItem.toString()</strong>超标，<ul>
<li>对于next()的方法实现，因为我是<strong>一次输出一个相对完整的字符串</strong>，所以我需要调用其他的一些方法来达成模块化设计的需求。</li>
<li>而对于TriItem.toString()的方法中，我为了许多细节的化简优化，比如说输出括号、去除符号等，打了<strong>许多的特判</strong>，所以圈复杂度会很高。</li>
</ul>
</li>
<li>但是可以看到，许多方法的<strong>基本复杂度还是挺糟糕的</strong>，这也说明了我的<strong>代码质量与风格</strong>确实有比较大的问题（这也导致了<strong>EE2.0的缺陷</strong>），接下来还是得在这一方面多下功夫。</li>
<li>可喜的是我的模块设计复杂度都比较的良好，这也得<strong>益于良好的架构</strong>与<strong>合适的方法属性设置</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>表达式</tag>
        <tag>第一单元</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OS】lab0_linux基础</title>
    <url>/2023/03/10/BUAA-OS-lab0-linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>BUAA-OS lab0实验报告，关于Linux的基础，shell脚本编程，git的知识，Makefile项目管理</p>
<span id="more"></span>
<h1 id="lab0实验报告"><a href="#lab0实验报告" class="headerlink" title="lab0实验报告"></a>lab0实验报告</h1><h2 id="实验思考题"><a href="#实验思考题" class="headerlink" title="实验思考题"></a>实验思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><blockquote>
<p>Thinking 0.1 思考下列有关 Git 的问题：<br>• 在前述已初始化的 ~/learnGit 目录下，创建一个名为 README.txt 的文件。执行命令 git status &gt; Untracked.txt。<br>• 在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令git status &gt; Stage.txt。<br>• 提交 README.txt，并在提交说明里写入自己的学号。<br>• 执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会 README.txt 两次所处位置的不同。<br>• 修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。<br>• 执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是否一样，并思考原因。</p>
</blockquote>
<ul>
<li>在刚开始第一个<code>git status</code>时，效果如下，但是因为我已经将README.txt文件提交过了，所以并不在未跟踪的文件里<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/1Untracked.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/1Untracked.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Untracked"></li>
<li>添加内容进readme中然后<code>git add README.txt</code>，此时文件在状态为Staged，位置在暂存区（而若已修改未提交则应该在工作区），下一步是commit<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/1Stage.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/1Stage.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Stage"></li>
<li>已修改未提交的文件则应该在工作区，状态为Modified，我们仍需要用<code>git add README.txt</code>将其更新。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/1Modified.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/1Modified.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Modified"></li>
</ul>
<h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><blockquote>
<p>Thinking 0.2 仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？</p>
</blockquote>
<ul>
<li>add the file: 用<code>git add</code>将未跟踪的文件添加进暂存区，状态Staged</li>
<li>stage the file: 用<code>git add</code>将已修改的文件加入缓存区，状态也是Staged</li>
<li>commit: 用<code>git commit</code>将暂存区内容提交储存区，文件不在暂存区，回到了Unmodified状态。</li>
</ul>
<h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><blockquote>
<p>Thinking 0.3 思考下列问题：<br>1.代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？<br>2.代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？<br>3.无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下<br>将其移出暂存区？</p>
</blockquote>
<ul>
<li>只是删除了工作区的print.c文件，可以使用<code>git checkout -- print.c</code>将其从暂存区拉回。</li>
<li>而删除后再执行<code>git rm print.c</code>指令会将其从暂存区中也删除，但是我们能将其从版本库中再次找回<ul>
<li>使用<code>git reset HEAD</code>将暂存区重置到与上一次commit一致，然后与上面操作一致。</li>
<li>也可以使用<code>git checkout HEAD print.c</code>使得分支中的文件直接替换工作区以及暂存区的文件。</li>
</ul>
</li>
<li>无关文件hello.txt在暂存区中，我们可以通过<code>git rm --cached hello.txt</code>将其在暂存区删除，而不改变本地文件。<ul>
<li>也可以使用<code>git rm -f hello.txt</code>将其强制都删除（暂存区and工作区</li>
</ul>
</li>
</ul>
<h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><blockquote>
<p>Thinking 0.4 思考下列有关 Git 的问题：<br>• 找到在/home/21xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存<br>在则新建该文件。<br>• 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。<br>• 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。<br>• 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为<br>3 的哈希值a。<br>• 进行版本回退。执行命令 git reset —hard HEAD^后，再执行 git log，观<br>察其变化。<br>• 找到提交说明为 1 的哈希值，执行命令 git reset —hard &lt; hash&gt; 后，再执<br>行 git log，观察其变化。<br>• 现在已经回到了旧版本，为了再次回到新版本，执行 git reset —hard &lt; hash&gt;<br>，再执行 git log，观察其变化。</p>
</blockquote>
<ul>
<li>我们可以在下面的图看到过程，收获就是版本回退的时候，版本库中的新版本并没有消失，因为我们还能够再通过hashCode回到新版本。</li>
<li>HEAD代表当前版本，HEAD\^代表上一个版本，HEAD\^\^代表上两个版本，以此类推。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/4.0.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/4.0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="q4"></li>
</ul>
<h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><blockquote>
<p>Thinking 0.5 执行如下命令, 并查看结果<br>• echo first<br>• echo second &gt; output.txt<br>• echo third &gt; output.txt<br>• echo forth &gt;&gt; output.txt</p>
</blockquote>
<p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/5.1.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab0/5.1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5.1演示"></p>
<h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><blockquote>
<p>Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问题:<br>echo echo Shell Start 与 echo ‘echo Shell Start’效果是否有区别; echo echo<br>$ c &gt; file1 与 echo ‘echo $c&gt;file1’效果是否有区别.</p>
</blockquote>
<ul>
<li>要创造test文件里的这些命令，需要将每一条命令都使用echo指令，输出到test文件中<ul>
<li>大致的指令如下：<code>echo &quot;echo Shell Start...&quot;</code>用双引号引起来。然后运行command脚本，即可得到一个test文件</li>
<li>然后我们运行test文件，通过命令内容我们可以知道脚本的功能是将a，b赋值为1，2让c=a+b然后将cba的值依次存到file123中，然后将file123的值输入到file4中，然后将file4的值输入到result中，所以result的结果会是1，2，3</li>
</ul>
</li>
<li>关于加引号与不加引号的区别，在第一对命令之间没有区别。</li>
<li>而第二对命令中，不加引号的会按照语法执行这个命令，将echo $c输入到file1文件里。带单引号的将会将引号内的内容当作字符串原封不动的输出在标准输出中。若要想让$c变量发挥作用，则应该使用双引号””</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="Exercise-0-1"><a href="#Exercise-0-1" class="headerlink" title="Exercise 0.1"></a>Exercise 0.1</h3><ul>
<li>第一问就不难了，大一C语言基础题</li>
<li>第二问：<code>target</code>是<code>palindrome</code>，<code>demand</code>是<code>palindrome.c</code>我们需要写的就只有一个指令<code>gcc palindrome.c -o palindrome</code></li>
<li>第三问：因为是输出指定行的操作，我们可以使用sed，输出指定内容的选项是’-n’，然后输出第k行，输入为AAA文件，重定向到BBB，我们可以使用<code>sed -n &#39;kp&#39; AAA &gt; BBB</code>指令。<ul>
<li>但注意AAA BBB是脚本的传入参数，所以在文件中用<code>$1 $2</code>表示</li>
<li>再另外因为是覆盖，所以我们使用<code>&gt;</code>而不是<code>&gt;&gt;</code></li>
</ul>
</li>
<li>复制操作就不多说</li>
</ul>
<h3 id="Exercise-0-2"><a href="#Exercise-0-2" class="headerlink" title="Exercise 0.2"></a>Exercise 0.2</h3><ul>
<li>涉及到脚本编程的循环结构</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i=start_num</span><br><span class="line"><span class="keyword">while</span> (( <span class="variable">$i</span> &lt;= end_num ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        i = $((i+<span class="number">1</span>)) | <span class="built_in">let</span> i=i+1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li>两个操作都可以这么去做</li>
</ul>
<h3 id="Exercise-0-3"><a href="#Exercise-0-3" class="headerlink" title="Exercise 0.3"></a>Exercise 0.3</h3><ul>
<li>根据题目的提示，我们可以使用<code>grep -n</code>指令进行查找并显示行号，用<code>awk</code>实现分离行号输出</li>
<li>也要注意文件名查找词作为参数输入。</li>
<li>因为<code>grep</code>的输出作为<code>awk</code>的输入，我们可以使用管道指令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="variable">$2</span> <span class="variable">$1</span> | awk -F: <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> &gt; <span class="variable">$3</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise-0-4"><a href="#Exercise-0-4" class="headerlink" title="Exercise 0.4"></a>Exercise 0.4</h3><ul>
<li>第一问是字符串替换，我没很容易能够想到使用<code>sed</code>指令，但有许多需要注意的地方<ul>
<li>比如我们能够想到<code>&#39;s\reg\str&#39;</code>的命令实现替换，但是我们需要用到<code>&#39;s\reg\str\g&#39;</code>，如果不加g则只会替换每行第一个匹配。</li>
<li>输入<code>sed &#39;s\char\int\g $1&#39;</code>到脚本，运行，然后发现根本没换，这里有个问题，就是在脚本文件中，单引号’’代表纯字符串，所以没有功能性，我们在这里需要用双引号””<ul>
<li>可以试试在脚本中<code>echo &#39;$1&#39;</code>和<code>echo &quot;$1&quot;</code>的输出来对比。</li>
</ul>
</li>
<li>最后输入<code>sed &quot;s\$2\$3\g $1&quot;</code>发现文件没有变化，原因是忘了<code>sed -i</code></li>
</ul>
</li>
<li>第二问有几个难点，一点是Make的循环调用<ul>
<li>主要用到<code>make -C</code>的方法，以及我们也可以使用<code>make clean -C</code></li>
<li>但是我打好码之后发现了报错，fibo.h的头文件没有找到，因为他在<code>../include</code>里所以我们需要gcc链接的指令<code>gcc -I 路径</code></li>
<li>最后，关于清除所有的.o文件，我们可以采用路径的通配符<code>*.o</code></li>
</ul>
</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><ul>
<li>lab0主要考察了关于git、Makefile、gcc、shell常用命令及脚本编程的基础，我认为考察还是十分全面的，收获满满。<ul>
<li>暂时不太可能记住很多的命令，所以需要学会自己查资料，要善于man指令或者—help的帮助。<ul>
<li>另一点我觉得一定要细心且规范，遵照着规矩来，计算机没有二义性。</li>
</ul>
</li>
<li>明白了c语言转化为可执行文件的底层原理<ul>
<li>学会了使用gcc的命令编译c语言文件</li>
</ul>
</li>
<li>更加了解了git的使用，对其中的操作的原理也有了更多的理解</li>
<li>学会了一个项目的Makefile的写法，相当于是掌握了一门新的工具了</li>
<li>最后就是觉得对于操作系统文件系统运行的原理有了一定的接触和感受（作为用户及程序员的角度）。Linux里Everything is files。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BUAA操作系统</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OS</tag>
        <tag>Linux</tag>
        <tag>git</tag>
        <tag>C语言</tag>
        <tag>Makefile</tag>
        <tag>shell</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OS】lab2-内存管理</title>
    <url>/2023/04/02/BUAA-OS-lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>BUAA-OS lab2实验报告，关于mos系统的内存管理机制的实现，内存初始化，二级页表，TLB重填等内容。</p>
<span id="more"></span>
<h1 id="lab2-log"><a href="#lab2-log" class="headerlink" title="lab2_log"></a>lab2_log</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking2-1"><a href="#Thinking2-1" class="headerlink" title="Thinking2.1"></a>Thinking2.1</h3><blockquote>
<p>Thinking 2.1 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？</p>
</blockquote>
<ul>
<li>都是虚拟地址，因为CPU只会发出虚拟地址，虚拟地址都需要经过映射才会得到物理地址。</li>
</ul>
<h3 id="Thinking2-2"><a href="#Thinking2-2" class="headerlink" title="Thinking2.2"></a>Thinking2.2</h3><blockquote>
<p>Thinking 2.2 请思考下述两个问题：<br>• 从可重用性的角度，阐述用宏来实现链表的好处。<br>• 查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中用的双向链表，分析三者在插入与删除操作上的性能差异。</p>
</blockquote>
<ul>
<li>使用宏定义对链表的操作进行封装，提高了代码的可重用性，提高了可读性。</li>
<li>单项链表只能获取每一项的后一项，所以在某项前插入与删除的操作只能从头开始遍历链表，但可以在后一项直接插入。</li>
<li>循环链表删除插入性能与单向链表一致，但是由于有尾部指针，所以在最后一项上插入开销小。</li>
<li>双向链表在某项前后的插入操作以及对某项的删除操作都只有O(1)的开销。</li>
</ul>
<h3 id="Thinking2-3"><a href="#Thinking2-3" class="headerlink" title="Thinking2.3"></a>Thinking2.3</h3><blockquote>
<p>Thinking 2.3 请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</p>
</blockquote>
<ul>
<li>我选择C结构，Page_list的结构体中有一个指向表头的指针，然后每一个页的项由一个包含两个指针的pp_link与一个表示索引次数的pp_ref表示。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">        u_short pp_ref;</span><br><span class="line">    &#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Thinking2-4"><a href="#Thinking2-4" class="headerlink" title="Thinking2.4"></a>Thinking2.4</h3><blockquote>
<p>Thinking 2.4 请思考下面两个问题：<br>• 请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。<br>• 请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。</p>
</blockquote>
<ul>
<li>address identifier必要性：在操作系统中，同一虚拟地址在不同的地址空间中会映射到不同的物理地址上，每个进程会有自己的虚拟地址空间，所以需要用ASID来区别改虚拟地址是在哪个进程中。</li>
<li>ASID在EntryHi中占了6位，所以最大可以容纳64个地址空间。</li>
</ul>
<h3 id="Thinking2-5"><a href="#Thinking2-5" class="headerlink" title="Thinking2.5"></a>Thinking2.5</h3><blockquote>
<p>Thinking 2.5 请回答下述三个问题：<br>• tlb_invalidate 和 tlb_out 的调用关系？<br>• 请用一句话概括 tlb_invalidate 的作用。<br>• 逐行解释 tlb_out 中的汇编代码。</p>
</blockquote>
<ul>
<li>tlb_invalidata调用了tlb_out。</li>
<li>在页表内容改变后删除它在TLB中的旧表项。</li>
<li>tlb_out代码如下：</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line"><span class="meta">.set</span> <span class="keyword">noreorder</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI</span><br><span class="line">        <span class="keyword">mtc0 </span>   <span class="built_in">a0</span>, CP0_ENTRYHI</span><br><span class="line">        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">tlbp</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">mfc0 </span>   <span class="built_in">t1</span>, CP0_INDEX</span><br><span class="line"><span class="meta">.set</span> reorder</span><br><span class="line">        <span class="keyword">bltz </span>   <span class="built_in">t1</span>, NO_SUCH_ENTRY</span><br><span class="line"><span class="meta">.set</span> <span class="keyword">noreorder</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYHI</span><br><span class="line">        <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO0</span><br><span class="line">        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">tlbwi</span></span><br><span class="line"><span class="keyword"></span><span class="meta">.set</span> reorder</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">NO_SUCH_ENTRY:</span></span><br><span class="line">        <span class="keyword">mtc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI</span><br><span class="line">        <span class="keyword">j </span>      <span class="built_in">ra</span></span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure>
<ul>
<li>tlb_out由tlb_invalidate调用，主要作用就是清空TLB表项。</li>
<li>首先将cp0_entryHI的原来的值存在t0寄存器中，我们看后面可以知道主要是为了找不到的时候恢复原样用的。</li>
<li>然后就是把a0这个传入的参数写入cp0_entryHI随后用tlbp查找，得到索引值，如果大于等于0，就是找到了。</li>
<li>然后我们就可以将cp0_entryHI和cp0_entryLO都置为0，最后用tlbwi将值写到index位置的tlb里，达到清零的目的。</li>
</ul>
<h3 id="Thinking2-6"><a href="#Thinking2-6" class="headerlink" title="Thinking2.6"></a>Thinking2.6</h3><blockquote>
<p>Thinking 2.6 任选下述二者之一回答：<br>• 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。<br>• 简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</p>
</blockquote>
<ul>
<li>理论课上提到了x86的内存管理机制，x86架构采用的是段页式管理机制，mips采用页式管理。</li>
<li>而且x86的页映射机制是可选的，可以通过CR0寄存器的PG位来设置。</li>
<li>除了段式的差别之外，x86的页式内存管理也与mips的有所不同，对于TLB不命中的处理机制上，mips会触发异常后TLB重填，然后第二次访问。而x86会直接索引CR3得到页目录基址，得到目标的PFN，然后再来重填TLB。</li>
</ul>
<h3 id="ThinkingA-1"><a href="#ThinkingA-1" class="headerlink" title="ThinkingA.1"></a>ThinkingA.1</h3><blockquote>
<p>Thinking A.1 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。<br>现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：<br>• 三级页表页目录的基地址。<br>• 映射到页目录自身的页目录项（自映射）。</p>
</blockquote>
<ul>
<li>三级页表页目录的基地址为： $PT_{base} +  PT_{base} &lt;&lt; 9 + PT_{base} &lt;&lt; 18$</li>
<li>映射到页目录自身的页表项： $PT_{base} +  PT_{base} &lt;&lt; 9 + PT_{base} &lt;&lt; 18 + PT_{base} &lt;&lt; 27 $</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><ul>
<li>这次主要要操作的文件为include/queue.c与kern/pmap.c，但同时，我们离不开include/mmu.h与include/pmap.h中定义的宏。</li>
</ul>
<h3 id="Exercise2-1-2-5"><a href="#Exercise2-1-2-5" class="headerlink" title="Exercise2.1-2.5"></a>Exercise2.1-2.5</h3><ul>
<li>这里主要需要完成内核初始化mips_init()中的两个函数</li>
<li>mips_detect_memory()</li>
<li><p>page_init()</p>
</li>
<li><p>主要利用BY2PG宏，定义在mmu.h中，代表页面的大小。</p>
</li>
<li><p>然后就是实现双向链表宏，为后续做准备。</p>
</li>
<li><p>理解Page结构体的引导的链表项，指向的应该是物理空闲页的页号，通过pmap.h中的两个函数page2pa与pa2page完成于物理页面号与物理地址之间的转换。</p>
</li>
<li><p>然后就是完成管理物理内存的四个函数</p>
</li>
<li>page_init, page_alloc, page_decref, page_free</li>
</ul>
<h3 id="Exercise2-6-2-7"><a href="#Exercise2-6-2-7" class="headerlink" title="Exercise2.6-2.7"></a>Exercise2.6-2.7</h3><ul>
<li>这里主要就是虚拟内存管理的结构，我们要实现一个两级页表，一级页目录(PD)，一级页表(PT)，可以用PDX(va)和PTX(va)来获取一个虚拟地址的页目录号和页表号，即第31-22位与第21-12位。</li>
<li>用Pde与Pte来表示页目录项及页表项。其实就是u_long。</li>
<li>MOS的满页不会置换，而是直接报错。</li>
<li>pgdir_walk函数的功能是完成页目录项到页表项的映射。</li>
<li>page_insert函数完成的是建立起页表与实际页控制块对应的物理页面的映射。</li>
</ul>
<h3 id="Exercise2-8-2-10"><a href="#Exercise2-8-2-10" class="headerlink" title="Exercise2.8-2.10"></a>Exercise2.8-2.10</h3><ul>
<li>TLB重填，指导书说的挺清楚的，看懂mips的汇编代码就好了~</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><ul>
<li>相较于lab1，lab2难度上增加很大，首先就是课下实验花费了大量的时间，但是很多地方还是不理解，我觉得最主要的还是先理解理论知识，得要先学会二级页表的寻址的规则，自映射的规则，不然会很难看懂源代码的意思。而且还有许多宏定义，一定要确保看过源代码，知道这个宏的用途。所以工作量还是很大的，但还是给自己留下了一点教训吧，os还是真的必须重视理论，这是一切的基础！而且得花时间！</li>
</ul>
]]></content>
      <categories>
        <category>BUAA操作系统</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OS</tag>
        <tag>内存管理</tag>
        <tag>页式存储</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OS】lab1_内核，启动，printf</title>
    <url>/2023/03/16/BUAA-OS-lab1-%E5%86%85%E6%A0%B8%EF%BC%8C%E5%90%AF%E5%8A%A8%EF%BC%8Cprintf/</url>
    <content><![CDATA[<p>BUAA-OS lab1实验报告，关于elf，mos系统内核结构，系统启动流程，和printf函数的实现。</p>
<span id="more"></span>
<h1 id="lab1-log"><a href="#lab1-log" class="headerlink" title="lab1_log"></a>lab1_log</h1><h2 id="一个关于ssh权限的小插曲"><a href="#一个关于ssh权限的小插曲" class="headerlink" title="一个关于ssh权限的小插曲"></a>一个关于ssh权限的小插曲</h2><ul>
<li>我按照OS的教程配置本地连接实验的跳板机，但是在配置好ssh的config之后到ssh连接这一步出现了问题，报错<code>bad ownership</code>。</li>
<li>在同学助教的帮助下发现.ssh文件夹的权限开大了反而有问题，应该开小一点，打开属性，点击安全，把权限<strong>删到只剩下用户</strong>就行。</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking1-1"><a href="#Thinking1-1" class="headerlink" title="Thinking1.1"></a>Thinking1.1</h3><blockquote>
<p>Thinking 1.1 请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</p>
</blockquote>
<ul>
<li>我们知道C语言从源代码到可执行文件需要四个步骤，<strong>预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</strong>，分别通过命令<code>gcc -E/S/c/I</code>来完成。我的复现过程如下：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.1.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.1"></li>
<li>通过<code>man objdump</code>我们知道，其中objdump传递的-DS(disassemble source)的意义是将后面传入的<strong>所有文件的section反汇编</strong>并输出结果（而且大写的S的意义是将<strong>反汇编的代码与原有机器码一同显示</strong>），但是我们将其重定向至另一个文件中，结果如下（<strong>只放出了main函数</strong>）：</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接前：</span></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line"><span class="symbol">   0:</span>	f3 <span class="number">0</span>f <span class="number">1</span>e fa          	endbr64 </span><br><span class="line"><span class="symbol">   4:</span>	<span class="number">55</span>                   	push   %rbp</span><br><span class="line"><span class="symbol">   5:</span>	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line"><span class="symbol">   8:</span>	<span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	lea    <span class="number">0x0</span>(%rip),%rax        <span class="comment"># f &lt;main+0xf&gt;</span></span><br><span class="line">   f:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line"><span class="symbol">  12:</span>	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	call   <span class="number">17</span> &lt;main+<span class="number">0x17</span>&gt;</span><br><span class="line"><span class="symbol">  17:</span>	<span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">1</span>c:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">  <span class="number">1</span>d:	c3                   	ret    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接后：</span></span><br><span class="line"><span class="number">0000000000001149</span> &lt;main&gt;:</span><br><span class="line"><span class="symbol">    1149:</span>	f3 <span class="number">0</span>f <span class="number">1</span>e fa          	endbr64 </span><br><span class="line">    <span class="number">114</span>d:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">    <span class="number">114</span>e:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line"><span class="symbol">    1151:</span>	<span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> ac <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> 	lea    <span class="number">0xeac</span>(%rip),%rax        <span class="comment"># 2004 &lt;_IO_stdin_used+0x4&gt;</span></span><br><span class="line"><span class="symbol">    1158:</span>	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line">    <span class="number">115</span>b:	e8 f0 fe ff ff       	call   <span class="number">1050</span> &lt;puts@plt&gt;</span><br><span class="line"><span class="symbol">    1160:</span>	<span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"><span class="symbol">    1165:</span>	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line"><span class="symbol">    1166:</span>	c3                   	ret   </span><br></pre></td></tr></table></figure>
<ul>
<li>虽然我们生成的程序是x86的，但是我们能够明显的看出来，我们最后比较未链接的反汇编文件与完整编译后的反汇编文件中，原本出现printf函数的位置，<strong>地址从0变成了一段有意义的地址</strong>。</li>
<li>当然，我们也可以通过<strong>readelf指令</strong>来看两个可执行文件之间的节头表的差异这里就先不再展示了。</li>
</ul>
<h3 id="Thinking1-2"><a href="#Thinking1-2" class="headerlink" title="Thinking1.2"></a>Thinking1.2</h3><blockquote>
<p>Thinking 1.2 思考下述问题：<br>• 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。<br>• 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</p>
</blockquote>
<ul>
<li>我们自己实现的readelf函数的作用是输出<strong>ELF文件中所有节头的地址</strong>，我用它来解析target目录下的内核，产生的结果如下：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.2.1.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.2.1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.2.1"></li>
<li>readelf目录下的Makefile中，它们俩分别长这样: （hello文件被编译成了<strong>32位</strong><br><img src="/.io//1.2.2.png" class="lazyload placeholder" data-srcset="/.io//1.2.2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.2.2"></li>
<li>而我的尝试确实也表明readelf无法解析本身但是readelf命令可以：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.2.3.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.2.3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.2.3"></li>
<li>我们也用readelf命令来解析第一问中我们可以用自己的readelf解析的内核文件，发现结果如下：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.2.4.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/BUAA-OS/lab1/1.2.4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.2.4"></li>
<li>比较两个的结果，除地址上的不同外，只有系统架构不一致，所以我认为原因是：是我们自己实现的readelf<strong>不能解析x86-64架构</strong>的文件。</li>
</ul>
<h3 id="Thinking1-3"><a href="#Thinking1-3" class="headerlink" title="Thinking1.3"></a>Thinking1.3</h3><blockquote>
<p>Thinking 1.3 在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？<br>（提示：思考实验中启动过程的两阶段分别由谁执行。）</p>
</blockquote>
<ul>
<li>系统启动分为两个阶段，分别在ROM或FLASH上和RAM上执行，然后在ROM上的系统引导程序Bootloader会<strong>将Stage2的代码复制到RAM上</strong>，并<strong>跳转</strong>至入口函数（也就是<strong>内核入口</strong>），所以只要Bootloader跳转正确，内核放置在哪无所谓。</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="Exercise-1-1"><a href="#Exercise-1-1" class="headerlink" title="Exercise 1.1"></a>Exercise 1.1</h3><ul>
<li>主要是要补全readelf的c程序，它的功能是输出ELF文件中所有节头所在的地址，所以做这一题的核心是理解<strong>节头表的结构原理</strong>，以及<strong>看懂elf.h中结构体的意思</strong>。</li>
<li>我们从ehdr这个结构体的代码中可以知道，节头表的偏移、节头项的数目、每个节头项的大小。</li>
<li>所以我们只需要获得节头表的首地址，然后在它的基础上累加，对于得到的每一项，需要注意的是我们仅仅只得到了表项，也就是一个Elf32_Shdr的示例，我们需要访问结构体的sh_addr属性获得最终的地址。即：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(sh_table + i*sh_entry_size).sh_addr</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-1-2"><a href="#Exercise-1-2" class="headerlink" title="Exercise 1.2"></a>Exercise 1.2</h3><ul>
<li>第二道题的难点主要在于<strong>理解内核的节的结构</strong>，并<strong>通过Linker Script建立起链接</strong>。</li>
<li>剩下的比较的简单，按照题中给的示例及include/mmu.h 中的<strong>内存布局图</strong>做就行</li>
</ul>
<h3 id="Exercise-1-3"><a href="#Exercise-1-3" class="headerlink" title="Exercise 1.3"></a>Exercise 1.3</h3><ul>
<li>.S文件代表汇编文件，所以需要用汇编写出。</li>
<li>只需要填写两行代码：</li>
<li>首先建立起栈，将sp移动到初始栈顶的位置，看<strong>内存布局图</strong>我们知道，在0x8040_0000，所以可以用<code>lui</code>指令赋值。</li>
<li>然后就是跳转，由于跳转之后<strong>不用再回退</strong>，所以用<code>j</code>指令即可。</li>
</ul>
<h3 id="Exercise-1-4"><a href="#Exercise-1-4" class="headerlink" title="Exercise 1.4"></a>Exercise 1.4</h3><ul>
<li>然后就到了最具难度的一题：实现一个printk函数，最主要的是看懂指导书中关于<strong>几个关联的库的关系</strong>，还是比较清晰的。</li>
<li>但是关于<strong>变长参数</strong>这一块，我本来还有点看不太懂（可能是我的问题），这里需要重点辨析的是传入的fmt指针，指向的是栈的最后一个参数（栈顶地址），由于压栈是从右向左压，所以最后一个参数就是形式化字符串，而ap的意义就是后面的参数表，只是需要初始化，以及通过<code>va_arg(va_list ap, 类型)</code>去访问。</li>
<li>另外最重要的是指导书并没有详细给出我们需要在print.c中做的工作，所以一定要<strong>先看懂源代码再开始补全！！！</strong>（这可能也是指导书信息不对称的考虑吧，因为看懂源码的能力还是挺重要的，移植或补全别的东西可不会有指导书教你）</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><ul>
<li>本次实验核心内容就是<strong>通过elf了解内核的结构以及它的形成</strong>，<strong>掌握思考系统启动的流程</strong>，<strong>完成一个printk的函数</strong>。</li>
<li>这是MOS操作系统运行起来的基础，大体上做到了与<strong>理论课程</strong>的内容相匹配，收获颇多。</li>
<li>另外感慨的就是读懂源码的能力了，这个上面已经感慨过了，总之就是十分的重要（<strong>read the F**king source code</strong>！）</li>
</ul>
]]></content>
      <categories>
        <category>BUAA操作系统</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OS</tag>
        <tag>elf</tag>
        <tag>系统启动</tag>
        <tag>printf实现</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-OO】pre_Summary</title>
    <url>/2022/09/10/OO-pre-Summary/</url>
    <content><![CDATA[<p>常见styleCheck报错改进合集，git相关知识，在题解过程中了解java语法以及面向对象知识</p>
<span id="more"></span>]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>pre</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-做一个简单的shell</title>
    <url>/2023/04/15/OS-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shell/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>blog配置教程</title>
    <url>/2022/09/06/blog%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>【BUAA-OO】pre学习笔记</title>
    <url>/2022/10/21/oo-pre%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>上ly老师的OOPre课所做的一些笔记，用cpp为载体比较系统的讲解了面向对象的三大特征（封装、继承、多态），可以作为了解这方面知识的开始，但记录较为繁杂，我后续会持续做整理补充。</p>
<span id="more"></span>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A better C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array, pointer,function,struct,macro</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//封装</span></span><br><span class="line"><span class="comment">//#progma pack(1)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">int</span> j;<span class="comment">//内存对齐</span></span><br><span class="line">    <span class="type">char</span> ch:<span class="number">1</span>;<span class="comment">//位结构</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//统一控制宏，#define 。。。</span></span><br><span class="line"><span class="comment">//#ifdef ... #else ... #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*c++调用c函数</span></span><br><span class="line"><span class="comment">    extern &quot;C&quot;&#123;</span></span><br><span class="line"><span class="comment">    void md5();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载overloading</span></span><br><span class="line"><span class="comment"> void print(int);</span></span><br><span class="line"><span class="comment"> void print(char*);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*default parameter</span></span><br><span class="line"><span class="comment"> void fun(int a,int b,int c=3);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//exception处理 throw(int),抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类中的参数可以用不传地址的函数修改，原理是用了this指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆区栈区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static&amp;extern</span></span><br></pre></td></tr></table></figure>
<h2 id="0913"><a href="#0913" class="headerlink" title="0913"></a>0913</h2><ul>
<li><p>堆区栈区：堆区：malloc new的空间</p>
</li>
<li><p>static:</p>
<ul>
<li>一次构造和全局变量一起析构；</li>
<li>只能本文件使用，链接器链接不到；</li>
<li>类里，用于共享内存，不能在构造函数初始化；</li>
<li>类中函数static修饰后，可以直接用类名调用</li>
</ul>
</li>
<li>总结: static把对象的变量变成了类的变量</li>
<li>extern链接器指令<ul>
<li>全局函数自带extern</li>
</ul>
</li>
<li>声明vs定义</li>
<li>引用，安全版指针，消除了两个问题，野指针问题和半路指岔<br>如何理解向上转型和多态，多态的触发条件是重写</li>
</ul>
<h2 id="0920"><a href="#0920" class="headerlink" title="0920"></a>0920</h2><ul>
<li>设计模式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何构造一个对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;    <span class="comment">//拷贝构造（clone），深拷贝、浅拷贝</span></span><br><span class="line"><span class="comment">//会崩溃，浅拷贝只拷贝了指针地址，而同一块空间不能delete两次.</span></span><br><span class="line"><span class="comment">//所以不能clone指针</span></span><br><span class="line"><span class="comment">//下面是深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t);</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = t.i;</span><br><span class="line">    <span class="comment">//this-&gt;p = t.p;</span></span><br><span class="line">    <span class="keyword">this</span> -&gt; p = <span class="keyword">new</span> <span class="built_in">Test</span>(*t.p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line"><span class="comment">//使用指针的常见错误</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. 野指针</span></span><br><span class="line"><span class="comment">* 2. 内存泄漏</span></span><br><span class="line"><span class="comment">* 3. 重复释放</span></span><br><span class="line"><span class="comment">* 4. 返回局部变量的地址</span></span><br><span class="line"><span class="comment">* 5. 类似浅拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//free</span></span><br><span class="line"><span class="comment">//free(p);</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;<span class="comment">//不可重现错误，a的内存没有再分配那就还是10</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="comment">//解决上一个问题，但是有新问题，p不记得delete</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="built_in">memcpy</span>()浅拷贝</span><br><span class="line"><span class="built_in">clone</span>()和<span class="built_in">putAll</span>()都是只对于built_in类型深克隆</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>C追求的是运行的高效，java追求的是编程的高效</p>
</li>
<li><p>继承</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inheritance</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//implement</span></span><br><span class="line">interface A &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> implements A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const与函数返回值的关系</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">fun</span>()++ &lt;&lt; endl;</span><br><span class="line"><span class="comment">//error:fun()是l-value，常量；</span></span><br><span class="line"><span class="comment">//对于built-in type有效（如 int）</span></span><br><span class="line"><span class="comment">//但对于自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参pass by value         vs          pass by address(pointer &amp; reference)</span></span><br><span class="line"><span class="comment">//功能  read                vs          read/write</span></span><br><span class="line"><span class="comment">//性能  低效(sizeof obj)    vs          高效(sizeof int)</span></span><br><span class="line"><span class="comment">//其他  可能是拷贝构造       vs         nothing</span></span><br><span class="line"><span class="comment">//never passby value(对于自定义变量)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于拷贝构造</span></span><br><span class="line"><span class="type">const</span> Test &amp;t <span class="comment">//这样传参可以保证函数对t只读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const对于类</span></span><br><span class="line"><span class="type">const</span> Test t;</span><br><span class="line">t.<span class="built_in">fun</span>() <span class="comment">//error: 编译器认为你可能在fun里改变自己的内存</span></span><br><span class="line"><span class="comment">//所以得这样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="0927"><a href="#0927" class="headerlink" title="0927"></a>0927</h2><ul>
<li>操作符重写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">int</span> id, <span class="type">int</span> balance);</span><br><span class="line">    Account&amp; <span class="keyword">operator</span>+(<span class="type">int</span> money);</span><br><span class="line">    Account&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    Account <span class="keyword">operator</span>++(<span class="type">int</span>);    <span class="comment">//硬传参</span></span><br><span class="line">&#125;</span><br><span class="line">Account&amp; Account::<span class="keyword">operator</span>+(<span class="type">int</span> money)&#123;</span><br><span class="line">    <span class="keyword">this</span>.balance += money;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Account Account::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="function">Account <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span> -&gt; balance++</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">Account&amp; Account::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; balance ++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>new/delete</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new vs malloc</span></span><br><span class="line"><span class="comment">//new = malloc + construct</span></span><br><span class="line"><span class="comment">//delete = destruct + free  #注意顺序 delete解决申请的内存，free 解决申请内存的内存</span></span><br><span class="line"><span class="comment">//new是一个operator, 可以重写, 可以避免内存碎片化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>继承</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> cardId;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">//history</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BorrowBook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="type">int</span> cardId;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承就是共性与特性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类对父类的重写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">super.<span class="built_in">fun1</span>();<span class="comment">//java</span></span><br><span class="line">Base::<span class="built_in">fun1</span>();<span class="comment">//C++</span></span><br><span class="line"><span class="comment">//如果在子类中重写了父类的函数，98%的可能会出现super</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cpp可以多重继承<ul>
<li>所以不能使用super</li>
</ul>
</li>
<li>不能菱形继承</li>
</ul>
<h2 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h2><ul>
<li>子类的构造会调用父类的构造</li>
<li>析构同样</li>
<li>注意顺序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> m);</span><br><span class="line">&#125;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">int</span> m): <span class="built_in">j</span>(m),<span class="built_in">i</span>(j)&#123; <span class="comment">//这里会先定义i，再给j赋值，按定义的顺序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reuse</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;   <span class="comment">//虚函数，多态和后绑定 later binding 的必要条件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;   <span class="comment">//而且无论多少个虚函数一共占4byte（virtual table这是针对于类的，和对象没关系），virtual关键字自动继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Pet :: <span class="built_in">speak</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pet::speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Pet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Cat :: <span class="built_in">speak</span>()&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;miaomiao&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(Pet &amp;pet)</span></span>&#123;  <span class="comment">//  never pass by value</span></span><br><span class="line">    pet.<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;        <span class="comment">//upcasting,向上类型转换，所以子类不要削弱父类的接口。</span></span><br><span class="line">    <span class="built_in">handle</span>(cat);    <span class="comment">//???</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binding:将一次函数调用与函数入口相对性的一致</span></span><br><span class="line"><span class="comment">//代码区，函数（代码），常量，lib</span></span><br><span class="line"><span class="comment">//全局变量区：包括static，一次初始化，最后析构</span></span><br><span class="line"><span class="comment">//runtime memory:</span></span><br><span class="line"><span class="comment">//1. stack</span></span><br><span class="line"><span class="comment">//2. heap</span></span><br><span class="line"><span class="comment">//early binding</span></span><br><span class="line"><span class="comment">//later binding / runtime binding / dynamic binding</span></span><br><span class="line"><span class="comment">//有指针就没有private</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多态的实现<ul>
<li>虚函数表</li>
<li>虚指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的类型</span></span><br><span class="line"><span class="comment">//constructor: 构造不会用虚函数，不会有多态。</span></span><br><span class="line"><span class="comment">//destructor: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Test</span>(); <span class="comment">//这里需要多态，如果没有，在delete p时只会调~Test</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    ~<span class="built_in">Derived</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Test *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="built_in">fun</span>(derived);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>高级抽象！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象的越高级，就越无法描述</span></span><br><span class="line"><span class="comment">//所以</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//pure virtual(纯虚函数);</span></span><br><span class="line"><span class="comment">//一个类里面有一个纯虚函数，就是abstract class。</span></span><br><span class="line"><span class="comment">//抽象类不可被实例化，但可以被继承，子类通常要对其进行override，没有全部override的话，就是个半抽象</span></span><br><span class="line"><span class="comment">//纯虚函数可以有函数体，但通常没有</span></span><br><span class="line"><span class="comment">//抽象的作用：祖训，提纲挈领</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联(c++里叫抽象类，而java里叫interface)</span></span><br><span class="line"><span class="comment">//java不可以有多继承，但是可以实现多个接口（interface没有属性）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal . <span class="keyword">public</span> FlyObject&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Machine</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> : <span class="keyword">public</span> Machine . <span class="keyword">public</span> FlyObject&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(Bird &amp;bird)</span></span>&#123;    <span class="comment">//follow(FlyObject &amp;fO)</span></span><br><span class="line">    bird.<span class="built_in">fly</span>();             <span class="comment">//由于行为的共性，变得相关</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码重用的另一个拷贝形式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> pool[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::<span class="built_in">Stack</span>() :<span class="built_in">top</span>(<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pool[--top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    pool[top++] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">push</span>(i*i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要一个double的stack呢；</span></span><br><span class="line"><span class="comment">//constainer 容器</span></span><br><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    T pool[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    Stack&lt;<span class="type">double</span>&gt; doubleStack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++里有STL(standard template library)</span></span><br><span class="line"><span class="comment">//C++与java的区别：java有类库，自成体系，跨平台（用java runtime）</span></span><br><span class="line"><span class="comment">//C++与操作系统有关</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">//动态增长的万能容器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; v[<span class="number">10034</span>] &lt;&lt; endl;   <span class="comment">//[]运算符重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1018"><a href="#1018" class="headerlink" title="1018"></a>1018</h2><ul>
<li>template</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;     <span class="comment">//命名分割，防止命名重复</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyClass&#123;      <span class="comment">//一般放在头文件里</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass::Test test = <span class="built_in">new</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//iterator迭代器模式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != v.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;        <span class="comment">//这里的*，++也是运算符重载</span></span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="课程总结-OO-based-on-cpp"><a href="#课程总结-OO-based-on-cpp" class="headerlink" title="课程总结 OO based on cpp"></a>课程总结 OO based on cpp</h2><ul>
<li>封装<ul>
<li>struct、class</li>
<li>data+function</li>
<li>access control(private, public, protest)</li>
<li>this</li>
<li>construct/destruct stack/heap</li>
<li>reference/copy constructor</li>
<li>keyWord: static const </li>
</ul>
</li>
<li>继承<ul>
<li>共性与特性</li>
<li>多重继承（x）</li>
<li>不要削弱父类接口</li>
<li>构造顺序</li>
</ul>
</li>
<li>多态<ul>
<li>upcasting，传参</li>
<li>runtime binding 前绑定，后绑定</li>
<li>vitual v-table v-ptr</li>
<li>高级抽象：抽象类，接口（行为的共性）</li>
<li>template</li>
<li>性能问题出现前，不需要考虑性能</li>
</ul>
</li>
<li>真理导向，结果导向</li>
</ul>
<h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><ul>
<li>console控制台程序</li>
<li><p>两类：基于Form， 基于Web</p>
</li>
<li><p>win32 application</p>
</li>
<li>API应用程序开发接口</li>
</ul>
]]></content>
      <categories>
        <category>BUAA面向对象</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大二</tag>
        <tag>OO</tag>
        <tag>面向对象</tag>
        <tag>pre</tag>
      </tags>
  </entry>
  <entry>
    <title>welcome</title>
    <url>/2022/09/06/welcome/</url>
    <content><![CDATA[<p>欢迎来到volca’s blog_world，在这里大家可以讨论学习，侃侃大山，<del>发一发电</del>。初临blog，一定要看完这篇welcome，要有正确的打开方式喔。<br><strong>更新时间：2022-03-15</strong></p>
<span id="more"></span>
<h1 id="let’s-start"><a href="#let’s-start" class="headerlink" title="let’s start"></a>let’s start</h1><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><h3 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h3><ul>
<li>这里是大家合法<del>发电</del>的地方，不过也得请<strong>合理合法</strong>哈！</li>
<li>评论区用的是<a href="https://valine.js.org/">valine</a>，大家用QQ，微信等<strong>登录后</strong>就可以评论啦。</li>
<li>对文章内容有什么问题指正，或者对此类问题还有什么疑问的话，欢迎评论区留言（反正我不会，总有dalao会），我会尽量去回答你的问题！</li>
<li>博主尽可能在<strong>每一个界面</strong>都放了评论区，有任何问题请批评指正。</li>
<li>有问题也可以通过头像下的<strong>email</strong>私聊联系我。</li>
<li>水平有限，敬请谅解~</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul>
<li>搜索功能在左上角</li>
<li>博主用的是最便宜的搜索（hexo自带滴），所以功能可能有点简陋，但是应该也够用了。</li>
</ul>
<h3 id="分享功能（待上线。。。）"><a href="#分享功能（待上线。。。）" class="headerlink" title="分享功能（待上线。。。）"></a>分享功能（待上线。。。）</h3><ul>
<li>可以对于每一篇文章进行分享</li>
<li>支持微信qq等社交软件的分享</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>这一点可以结合着后面的<a href="#内容简介">内容简介</a>一起食用喔~</li>
<li>在这里<a href="http://volcaxiao.top/categories/">分类</a></li>
<li>分类的应该还是合理的，按需选取喔</li>
</ul>
<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><blockquote>
<p>这里主要就是一些内容分类以及具体的打开方式</p>
</blockquote>
<h3 id="北航信息类大一资料"><a href="#北航信息类大一资料" class="headerlink" title="北航信息类大一资料"></a>北航信息类大一资料</h3><ul>
<li>博主建博客时已是大二，没法对大一的知识再进行系统的梳理，所以把大一的时候<strong>整理的资料</strong>上传上来，学弟学妹们按需自取。</li>
<li>资料包括但不限于往年题的题与解析（想当年一个一个抠出来的）、课件、期末复习的总结资料。</li>
<li>内容应该还是挺全面的，个人认为。</li>
<li>形式是通过北航云盘链接上传（温知识，北航校园网用北航云盘不跑流量）。</li>
<li>在传资料的博客里还会有学长亲身经验分享，大家也可以辩证看待，多多思考。</li>
</ul>
<h2 id="工科高等代数"><a href="#工科高等代数" class="headerlink" title="工科高等代数"></a>工科高等代数</h2><ul>
<li>但是事情有所变化，博主今年有幸应聘上了学支中心的<strong>朋辈辅导师</strong>，并负责<strong>工科高等代数</strong>的课程。将会在第3，6，9，12，15周周末为大家带来<strong>微博直播课程</strong>，并会在期中期末烤漆给大家<strong>串讲</strong>，所以我会把每次上课的<strong>备课</strong>本作为博客上传，大家感兴趣的话可以康康。</li>
<li>不过，博主开通了一个 <strong><a href="http://volcaxiao.top/AA-column/">工科高等代数专栏</a></strong></li>
<li>在这个专栏里，会放我上面说的所有内容。</li>
<li>另外这个专栏最下方有<strong>评论区</strong>，大家可以多多水水，我也会在评论区答疑哒~</li>
</ul>
<h3 id="数理基础学习总结笔记"><a href="#数理基础学习总结笔记" class="headerlink" title="数理基础学习总结笔记"></a>数理基础学习总结笔记</h3><ul>
<li>数理基础对我们的学习还是挺重要的，所以我分出这一个分类，记录了博主我上过的数理基础课的一些总结</li>
<li>其中大致有离散数学2，以及工科大学物理</li>
</ul>
<h3 id="COOOOS"><a href="#COOOOS" class="headerlink" title="COOOOS"></a>COOOOS</h3><ul>
<li>秋季，是祭祖的时节~</li>
<li>春季，是<del>面向对象</del>的季节</li>
<li>博主俺会把学习CO的一些<strong>小心得小总结</strong>放在这</li>
<li>欢迎大家来一起学习讨论。</li>
</ul>
<h3 id="学习心得总结记录"><a href="#学习心得总结记录" class="headerlink" title="学习心得总结记录"></a>学习心得总结记录</h3><ul>
<li>博主喜欢在这方面进行一些思考与学习，也分享给大家。</li>
<li>大家有什么想法也欢迎交流</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>这里会有其他一些零零散散的知识点</li>
<li>或者是杂事</li>
<li>积少成多后可能会<strong>单独new一个分类</strong>出来，大家可以多注意<strong>welcome的更新</strong>！</li>
</ul>
<h2 id="约法三章"><a href="#约法三章" class="headerlink" title="约法三章"></a>约法三章</h2><ul>
<li>评论区文明发言。</li>
<li>都不容易，请任何事情都就事论事。</li>
<li>一般小事请不要通过邮件通知，因为可能判为垃圾邮件。</li>
</ul>
<blockquote>
<p>未完待续。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>welcome</category>
      </categories>
      <tags>
        <tag>welcome</tag>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】从线性方程组到矩阵讲课材料</title>
    <url>/2022/10/08/%E4%BB%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E5%88%B0%E7%9F%A9%E9%98%B5%E8%AE%B2%E8%AF%BE%E6%9D%90%E6%96%99/</url>
    <content><![CDATA[<p>朋辈辅导师第三周直播课-空间解析几何基础的备课资料，大家有需要自取。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/D98E660DE6A00FEC3AC14AF6FC383427">从线性方程组到矩阵</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="第六周备课本"><a href="#第六周备课本" class="headerlink" title="第六周备课本"></a>第六周备课本</h1><ul>
<li>我在私下里做了一个小调查哈，知道大家的各班的学习进度以及学习的顺序都不太一样，有的先开始学行列式，有的先开始学向量组，有的先开始学线性方程组，各班都不太一样，但考虑到这已经不是期中的内容了，而到期末呢，大家这些肯定都是要学的，所以我就按着我对于高代的学科体系构建的理解来讲这一次课，每个地方都会涉及到，大家在这个阶段能接受的内容我会多讲，然后后面的内容呢我会随着体系的构建把这些知识给逐步的完善。</li>
<li>对于这些内容呢，已经学过的同学加深一遍印象，没有学过的同学呢，我会浅处着手，再来深入，大家也当预习+学习。大家有什么问题的话，也请及时反馈，可以实时在聊天区表示疑惑，可以在直播的最后填写学支中心的反馈二维码。</li>
<li>我对我们的学习进度简要的设计了一下，我会在9、12、15周带来常规的三次直播，当然期中期末的时候也会有串讲，这是我的暂定进度，大家可以参考一下。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">直播时间</th>
<th style="text-align:center">直播主题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第三周</td>
<td style="text-align:center">空间解析几何基础</td>
</tr>
<tr>
<td style="text-align:center">第六周</td>
<td style="text-align:center">从线性方程组到矩阵</td>
</tr>
<tr>
<td style="text-align:center">第九周</td>
<td style="text-align:center">向量空间与欧式空间</td>
</tr>
<tr>
<td style="text-align:center">第十二周</td>
<td style="text-align:center">特征根与相似变换</td>
</tr>
<tr>
<td style="text-align:center">第十五周</td>
<td style="text-align:center">二次型与合同变换</td>
</tr>
</tbody>
</table>
</div>
<p>我和另外一位辅导师一起做高代的直播，我们的安排呢大致就是我给大家过一遍知识点，然后他来给大家讲解例题。</p>
<p>我们今天呢来讲四个概念，线性方程组、向量组、行列式，这几个东西呢，相互交汇，相互依存，很多概念，大家要将他们统一到自己的知识体系结构中，不能学乱了。</p>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h3 id="线性方程组的表示"><a href="#线性方程组的表示" class="headerlink" title="线性方程组的表示"></a>线性方程组的表示</h3><ul>
<li>向量表示</li>
<li>矩阵表示</li>
</ul>
<h3 id="线性方程组的求解"><a href="#线性方程组的求解" class="headerlink" title="线性方程组的求解"></a>线性方程组的求解</h3><ul>
<li>三类初等变换，同解变形</li>
<li>消元法与矩阵消元法</li>
</ul>
<h3 id="齐次方程与非齐次方程"><a href="#齐次方程与非齐次方程" class="headerlink" title="齐次方程与非齐次方程"></a>齐次方程与非齐次方程</h3><ul>
<li>解的讨论（联系我上次课讲的，维度与约束条件的概念，其实也就是解空间的维度与秩的关系）<ul>
<li>我们方程组的解的几何意义就是在高维空间中超平面的交线</li>
<li>齐次方程一定有解（0解）</li>
<li>当齐次方程的秩小于n时，有无穷多解（多维解空间）</li>
<li>$非齐次方程AX = B有解\Leftrightarrow r(A) = r(A|B) $</li>
<li>无解显而易见</li>
</ul>
</li>
<li>解的联系<ul>
<li>齐次方程通解的形式</li>
<li>非齐次方程的解：<blockquote>
<p>$\forall X, Y是AX = \beta 的解，则AX= \beta ,AY = \beta ,两式相减，A(X-Y) = 0,即X-Y为AX= 0方程的解。 $<br>$\therefore 若AX= \beta 有解Y_0，则对于方程的解X，X-Y_0 = t_1\varepsilon_1 + …… + t_{n-r}\varepsilon_{n-r}$<br>得到非齐次方程的通解</p>
</blockquote>
</li>
<li>$XA = B $的求解问题</li>
<li>给出非齐次方程的特解，相减构造导出方程的基，通过A的秩判断解空间的维度，算出通解。</li>
<li>判断X是否为 $AX = \beta $ 的解：代入即可</li>
</ul>
</li>
</ul>
<h2 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h2><h3 id="n维向量的定义与意义"><a href="#n维向量的定义与意义" class="headerlink" title="n维向量的定义与意义"></a>n维向量的定义与意义</h3><ul>
<li>首先带着一种对于我们能够感知到的三维的向量的认识去看这件事，升到n维以后，空间性质肯定还是存在，就比如说我们讨论的齐次方程与非齐次方程的解，其实就是一个讨论高维空间中超平面的交线的问题。</li>
<li>函数参数，写程序等等，函数传入了6个参数，其实就是构造了一个6维的空间，所以说我们生活在一个3维的空间里，这个维度是长宽高。但我们带着一种多面多元的视角去看世间，多维空间随处可见。</li>
</ul>
<h3 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h3><ul>
<li>$定义：对于一组向量\{\alpha_1, \alpha_2, ……, \alpha_n \}，若有一组k_n,与向量相乘加等于0，则k_1 = k_2 = …… = k_n = 0 , 则称\{\alpha_1, \alpha_2, ……, \alpha_n\}线性无关$<ul>
<li>联想一下，我们第一章的不共面定理不共线定理怎么说的。</li>
<li>所以相应的，不满足就是线性相关</li>
<li>光看这个定义，有点抽象，看不出什么来。</li>
</ul>
</li>
<li><p>相关性质</p>
<ul>
<li>相关的线性表示（及其逆，单边法则）<blockquote>
<p>由线性相关的定义可推出，其中某个向量可以由其余向量线性表示，这又可推出其中的某个向量可以写成前面的向量的线性组合。<br>所以我们逆过来看，线性无关，等价于<br>$每一个向量都不可由前面的向量表示（\alpha_i = 0） $<br>这我们叫做单边法则</p>
</blockquote>
</li>
<li>大数法则/不大法则<blockquote>
<p>我们先来看，一个向量组被另一个向量组表示被表示的意义。<br>$S_1组被S_2组表示\Leftrightarrow \forall \alpha_i \in S_1 , \alpha_i 可以被 \beta_j \in S_2 表示 $<br>大的向量组可以被小的向量组表示，大组必相关<br>（逆否命题：若A组无关，但可以被B组表示，则A比B小 ——不大法则）<br>为啥可以被表示，我们可以理解了后面的秩再来说，是不是说AX=B有解啊。</p>
</blockquote>
</li>
<li>表示的传递性<blockquote>
<p>$我们说S_2 能被S_1表示，S_1能被S_0表示，则S_2能被S_0表示$</p>
</blockquote>
</li>
<li>唯一表示法则<blockquote>
<p>$\{\alpha_1,……,\alpha_n\}无关,\{\alpha_1,……,\alpha_n,\beta\}相关，则\beta 由\{\alpha_1,……,\alpha_n\}唯一表示 $</p>
</blockquote>
</li>
<li>子组相关法则<blockquote>
<p>子组相关，全组必定相关<br>proof:<br>$k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p = 0 (k_1,……,k_p不全为零) $<br>$\therefore k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p + 0\alpha_{p+1} + …… + 0\alpha_n  = 0$</p>
</blockquote>
</li>
<li>等数法则<blockquote>
<p>$\{\alpha_1,……\alpha_p\},\{\beta_1,……\beta_q\}两组无关，且能相互表示，则p=q $<br>由不大法则可证</p>
</blockquote>
</li>
<li>长短法则<blockquote>
<p>长相关则短相关，短无关则长无关<br>看具体怎么理解了，有的老师说“如果矩阵A的子矩阵A0的各行（列）线性无关，则由A0的这些行（列）扩充得到的A的行（列）线性无关。”<br>这是从大到小，从矩阵看问题<br>也可以这么理解（从小到大，从向量组）：</p>
</blockquote>
</li>
</ul>
</li>
<li><p>这些是不是很难理解又臭又长，高等代数是一门极为统一连贯的科目，所以我们由表及里，定义了极大线性无关组，来帮助我们更好的理解线性相关与线性无关。</p>
</li>
<li><p>极大线性无关组</p>
<ul>
<li>定义：我们定义在全组中如果有一个子组线性无关，再加上其他任意一个元素，就会线性相关，我们称之为极大无关。</li>
<li>所以由唯一表示法则可以知道，全组中的其余元素均可由极大无关组唯一表示。</li>
<li>我们来定义一个等价的概念<blockquote>
<p>$S_1，S_2相互表示，则S_1等价于S_2 $<br>所以极大无关组与全组等价，且由于表示的传递性，任意两个极大组之间等价。<br>所以由于等数法则，任意两个极大组之间具有相同的个数。</p>
</blockquote>
</li>
<li>定义秩rank<blockquote>
<p>这样，我们就可以来定义向量组的秩了，我们就定义极大无关组中元素的个数叫做秩。<br>$所以在一个n维空间R^n，我们可以把它看作是一个有无限多向量的向量组，$<br>$那么的它秩是什么，我们选取一组标准正交基（坐标系的坐标，可以用三维来理解），$<br>$是不是说，再这个标准正交基外任意找一个向量，这个向量都能被这组向量表示啊，$<br>$所以rank(R^n) = n $<br>那我们继续想，我不必选择标准正交基是吧，我任意选n个线性无关的向量，他们是不是也是一个极大无关组啊，所以他们也能当作是基。</p>
</blockquote>
</li>
<li>秩与相关性的联系</li>
</ul>
</li>
<li><p>空间的基与解空间（略讲，联系着前面线性方程组来讲）</p>
<ul>
<li>由极大组引出基向量组的概念<blockquote>
<p>是不是隐隐约约感觉这个秩和维度应该是有点关系的<br>所以我们可以用一个极大无关组来作为一组基。<br>在这个空间的其他向量都被它们表示，怎么表示，我就可以定义出广义坐标。<br>…<br>但注意，这里的向量组是有序的，改变顺序，坐标就会变。</p>
</blockquote>
</li>
<li>有序无关组与广义坐标</li>
<li>线性方程组的解由基来表示<blockquote>
<p>所以，你们看过这些以后再来看线性方程组，以及它的解，是不是也就是用坐标来表示，它们的通解的表达形式中仿佛看到了基的出现，所以它们是不是也构成空间？这个我们点到为止，下次课我在来拿出空间和你们细说。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>我们用前面的相关性质来证明和定义了极大组与秩，我们再用秩的定义来更好的理解前面的这些性质与相关和无关的深入理解。</p>
</li>
<li>很简单，记住两条。</li>
<li>一个向量组的元素个数比秩大，就线性相关，等于秩就线性无关。</li>
<li>一个向量组被另一个向量组表示，就是说能被另一个组生成，所以秩肯定不会变大。</li>
<li>所以我们再来理解这些东西</li>
</ul>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><blockquote>
<p>矩阵只是记号，向量拼一块就是矩阵</p>
</blockquote>
<ul>
<li>矩阵的运算<ul>
<li>主要就是乘法及其运算性质</li>
<li>我们能看到这个直接定义并不好看。所以我更推荐大家按照下面这种理解。</li>
<li>矩阵分块<blockquote>
<p>我们在线性方程组的矩阵表示方法中已经看到AX是怎么定义的。<br>所以我们可以推广，把B这个矩阵按列分块成$(\beta_1,……,\beta_q),则AB = (A\beta_1, A\beta_2 , ……,A\beta_q) $</p>
</blockquote>
</li>
<li>所以得匹配才能乘，大家也能看出来其中的性质AB != BA 这种</li>
<li>但是特殊情况，方阵，单位阵。</li>
</ul>
</li>
<li><p>矩阵的可逆与正交</p>
<ul>
<li>可逆的定义及相关性质<blockquote>
<p>$若\exists B,AB=BA=I，则称A为可逆阵，B为A的逆阵,记作：A^{-1} = B $</p>
</blockquote>
</li>
<li>性质：<blockquote>
<p>$(ABC)^{-1} = C^{-1}B^{-1}A^{-1} $(proof)<br>行列式不为零则可逆<br>……</p>
<ul>
<li>逆阵唯一性<script type="math/tex; mode=display">
AB =AC =I  
则B = BI = B(AC) = (BA)C = C</script></li>
<li>保可逆，反序可逆<br>A可逆，B可逆，则AB可逆<br>$proof: ABB^{-1}A^{-1} = I $<br>若AB = I ，BA也可逆。</li>
</ul>
</blockquote>
</li>
<li>正交的定义及其相关性质<blockquote>
<p>$A^TA = I,即A^{-1} = A^T,则称A为正交阵 $<br>性质：矩阵乘的转置,与矩阵乘的求逆类似</p>
<ul>
<li>保长、保内积、保正交<br>$我们知道向量的模长度公式是吧，对于列向量X，它的模长为||X||^2 = X^TX(内积的表示) ，所以列向量AX(A为正交阵)为||AX||^2 = X^TA^TAX ——保长性$<br>$保内积类似，(X,Y) = (AX,AY) = X^TY $<br>$保正交:两种理解：<br>A正交，B正交，则AB正交<br>X \perp Y \Leftrightarrow AX \perp AY $</li>
<li>线性变换初步<br>所以我们从三维来理解一下，一个向量乘上一个矩阵后，变了，但是长度没变，两个向量之间的内积没变，两个向量该垂直的垂直，所以我们把这种变换，保长保内积保正交的变换，叫做线性变换/正交变换，矩阵又有了它的另一层含义。</li>
<li>每列为单位向量且相互正交，且则阵正交<br>用矩阵乘法去理解。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>矩阵的秩</p>
<ul>
<li>阶梯阵概念，及其与向量组秩的联系。<blockquote>
<p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>所以三种同解变形，其实就代表着三种初等变换。</p>
</blockquote>
</li>
<li>秩一阵<blockquote>
<p>我们来看一个一点的矩阵，秩一阵，可分解为两个向量之间的乘积。</p>
</blockquote>
</li>
<li>降秩定理<blockquote>
<p>$r(AB) \le r(A) , r(B) (用AB被A表示证明一边，用转置证明另一边)$</p>
</blockquote>
</li>
<li>满秩、方程组解、可逆之间的关系<blockquote>
<ul>
<li>满秩则有唯一解<br>$proof: \because r(A) = n $<br>$\therefore \{\alpha_1,……,\alpha_n\}可作为一组基 $<br>$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>$坐标即为唯一解 $</li>
<li>满秩则可逆<br>$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="行列式（看时间待定）"><a href="#行列式（看时间待定）" class="headerlink" title="行列式（看时间待定）"></a>行列式（看时间待定）</h2><ul>
<li>行列式的定义<ul>
<li>逆序数</li>
</ul>
</li>
<li>余子式与余子阵</li>
<li>行列式的计算<ul>
<li>对角阵</li>
<li>余子阵展开</li>
</ul>
</li>
<li>相伴逆公式，克莱姆法则<ul>
<li>理解其与秩、可逆，方程组解之间的关系</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-数分1】北航信息类数分一资料</title>
    <url>/2022/09/06/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>北航大一的数分（一）资料，有<strong>数分讲座的ppt</strong>以及<strong>2010-2022的期中考题</strong>、<strong>2010-2021的期末考题</strong>，其中期末的考题以及处理好了，题目和答案分开在两个文件夹内。但期中的考题答案和题目还合在一起，这里并不是俺懒（确信.jpg，而是学长觉得授人以鱼不如授人以渔，所以内有<strong>wps处理教程</strong>，赶紧学起来叭！！！</p>
<span id="more"></span>
<h1 id="数分（一）资料"><a href="#数分（一）资料" class="headerlink" title="数分（一）资料"></a>数分（一）资料</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>快点端上来罢 我已经等不及了<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%80.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%80.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图1"></p>
</blockquote>
<ul>
<li><a href="https://bhpan.buaa.edu.cn:443/link/D8A4739E259BFEBEE88FD61C2F75F331">北航云盘-淑芬（一）资料</a><br>有效期限：2025-10-01 23:59</li>
<li>有效期快到了的话提醒我续费（</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>第一个文件夹，北航学院开的<strong>数分讲座的ppt</strong>，你们也会有这种讲座的，课程组的老师会在每章结束后开讲座（一般在周日下午），俺还是比较推荐你们去看看的，错过了也没关系，一般会有录屏，要去自己找找（上大学，<strong>信息检索</strong>的能力是挺需要的，就比如你们要能从我这篇文章中取得你们需要的东西），录屏可以开1.5倍或者是2倍速看。<ul>
<li>什么？怎么开倍速，建议去了解一下<strong>浏览器插件</strong>。</li>
</ul>
</li>
<li>第二个文件夹，数分期中的试卷，这个对于大家挺重要的，而且建议打印下来，<strong>刷纸质版</strong>。往年题是真的要认真刷的！！！<ul>
<li>但是你们也注意到，答案和题目混在一块，别急，<a href="#正片开始-wps_pdf处理">去后面看看，有好东西</a>。按照这里一步一步走就可以自己造试卷了，而且有北航专属彩蛋相送。</li>
</ul>
</li>
<li>第三个文件夹，数分期末试卷，这里就都喂你们口中了，利用好喔~<ul>
<li>看完这里以后别急着走哈，后面有学长头铁的<strong>备考建议</strong>捏~~~~<a href="#备考建议及写在最后的话">备考建议</a></li>
</ul>
</li>
</ul>
<h2 id="正片开始-wps-pdf处理"><a href="#正片开始-wps-pdf处理" class="headerlink" title="正片开始-wps_pdf处理"></a>正片开始-wps_pdf处理</h2><ul>
<li>ms office全家桶是非常强大的办公软件，用的好ms office当然能够解决好许多问题。而wps这一类金山的东西一直给人一种广告多不好用的印象，但其实金山软件公司在1988年创立，和ms争夺办公软件的市场许多年，wps在功能性上完全不输ms office，所以大家可以放心食用，另外广告这件事也不用担心，马上就没了（手动滑稽</li>
</ul>
<h3 id="具体教程"><a href="#具体教程" class="headerlink" title="具体教程"></a>具体教程</h3><ul>
<li>我们打开2020-2021的期中试卷，看到里面还有答案。我们点击 <strong>编辑-&gt;编辑内容</strong> 可以发现页面变成了这样<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%BA%8C.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%BA%8C.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图二"></li>
<li><p>问题是这样不好处理选项啊，删错了怎么办？（可以ctrl+z）</p>
<ul>
<li>这样可以来<strong>处理大题</strong>，像这样，直接<strong>全部选中，delete</strong>，就okk了<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%89.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%89.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图三"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E5%9B%9B.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E5%9B%9B.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图四"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%BA%94.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/%E5%9B%BE%E4%BA%94.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图五"></li>
</ul>
</li>
<li><p>那选择题怎么搞？ 可以点击 <strong>编辑-&gt;擦除</strong> ，去试一下很好搞的，绝对不是俺懒（确信.jpg。</p>
</li>
<li>编辑内容功能还可以用来<strong>去除部分水印</strong>，留给大家遇到了再自己去尝试了，当然有需求可以评论区告诉我。</li>
<li>最后，全都处理完后记得<strong>另存为</strong>，放到另一个文件夹里。（<strong>管理资料</strong>的能力也同样重要！</li>
</ul>
<h3 id="白嫖wps会员方法"><a href="#白嫖wps会员方法" class="headerlink" title="白嫖wps会员方法"></a>白嫖wps会员方法</h3><ul>
<li>有人说（也有可能没有）：学长学长，wps它没有会员不好用哇！</li>
<li>不用担心，北航有办法</li>
<li>网址：s.buaa.edu.cn（在校外用vpn1就可以上）</li>
<li><strong>登录后</strong>在下载中心点击<strong>金山软件</strong>-&gt;<strong>wps激活绑定</strong>，这样就能加入北航的企业团队啦，就有了白嫖的企业vip！</li>
<li>而且在<a href="https://s.buaa.edu.cn">北航正版软件平台</a>上，你还能看到其他有用的软件，按需自取吧！</li>
</ul>
<h2 id="备考建议及写在最后的话"><a href="#备考建议及写在最后的话" class="headerlink" title="备考建议及写在最后的话"></a>备考建议及写在最后的话</h2><ul>
<li>最后是学长的唠叨，数分高代作为两个大宗科目（恐怖的6学分），希望大家都能把握好。</li>
<li>多<strong>刷刷往年题</strong>，此外推荐好好看看<strong>书本及其课后题</strong>和<strong>老师的ppt</strong>，其实很多题都换汤不换药。</li>
<li>另外推荐看看<strong>蓝书的典型例题</strong>，整理的挺全面的。</li>
<li>然后最重要的是<strong>平时要学好</strong>！</li>
</ul>
<blockquote>
<p>the end 祝大家好好学习天天向上！</p>
</blockquote>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>数分</tag>
        <tag>wps</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-数分2】北航信息类数分二资料</title>
    <url>/2023/03/14/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>北航大一的数分（二）的资料，期中期末的往年题，其中21级的题没有答案，不过欢迎讨论。</p>
<span id="more"></span>
<h1 id="上链接"><a href="#上链接" class="headerlink" title="上链接"></a>上链接</h1><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/emmmm.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E6%95%B0%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%84%E6%96%99/emmmm.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="emmmm"></p>
<ul>
<li><a href="https://bhpan.buaa.edu.cn:443/link/B1A3FF121AA0459A1E4E6FE7A77595C6">北航云盘-淑芬（二）资料</a><br>有效期限：2026-10-01 23:59</li>
<li>有效期快到了的话提醒我续费（</li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>数分</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】北航信息类高代资料</title>
    <url>/2022/09/06/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E9%AB%98%E4%BB%A3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>北航大一高代的资料，高代的题可能就不像数分的题整理的那么的整齐，可能<strong>有点零散</strong>，特别是期中的题，俺可能还一不小心删掉一部分（秃头），而且很多<strong>试题都没有答案</strong>。不过乐观点想，期中大家真的不用太担心，试题没有答案的话可以多<strong>和同学讨论</strong>，<strong>对答案</strong>，<strong>问老师</strong>；这也是个主动学习的过程。另外文档里，有俺滴<strong>手写笔记</strong>，大一上跟着<strong>赵迪老师</strong>上课，受益匪浅，学会了很多 <strong><em>学术语言</em></strong>()，<strong>大大滴推荐</strong>。另外这一篇也有<strong>加餐</strong>，给大家讲一下可以从哪里<strong>找试卷资源</strong>，这样大家也能自己去找资源！</p>
<span id="more"></span>
<h1 id="高代资料"><a href="#高代资料" class="headerlink" title="高代资料"></a>高代资料</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>话不多说，上链接！<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E9%AB%98%E4%BB%A3%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%80.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%8C%97%E8%88%AA%E4%BF%A1%E6%81%AF%E7%B1%BB%E9%AB%98%E4%BB%A3%E8%B5%84%E6%96%99/%E5%9B%BE%E4%B8%80.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图一"></p>
</blockquote>
<ul>
<li><a href="https://bhpan.buaa.edu.cn:443/link/197EDC5E339248FC004CD796F84C3EB8">北航云盘-高代资料</a><br>有效期限：2025-10-01 23:59</li>
<li>有效期快到了的话提醒我续费（</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="高代期中"><a href="#高代期中" class="headerlink" title="高代期中"></a>高代期中</h3><ul>
<li>期中这个文件夹里是些零零碎碎的东西，其中有一本 <strong>！几何书（教材）</strong> 那上面应该就是你们期中考试的大致范围了。</li>
<li>不过高代的期中完全不用担心，只占10的平时分，而且巨简单，高代难的在后面<strong>概念多</strong>起来的时候，容易头晕。</li>
</ul>
<h3 id="高代期末"><a href="#高代期末" class="headerlink" title="高代期末"></a>高代期末</h3><ul>
<li>这个文件夹里，有高代的<strong>芝士点总结</strong>，还有<strong>真题试卷</strong>和<strong>练习的试卷</strong>，知识点可以看看，主要多刷题多总结。</li>
</ul>
<h3 id="最后两个文件"><a href="#最后两个文件" class="headerlink" title="最后两个文件"></a>最后两个文件</h3><ul>
<li>这两个文件，一个是<strong>教材的答案</strong>，不是教材的顺序，但是很多题是重合的，<strong>仔细找找</strong>应该能找到答案。</li>
<li>另一个是学长<strong>面向高代考纲（手动滑稽）</strong> 的一手资料，里面会有一些<strong>难懂难蚌</strong>的学术词汇，大家可以简单看看。</li>
</ul>
<h2 id="加餐时间"><a href="#加餐时间" class="headerlink" title="加餐时间"></a>加餐时间</h2><blockquote>
<p>此次的加餐主要是为了解决资源检索的问题，关于数分高代，或说一些其他科目(程设)，有哪些资料的来源。</p>
</blockquote>
<h3 id="梦拓学长学姐"><a href="#梦拓学长学姐" class="headerlink" title="梦拓学长学姐"></a>梦拓学长学姐</h3><h3 id="老师发的资料"><a href="#老师发的资料" class="headerlink" title="老师发的资料"></a>老师发的资料</h3><h3 id="腾讯乐享"><a href="#腾讯乐享" class="headerlink" title="腾讯乐享"></a>腾讯乐享</h3><h3 id="各种群聊"><a href="#各种群聊" class="headerlink" title="各种群聊"></a>各种群聊</h3><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><blockquote>
<p>持续更新中，未完待续。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>工科大物-气体动理论总结</title>
    <url>/2022/09/06/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E6%B0%94%E4%BD%93%E5%8A%A8%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>系边上老师的课边做的一些笔记以及自己的一些想法，但有时候可能会拖更，分享给大家，有不妥之处，敬请评论区指正。</p>
<span id="more"></span>
<h1 id="气体动理论总结（持续更新中…）"><a href="#气体动理论总结（持续更新中…）" class="headerlink" title="气体动理论总结（持续更新中…）"></a>气体动理论总结（持续更新中…）</h1><h2 id="一、基本概念、微观结构、统计规律"><a href="#一、基本概念、微观结构、统计规律" class="headerlink" title="一、基本概念、微观结构、统计规律"></a>一、基本概念、微观结构、统计规律</h2><h3 id="1、热力学系统与外界"><a href="#1、热力学系统与外界" class="headerlink" title="1、热力学系统与外界"></a>1、热力学系统与外界</h3><ul>
<li>热力学系统：一般相对较大、能被察觉，包含大量的分子原子。</li>
<li>外界：系统之外（严谨的废话）。</li>
</ul>
<h3 id="2、物质的微观结构"><a href="#2、物质的微观结构" class="headerlink" title="2、物质的微观结构"></a>2、物质的微观结构</h3><ul>
<li>宏观的物体都由大量微观粒子构成</li>
<li>所有分子都在不停无规则的热运动</li>
<li>分子间存在相互作用力</li>
</ul>
<h3 id="3、气体分子热运动的主要特征"><a href="#3、气体分子热运动的主要特征" class="headerlink" title="3、气体分子热运动的主要特征"></a>3、气体分子热运动的主要特征</h3><ul>
<li>分子间间距大</li>
<li>碰撞频繁</li>
<li>遵从牛顿运动定律（相对较低速）</li>
</ul>
<h3 id="4、理想气体微观模型"><a href="#4、理想气体微观模型" class="headerlink" title="4、理想气体微观模型"></a>4、理想气体微观模型</h3><ul>
<li>气体分子看作小球，可以弹性也可以刚性</li>
<li>分子间只有相互碰撞，没有其他相互作用，所以没有分子间势能</li>
<li>碰撞时分子看成完全弹性小球</li>
</ul>
<h3 id="5、平衡态"><a href="#5、平衡态" class="headerlink" title="5、平衡态"></a>5、平衡态</h3><ul>
<li>是指在系统不受外界影响时，各部分宏观性质长时间不随时间改变的状态</li>
<li>平衡态应用：热力学第三定律</li>
</ul>
<h3 id="6、温度"><a href="#6、温度" class="headerlink" title="6、温度"></a>6、温度</h3><hr>
<p>整理老师ppt的部分结束了，俺懒得copy了，接下来就是一些理论的推导过程以及我觉得重要的地方</p>
<h2 id="理想气体平衡态时宏观描述"><a href="#理想气体平衡态时宏观描述" class="headerlink" title="理想气体平衡态时宏观描述"></a>理想气体平衡态时宏观描述</h2><blockquote>
<p>注意表述，有哪些定语，理想气体、平衡态、宏观</p>
</blockquote>
<ul>
<li>有V(体积)、P(压强)、T(温度)、M(质量)、、、气体的宏观量，并且有由它们相互之间构成的关系——克拉伯龙方程</li>
<li>还有许多由实验得来的定律，等温的玻意尔定律，等容的查理定律，等压的盖吕萨克定律都可以在克拉伯龙方程得到体现，相信大家高中学的都挺好，这些不在话下。</li>
</ul>
<blockquote>
<p>$PV= \nu RT$    ($\nu$为摩尔数，T单位为开尔文K)<br>它有许多变式<br>$\because \nu=\frac{m}{M}=\frac{N}{N_A}$<br>$\therefore \dotsb$<br>$\because k = \frac{R}{N_A}$（k为玻尔兹曼常数）<br>$\because n=\frac{N}{V} = \frac{\nu N_A}{V}$ (n为分子数密度)<br>$\therefore 它又能写成 PV=NkT, P=nkT$<br>其中常数$R=8.314510J/molK$<br>$k=1.380658 \times 10^{-23} J/K$</p>
</blockquote>
<h2 id="理想气体压强公式"><a href="#理想气体压强公式" class="headerlink" title="理想气体压强公式"></a>理想气体压强公式</h2><ul>
<li>首先得清楚，压强的来源是每一个小分子对于器壁都会有冲击力，但是这里的P是大量分子撞击的宏观结果，单个的分子无法讨论压强。</li>
<li>下面开始推导</li>
</ul>
<blockquote>
<p>在一个边长分别为$l_1,l_2,l_3$的全反射壁容器内<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E6%B0%94%E4%BD%93%E5%8A%A8%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/%E5%9B%BE2.1.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E6%B0%94%E4%BD%93%E5%8A%A8%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/%E5%9B%BE2.1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="容器"></p>
</blockquote>
<h2 id="分子碰撞基本理论——平均自由程"><a href="#分子碰撞基本理论——平均自由程" class="headerlink" title="分子碰撞基本理论——平均自由程"></a>分子碰撞基本理论——平均自由程</h2><p>Maxwell速率分布</p>
<h2 id="温度公式"><a href="#温度公式" class="headerlink" title="温度公式"></a>温度公式</h2><p>温度与平动动能有关，相同温度不同气体，平动动能一定相等，但总动能和内能不一定相等</p>
<h2 id="阿佛加德罗定律"><a href="#阿佛加德罗定律" class="headerlink" title="阿佛加德罗定律"></a>阿佛加德罗定律</h2><h2 id="道尔顿分压定理"><a href="#道尔顿分压定理" class="headerlink" title="道尔顿分压定理"></a>道尔顿分压定理</h2><h2 id="能量均分定理"><a href="#能量均分定理" class="headerlink" title="能量均分定理"></a>能量均分定理</h2><h2 id="气体内能的讨论"><a href="#气体内能的讨论" class="headerlink" title="气体内能的讨论"></a>气体内能的讨论</h2><h2 id="Maxwell速率分布"><a href="#Maxwell速率分布" class="headerlink" title="Maxwell速率分布"></a>Maxwell速率分布</h2><p>最可几/最概然 速率 无序度增加</p>
]]></content>
      <categories>
        <category>工科大学物理</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>物理</tag>
        <tag>热力学</tag>
        <tag>气体动理论</tag>
      </tags>
  </entry>
  <entry>
    <title>工科大物-热力学基础总结</title>
    <url>/2022/09/13/%E5%B7%A5%E7%A7%91%E5%A4%A7%E7%89%A9-%E7%83%AD%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>系边上老师的课边做的一些笔记以及自己的一些想法，但有时候可能会拖更，分享给大家，有不妥之处，敬请评论区指正。</p>
<span id="more"></span>
<h1 id="热力学总结"><a href="#热力学总结" class="headerlink" title="热力学总结"></a>热力学总结</h1><h2 id="内能、功、热量、热一律"><a href="#内能、功、热量、热一律" class="headerlink" title="内能、功、热量、热一律"></a>内能、功、热量、热一律</h2><ul>
<li>系统的状态发生变化 -&gt; 热力学过程<ul>
<li>弛豫时间：系统由非平衡态达到平衡态所需的时间</li>
<li>准静态过程（平衡过程）：过程无限（理想过程）缓慢，每个中间过程都无限接近平衡态（每一点都满足 $ PV = \nu RT$），可以用P-V图表示。</li>
</ul>
</li>
<li>做功（机械能转化的量度）：在准静态过程中：<blockquote>
<p>$状态从 (P_1,v_1,T_1)到(P_2,V_2,T_2)$<br>$ A = \int _{1 \rightarrow 2} \vec{F} \cdot d \vec{l} $<br>$ = \int_{1 \rightarrow 2} P \cdot S \cdot dl = \int _{v_1} ^{v_2} P dV $</p>
<ul>
<li>在P-V图上体现为始末状态所围的面积</li>
<li>$ \Delta V &gt; 0 气体对外界做正功  ，在P-V图上，顺时钟循环 A &gt; 0 $</li>
</ul>
</blockquote>
</li>
<li>热量也是一种能量交换的度量！</li>
<li>热力学第一定律：<blockquote>
<p>$ 系统内能的增量：\Delta E = A’ + Q (A’ 为外界对系统做的功，Q为外界向系统传递的热量) $<br>$\therefore 外界对系统传递的热量 Q = \Delta E + A$<br>$ Q = dE + A$</p>
</blockquote>
</li>
</ul>
<h2 id="气体的摩尔热容量"><a href="#气体的摩尔热容量" class="headerlink" title="气体的摩尔热容量"></a>气体的摩尔热容量</h2><ul>
<li>$热容C：C = \lim _{ \Delta T \to 0 } \frac{ \Delta Q }{ \Delta T} = \frac{dQ}{dT} $</li>
<li>$比热容：单位质量物质的热容 C_b = \frac{dQ}{mdT} : J/Kg \cdot K$</li>
<li>$ 摩尔热容：J / mol \cdot K$</li>
<li>定容摩尔热容：<blockquote>
<p> $ C_{V,m} = \frac{ (dQ)_V }{ \nu dT } = \frac{dE}{dT}+ P\frac{dV}{dT} \stackrel{dV=0}{=} \frac{dE}{dT} = \frac{i}{2}R $</p>
</blockquote>
</li>
<li>定压摩尔热容：<blockquote>
<p>$ C_{P,m} = \frac{dE}{dT}+ P\frac{dV}{dT} = \frac{i}{2}R+ P\frac{dV}{dT} \stackrel{PV=RT}{==} (\frac{i}{2}+1)R $</p>
</blockquote>
</li>
<li>比热容比（泊松比）：定压摩尔热容比定容摩尔热容</li>
<li>准静态过程的热量的计算</li>
</ul>
<h2 id="等值过程的过程方程和能量关系"><a href="#等值过程的过程方程和能量关系" class="headerlink" title="等值过程的过程方程和能量关系"></a>等值过程的过程方程和能量关系</h2><blockquote>
<p>我们研究一个过程可以着重研究四个方面：其特点、过程方程、过程曲线、能量关系。</p>
</blockquote>
<ul>
<li>等压过程<blockquote>
<p>$ P=const, \frac{V}{T}=const$<br>$ A = \int _{V_1}^{V_2} P dV = \nu R \Delta T  $<br>$ \Delta E = \nu \frac{i}{2} R \Delta T = Q_P - A $<br>$ Q_P = \nu C_{P,m} (T_2-T_1) $</p>
</blockquote>
</li>
<li>等容过程<blockquote>
<p>$ A = 0 (dV = 0) $<br>$ \Delta E = \nu \frac{i}{2} R \Delta T  $<br>$ Q_V = \Delta E = \nu C_{V,m} \Delta T = \frac{i}{2} V \Delta P $</p>
</blockquote>
</li>
<li>等温过程<blockquote>
<p>$PV = const, \Delta E = 0 $<br>$Q_T =  \nu C_{T,m} \Delta T $<br>$\because \Delta T = 0,Q_T为有限量 \Rightarrow C_{T,m} = +\infty  $<br>$Q_T = A = \int _{1 \to 2} PdV = \int_{V_1}^{V_2} \nu \frac{R}{V}TdV $<br>$=\nu R T \ln{\frac{V_2}{V_1} } = \nu R T \ln{\frac{P_1}{P_2} } $</p>
</blockquote>
</li>
</ul>
<h2 id="绝热过程"><a href="#绝热过程" class="headerlink" title="绝热过程"></a>绝热过程</h2><ul>
<li>绝热过程：系统在整个过程中，始终不和外界交换热量。<blockquote>
<p>$ 特点：dQ = 0 , C_{Q,m} = 0 $<br>$ dQ = 0 \Rightarrow dA + dE = 0 $<br>$ 我们利用等容关系能得到：-PdV = \nu C_{V,m} dT $<br>$ 但是我们在绝热过程中P,V都会变$<br>$ \therefore 对克拉伯龙方程微分 $<br>$ PdV+ VdP = \nu R dT $<br>$ 把上式代入得：(C_{V,m}+ R)PdV = - C_{V,m} V dP $<br>$\therefore \frac{dP}{P} = - \gamma \frac{dV}{V} $<br>$ 两边求导：PV^{\gamma} = const (过程/泊松方程) $</p>
</blockquote>
</li>
<li><p>绝热曲线：<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/pict_1.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/pict_1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="pict1"></p>
<ul>
<li>我们来仔细辨析一下其中的原理，从宏观和微观的角度。</li>
</ul>
</li>
<li><p>能量关系：</p>
<blockquote>
<p>$ \Delta E = \nu \frac{i}{2} R \Delta T = \nu C_{V,m} \Delta T = -A$<br>$\because \frac{i}{2} = \frac{1}{\gamma - 1} $<br>$\therefore A = \frac{P_1 V_1 - P_2 V_2}{ \gamma - 1} $</p>
<ul>
<li>当然，我们也可以通过理气对外做功的方程以及泊松方程直接求A<br>$A = \int_{V_2}^{V_1} PdV =  $</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="多方过程"><a href="#多方过程" class="headerlink" title="多方过程"></a>多方过程</h2><ul>
<li>多方过程：理想气体的一般过程。</li>
<li>$ 过程方程：PV^n = const $<ul>
<li>从方程可以看出，这个过程介于等压过程和等容过程之间，为啥这么说捏？<blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="循环过程"><a href="#循环过程" class="headerlink" title="循环过程"></a>循环过程</h2><ul>
<li>循环过程：从初始状态出发，一系列变化回到初始状态<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/pict_2.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/pict_2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="pict2"></li>
<li>$特点：\Delta E = 0 \therefore A = Q $<blockquote>
<p>$A = \int_LPdV = \pm S_{abcda} $<br>$ A的\pm 取决于L路径的正负$</p>
</blockquote>
</li>
<li>应用：热机与制冷机</li>
</ul>
<h2 id="拓展—热力经济学"><a href="#拓展—热力经济学" class="headerlink" title="拓展—热力经济学"></a>拓展—热力经济学</h2><blockquote>
<p>持续更新中。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>工科大学物理</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>物理</tag>
        <tag>热力学</tag>
        <tag>热力学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】向量空间与内积空间讲课资料</title>
    <url>/2022/11/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4%E8%AE%B2%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>朋辈辅导师第九周直播课-向量空间和内积空间的备课资料，大家有需要自取。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/C7BC9C11CA3A9858EE1EDD8BBECCA983">向量空间与内积空间</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="向量空间与欧氏空间"><a href="#向量空间与欧氏空间" class="headerlink" title="向量空间与欧氏空间"></a>向量空间与欧氏空间</h1><ul>
<li>高代的概念多的很啊，像我们的矩阵、线性方程组、还有向量，这些之间是一个什么关系呢，它们都统一的在空间这个框架里面被联系起来。所以在学习高代的时候一定要有一个意象化的空间的思想，这个思想对于大家好好的理解概念，会有很大的帮助。</li>
</ul>
<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p>[toc]</p>
<h2 id="空间的定义"><a href="#空间的定义" class="headerlink" title="空间的定义"></a>空间的定义</h2><ul>
<li>向量空间（线性空间）的原始定义：对加倍法封闭</li>
<li>性质：零元一定在空间里</li>
<li>拓展：矩阵空间，矩阵掰直就是向量</li>
<li>那我们来看，联系来了，AX=0的解集就构成空间</li>
<li>何以见得：证明对加倍法封闭</li>
<li>该怎么意象化的理解封闭：你们可以用三维空间来理解，空间是一定过原点的，所以在三维空间中一个过原点的平面是空间，这样的话，在平面上的向量怎么组合都跳不出这个平面，这就叫封闭，没过原点的平面上的向量（注意这里的向量顶点分别在原点和平面上）稍微*2就出去了。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1空间的定义.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1空间的定义.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="空间的定义"></li>
</ul>
<h2 id="从生成空间看到解空间"><a href="#从生成空间看到解空间" class="headerlink" title="从生成空间看到解空间"></a>从生成空间看到解空间</h2><h3 id="再次讨论齐次解与非齐次解"><a href="#再次讨论齐次解与非齐次解" class="headerlink" title="再次讨论齐次解与非齐次解"></a>再次讨论齐次解与非齐次解</h3><ul>
<li><p>写出齐次方程的通解，基和广义坐标的关系，所以我们能看到解空间的影子</p>
</li>
<li><p>所以关于非齐次方程的解是否构成空间？</p>
</li>
<li>常见的问题：判断一个解是否为齐次方程或非齐次方程的解？</li>
<li><p>补充：齐次方程解与非齐次方程解之间的关系<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3齐次解与非齐次解讨论.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3齐次解与非齐次解讨论.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="齐次解与非齐次解的讨论"></p>
</li>
<li><p>补充：高三定理：一个非齐次线性方程组有解，且所有解组成的解集的一个极大线性无关组含有n个解（秩为n），那么对应的齐次线性方程组基础解系含有n-1个解向量（解空间的维度为n-1），这个命题对吗？</p>
<blockquote>
<p>首先经过我上面的描述能证明：<br>  导出方程的解空间的基+一个特解组成的向量组依然无关<br>  然后：<br>  通过非齐次方程组通解的表达形式可知，该解系中任意一个解都能用上面的无关向量组表示，所以我们说该向量组是极大线性无关组。<br>  设这个无关组秩为n。<br>  则根据构造形式，它的导出方程的解空间秩为n-1</p>
</blockquote>
</li>
<li>所以我们要说解空间了嘛？我知道你很急，但你先别急，让我先急（</li>
<li>我们先来说关于空间的另一种理解，这种理解了以后，关于解空间问题迎刃而解。</li>
</ul>
<h3 id="生成空间的定义"><a href="#生成空间的定义" class="headerlink" title="生成空间的定义"></a>生成空间的定义</h3><ul>
<li>关于空间的另一个理解：生成空间！important！！</li>
<li>我们给定任意的一组向量，他们的线性组合，满足双封闭？事空间！</li>
<li>但是还不够简洁，我们远不需要这些向量的全部，因为我们可以由其中的某些来表示全部，这个大家是知道的，叫极大线性无关组，</li>
<li>所以我们有了另一个理解向量空间的视角：就好像是一个极大线性无关组的任意组合，它们生成了空间。我们把这个极大线性无关组叫做基，基的秩就是空间的维数。</li>
<li>空间相同，就是基等价！<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4生成空间的定义.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4生成空间的定义.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="生成空间"></li>
</ul>
<h3 id="解空间"><a href="#解空间" class="headerlink" title="解空间"></a>解空间</h3><ul>
<li>所以我们回过头来看看解空间是个什么回事。</li>
<li>解空间就是由通解的基生成的。</li>
<li>解空间的维度：两种理解，一种理解是解线性方程组得到，另一种理解更高级和优雅，是定义完内积空间之后得到。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2解空间的由来.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2解空间的由来.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="解空间的秩"></li>
<li>然后大家很迫切的想要弄清楚空间的交和空间的和之间的关系，定义我就不多说了</li>
<li>求空间的和：根据定义两边各取一个向量来表示，就把通解写到一块，所以为啥要理解了生成空间再来看这个，就是两个解空间的生成元放在一块，然后再生成一个空间嘛，所以对于维度公式我们也好理解了。</li>
<li>求两个解空间的交有两种办法，一种是定义，把他们的线性方程组联立到一起，这样解出来的空间就既满足A，又满足B。但是一般如果你刚开始知道基，你就很难去反解出他的线性方程组(得求正交，有点麻烦)，但是你可以直接输出两个解空间集合重合的部分，方法就像上面说的，把两个通解的一般形式放一块，划个等号，然后解出来系数之间的关系。把关系再代回去，就得到了他们交空间的通解的形式(这个通解既能通过A的基生成，又能通过B的基生成)</li>
<li>补充：空间的直和与空间的并。</li>
</ul>
<h2 id="欧氏空间的定义"><a href="#欧氏空间的定义" class="headerlink" title="欧氏空间的定义"></a>欧氏空间的定义</h2><ul>
<li>我们理解了这么多以后其实还是会感觉有点空虚的，空虚在哪？关于解空间的维度我前面留了一个小坑，关于基本解与系数矩阵之间的关系若隐若现。</li>
<li>这一些，我们在定义完内积之后，也将得到解决。</li>
<li>我们常说的欧几里得空间就是内积空间，也就是加上内积的定义以后的向量空间！</li>
</ul>
<h3 id="内积与模长"><a href="#内积与模长" class="headerlink" title="内积与模长"></a>内积与模长</h3><ul>
<li>关于内积是怎么定义的，大家早学过了，那么内积有些什么用呢</li>
<li>内积正定性，定义模长</li>
<li>正交向量的内积</li>
<li>若一个向量与一个向量组都正交，那么他与这个生成空间正交</li>
<li>所以我们可以来以另一个视角理解一下解齐次方程组：<ul>
<li>我们把系数矩阵分行来看，我们把需要解的X乘过去的过程不就是在算他与每一行的内积嘛，它们的内积等于零，所以我们的解与系数矩阵的每一行都正交，所以我们的解空间是怎样的一个空间，是一个与A行向量生成的空间正交的空间，所以这也就不难解释，当A的秩为r，A行向量生成的空间的维数就是r，如果这是在一个总共为n的空间里，那我们的解空间与A空间正交，就有了dim = n-r的公式。这么去理解。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/6内积与Gram.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/6内积与Gram.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="内积与Gram"></li>
</ul>
</li>
</ul>
<h3 id="Gram方阵"><a href="#Gram方阵" class="headerlink" title="Gram方阵"></a>Gram方阵</h3><ul>
<li>定义，所以易知是对称阵</li>
<li>行列向量都是一样的，我们这里只讨论列向量</li>
<li>我们想想，如果这些向量每一列都相互正交，Gram矩阵应该长什么样，变成了对角阵。</li>
<li>你再想想如果每一个向量都是单位向量，那对角线变成了什么样，单位矩阵！！！</li>
<li>所以我们换一个写法，把向量组拼成矩阵，这就是矩阵的乘法，不要说没学过，就是矩阵乘向量然后拼一块。</li>
<li><p>所以$ A^T A = I$, 这就是正交阵的定义！</p>
</li>
<li><p>矩阵乘法的定义和正交矩阵的定义就来了，不管你有没有学过，反正这讲完了就都应该学过了。</p>
</li>
</ul>
<h2 id="线性映射-amp-线性变换（看时间，待定）"><a href="#线性映射-amp-线性变换（看时间，待定）" class="headerlink" title="线性映射&amp;线性变换（看时间，待定）"></a>线性映射&amp;线性变换（看时间，待定）</h2><ul>
<li>二维矩阵中的两个特殊的变换，旋转与反射。X向量乘上一个矩阵=另一个向量。</li>
<li>所以我们可以把乘矩阵理解成一种变换，这个很重要，前面大家可能接触过乘上可逆矩阵就是初等变换（行变列变），还有可能接触过过渡矩阵给空间的基做变换。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/6内积与Gram.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/6内积与Gram.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="线性映射初步"></li>
</ul>
<h3 id="线性映射定义"><a href="#线性映射定义" class="headerlink" title="线性映射定义"></a>线性映射定义</h3><ul>
<li>所以我们可以粗浅的定义线性映射为乘矩阵，这种映射可以是$R^m \rightarrow R^n $的，特别的，我们把$R^n \rightarrow R^n $叫做线性变换</li>
</ul>
<h3 id="特殊-正交变换"><a href="#特殊-正交变换" class="headerlink" title="特殊-正交变换"></a>特殊-正交变换</h3><ul>
<li>更加特别的，我们把A矩阵是正交阵的这种叫做，正交变换</li>
<li>正交变换性质：保长保正交，所以体现出来就是单纯的旋转。<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/9内积与正交变换.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/9内积与正交变换.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="正交变换"></li>
</ul>
<h2 id="由Gram初见合同与二次型"><a href="#由Gram初见合同与二次型" class="headerlink" title="由Gram初见合同与二次型"></a>由Gram初见合同与二次型</h2><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/10Gram与二次型.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/10Gram与二次型.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Gram和二次型"></p>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】矩阵相关问题讲课资料</title>
    <url>/2022/11/24/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B2%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>朋辈辅导师第十二周直播课-矩阵相关典型问题的备课资料，大家有需要自取，备课本有点乱，建议配合视频一起食用。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/F1D5448BCDB824AACC5FB3DF2F454490">矩阵相关典型问题</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="矩阵相关问题"><a href="#矩阵相关问题" class="headerlink" title="矩阵相关问题"></a>矩阵相关问题</h1><p>[toc]</p>
<h2 id="矩阵的基本盘"><a href="#矩阵的基本盘" class="headerlink" title="矩阵的基本盘"></a>矩阵的基本盘</h2><h3 id="可逆定义定义及相关性质及求逆阵的方法"><a href="#可逆定义定义及相关性质及求逆阵的方法" class="headerlink" title="可逆定义定义及相关性质及求逆阵的方法"></a>可逆定义定义及相关性质及求逆阵的方法</h3><ul>
<li>可逆的定义及相关性质<blockquote>
<p>$若\exists B,AB=BA=I，则称A为可逆阵，B为A的逆阵,记作：A^{-1} = B $</p>
</blockquote>
</li>
<li>性质：<blockquote>
<p>$(ABC)^{-1} = C^{-1}B^{-1}A^{-1} $(proof)<br>行列式不为零则可逆<br>……</p>
</blockquote>
</li>
<li><p>逆阵唯一性</p>
<blockquote>
<script type="math/tex; mode=display">
  AB =AC =I  
  则B = BI = B(AC) = (BA)C = C</script></blockquote>
</li>
<li><p>拓展唯一性例题的解法<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0唯一性表示例题1.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0唯一性表示例题1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="唯一性例题"><br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0唯一性表示例题2.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0唯一性表示例题2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="解法2"></p>
</li>
<li><p>保可逆，反序可逆</p>
<blockquote>
<p>A可逆，B可逆，则AB可逆<br>$proof: ABB^{-1}A^{-1} = I $<br>若AB = I ，BA也可逆。</p>
</blockquote>
</li>
<li>求逆方法有三：增广，伴随，0化式（看见多项式赢麻啦）<blockquote>
<p>增广矩阵的机理<br>伴随公式的引申<br>0化式，关于矩阵的多项式，例题，关于特征多项式（Caley定理）<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0化式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/0化式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0化式"></p>
</blockquote>
</li>
</ul>
<h3 id="正交及相关性质"><a href="#正交及相关性质" class="headerlink" title="正交及相关性质"></a>正交及相关性质</h3><blockquote>
<p>$A^TA = I,即A^{-1} = A^T,则称A为正交阵 $<br>性质：矩阵乘的转置,与矩阵乘的求逆类似</p>
</blockquote>
<ul>
<li>保长、保内积、保正交<blockquote>
<p>$我们知道向量的模长度公式是吧，对于列向量X，它的模长为||X||^2 = X^TX(内积的表示) ，所以列向量AX(A为正交阵)为||AX||^2 = X^TA^TAX ——保长性$<br>$保内积类似，(X,Y) = (AX,AY) = X^TY $<br>$保正交:两种理解：<br>A正交，B正交，则AB正交<br>X \perp Y \Leftrightarrow AX \perp AY $</p>
</blockquote>
</li>
<li>线性变换初步<blockquote>
<p>线性变换与内积空间来理解, Gram阵</p>
</blockquote>
</li>
<li>每列为单位向量且相互正交，且则阵正交<blockquote>
<p>用矩阵乘法去理解。</p>
</blockquote>
</li>
</ul>
<h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><h3 id="秩的xdm"><a href="#秩的xdm" class="headerlink" title="秩的xdm"></a>秩的xdm</h3><ul>
<li>阶梯阵概念，及其与向量组秩的联系。<blockquote>
<p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>所以三种同解变形，其实就代表着三种初等变换。</p>
</blockquote>
</li>
<li>秩一阵<blockquote>
<p>我们来看一个矩阵，秩一阵，可分解为两个向量之间的乘积。</p>
</blockquote>
</li>
<li><p>我们在最后再来谈秩的各种公式的关系</p>
<blockquote>
<ul>
<li>满秩则有唯一解<br>$proof: \because r(A) = n $<br>$\therefore \{\alpha_1,……,\alpha_n\}可作为一组基 $<br>$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>$坐标即为唯一解 $</li>
<li>满秩则可逆<br>$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li>
</ul>
</blockquote>
</li>
<li><p>所以说到这就只需要明确一个事情，满秩，行向量组列向量组无关，行列式不等于0，可逆，只有唯一解，非奇异这都是等价的概念</p>
</li>
</ul>
<h3 id="各种各样的秩公式"><a href="#各种各样的秩公式" class="headerlink" title="各种各样的秩公式"></a>各种各样的秩公式</h3><h4 id="分块秩公式"><a href="#分块秩公式" class="headerlink" title="分块秩公式"></a>分块秩公式</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4分块秩公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4分块秩公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="分块秩公式"></p>
<h4 id="积阵秩公式"><a href="#积阵秩公式" class="headerlink" title="积阵秩公式"></a>积阵秩公式</h4><ul>
<li>乘积不增秩公式<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4不增秩公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4不增秩公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="不增秩公式"></li>
<li>积0公式<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4不增秩公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4不增秩公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="积0公式"></li>
<li>转置积秩公式<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4积0公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4积0公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="内积秩公式"></li>
</ul>
<h4 id="加减秩公式"><a href="#加减秩公式" class="headerlink" title="加减秩公式"></a>加减秩公式</h4><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4加减秩公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/4加减秩公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="加减秩公式"></p>
<h3 id="奇妙的秩一阵"><a href="#奇妙的秩一阵" class="headerlink" title="奇妙的秩一阵"></a>奇妙的秩一阵</h3><ul>
<li>用一个例题来说明<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1秩一阵例题.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/1秩一阵例题.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="秩一阵例题"></li>
</ul>
<h4 id="提一嘴先不讲"><a href="#提一嘴先不讲" class="headerlink" title="提一嘴先不讲"></a>提一嘴先不讲</h4><ul>
<li>秩一阵的特征值</li>
<li>秩一阵+平移公式+特征值与行列式的关系</li>
</ul>
<h2 id="下降公式"><a href="#下降公式" class="headerlink" title="下降公式"></a>下降公式</h2><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式例题.png" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式例题.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="换位公式例题"></p>
<h3 id="换位公式1-0"><a href="#换位公式1-0" class="headerlink" title="换位公式1.0"></a>换位公式1.0</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式1.0.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式1.0.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="换位公式1"></p>
<h3 id="换位公式2-0"><a href="#换位公式2-0" class="headerlink" title="换位公式2.0"></a>换位公式2.0</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式2.0.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式2.0.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="换位公式2"></p>
<h3 id="换位公式3-0及特征值（带拓展，看时间）"><a href="#换位公式3-0及特征值（带拓展，看时间）" class="headerlink" title="换位公式3.0及特征值（带拓展，看时间）"></a>换位公式3.0及特征值（带拓展，看时间）</h3><p><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式3.0.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/3换位公式3.0.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="换位公式3"></p>
<h2 id="奇妙的伴随阵"><a href="#奇妙的伴随阵" class="headerlink" title="奇妙的伴随阵"></a>奇妙的伴随阵</h2><ul>
<li>伴随阵的定义</li>
<li>伴随公式的推导<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2伴随阵定义及相伴公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2伴随阵定义及相伴公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="伴随阵及相伴公式"></li>
</ul>
<h3 id="相关行列式值的推导"><a href="#相关行列式值的推导" class="headerlink" title="相关行列式值的推导"></a>相关行列式值的推导</h3><ul>
<li>相关行列式的值的计算<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2各种行列式值之间的关系.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2各种行列式值之间的关系.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="相关行列式的值"></li>
</ul>
<h3 id="相伴秩公式"><a href="#相伴秩公式" class="headerlink" title="相伴秩公式"></a>相伴秩公式</h3><ul>
<li>古典秩定义<br><img src="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2相伴秩公式.jpg" class="lazyload placeholder" data-srcset="https://volca-pict.oss-cn-beijing.aliyuncs.com/images/2相伴秩公式.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="相伴秩公式"></li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学关系</title>
    <url>/2023/02/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>蒟蒻博主缓考了离散，于是开始芝士总结与复习，进度（2/5）</p>
<span id="more"></span>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><h3 id="关系定义"><a href="#关系定义" class="headerlink" title="关系定义"></a>关系定义</h3><ul>
<li>关系：我们知道关系就是两个事物之间的联系，抽象一下，具体是啥关系不重要，哪两个东西在一起很重要。所以我们定义如下：<ul>
<li>$若集合R \subseteq X\times Y ，则称R是X到Y的二元关系，简称关系。$</li>
<li>若R是X到X的关系，也称R是X上的二元关系。</li>
<li>$我们可以把&lt; x , y &gt;\in R 记作xRy $</li>
<li>$&lt; x , y &gt;\notin R记作x\bar Ry $</li>
</ul>
</li>
<li>特殊情况：<ul>
<li>$R = \phi，称为空关系 $</li>
<li>$R = U_X(U_X = X\times X)，称为全域关系 $</li>
<li>$R = I_X(I_X = \{&lt; x , x &gt;| x \in X \})，称为恒等关系 $</li>
</ul>
</li>
<li>定义域(domain)/值域(range)：<ul>
<li>$dom(R) = \{x \in X | \exists y \in Y : &lt; x , y &gt; \in R \}, dom(R) \subseteq X $</li>
<li>$ran(R) = \{y \in Y | \exists x \in X : &lt; x,y&gt; \in R \}, ran(R) \subseteq Y $</li>
<li>后面这种类似的东西我都只写一个，另一个类比</li>
</ul>
</li>
<li>矩阵/关系图表示：<ul>
<li>用矩阵和图的方式来表示一个关系（DS课学过图和矩阵表示方法，很像）<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="关系性质"><a href="#关系性质" class="headerlink" title="关系性质"></a>关系性质</h3><ul>
<li>五个性质：记住他们的定义、矩阵的特征、图的特征</li>
<li>这些性质的前提是R为非空集合X上的关系</li>
<li>定义<ul>
<li>自反：$R满足 \forall x (x \in X \rightarrow &lt; x,x&gt; \in R) $</li>
<li>反自反：$R满足 \forall x (x \in X \rightarrow &lt; x,x&gt; \notin R) $</li>
<li>对称：$R满足 \forall x \forall y (x \in X \wedge y \in X \wedge xRy \rightarrow yRx) $</li>
<li>反对称：$R满足 \forall x \forall y (x \in X \wedge y \in X \wedge xRy \wedge x \neq y \rightarrow y \bar Rx)  $</li>
<li>传递：$R满足 \forall x \forall y \forall z(x \in X \wedge y \in X \wedge z \in X \wedge xRy \wedge yRz \rightarrow xRz) $</li>
<li>例：恒等关系是自反、对称、传递的；“&lt;”关系是反自反、反对称、传递的。</li>
</ul>
</li>
<li>矩阵与图的特征<ul>
<li>见图：<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li>关于$\cup、\cap、-、\sim、\oplus $等运算，关系就是二元序偶集的一种，可以照搬运算。</li>
<li>有三大新运算：复合、逆（注意与取反区分）、闭包</li>
</ul>
<h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><ul>
<li>定义：R为X到Y的关系，S是Y到Z的关系<ul>
<li>$则R\cdot S = \{&lt; x,z&gt; | \exists y \in Y: xRy \wedge ySz \} $</li>
<li>运算不满足交换律，但满足结合律。</li>
</ul>
</li>
<li>复合的矩阵表示就是俩矩阵相乘（），细想一下逻辑完全符合</li>
<li>性质：<ul>
<li><script type="math/tex; mode=display">
> ...</script></li>
</ul>
</li>
<li>复合运算的定义域与值域讨论：<ul>
<li>我们把关系作用于集合，定义为：<ul>
<li>$R是X到Y的集合，R[A] = \{y \in Y | \exists x \in A: &lt; x,y&gt; \in R \}, R^{-1}同理 $</li>
</ul>
</li>
<li>所以我们易证：<ul>
<li>$dom(R \cdot S) = R^{-1}[domS], ran(R \cdot S) = R[ranR] $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逆关系"><a href="#逆关系" class="headerlink" title="逆关系"></a>逆关系</h3><ul>
<li>定义：记作$R^{-1} $<ul>
<li>关系中的每个有序偶的第一元与第二元对换</li>
<li>在矩阵上表现为原矩阵的转置$M_R^T $</li>
<li>关系图上表示为每一条边反向</li>
</ul>
</li>
<li>注意与$\sim R $区分</li>
</ul>
<h3 id="关系五大性质对应的判断条件"><a href="#关系五大性质对应的判断条件" class="headerlink" title="关系五大性质对应的判断条件"></a>关系五大性质对应的判断条件</h3><ul>
<li>R是A上的二元关系<ul>
<li>$R是自反的 \iff I_A \subseteq R $</li>
<li>$R是反自反的 \iff I_A \nsubseteq R (I_A \cap R = \phi) $</li>
<li>$R是对称的 \iff R^{-1} = R $</li>
<li>$R是反对称的 \iff R^{-1} \cap R \subseteq I_A $</li>
<li>$R是传递的 \iff R \cdot R \subseteq R $</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>自反，对称，传递关系都是极大的条件，也就是说，任何一个关系，我都可以通过增加元素，使得其满足这三个性质。而反自反与反对称不行，所以诞生了闭包的运算，也就是通过添加元素，使得关系满足这三个性质形成的最小关系。</li>
<li>定义：关系R’为R的自反（对称、传递）闭包(它们都为A上的关系)，当且仅当满足：<ul>
<li>$R’是自反的 $</li>
<li>$R \subseteq R’ $</li>
<li>$对于A上的任何一个自反（对称、传递）的关系R’’，R \subseteq R’’ \rightarrow R’ \subseteq R’’(可以看作是一种极小化,这一条称为闭包的最小性) $</li>
<li>R的自反、对称、传递闭包分别记作：r(R),s(R),t(R)</li>
</ul>
</li>
<li>由定义可知：<ul>
<li>R是自反（对称、传递）的，当且仅当R = r/s/t(R)</li>
</ul>
</li>
<li>R的三大闭包的存在性与唯一性证明：<ul>
<li>$r(R) = R \cup I_A $</li>
<li>$s(R) = R \cup R^{-1} $</li>
<li>$t(R) = \cup_{n=1}^\infty R^n $</li>
<li>证明都非常的有意思，s(R)的证明直接通过定义，r/t的证明可以证明等式两边相互包含。</li>
</ul>
</li>
<li>传递闭包缩小定理：对于有限集A，A中有n个元素，则 $t(R) = \cup_{i=0}^n R^i $<ul>
<li>可证：$对于任意k &gt; 0 都有R^{n+k} \subseteq \cup_{i=0}^n R^i $</li>
</ul>
</li>
<li>性质：<ul>
<li>闭包运算不破坏包含序关系，即：$若R_1 \subseteq R_2 ，则r/s/t(R_1) \subseteq r/s/t(R_2) $</li>
<li>闭包运算也基本不破坏R本身的三大性质，除s(R)会破坏R的传递性（即R传递，s(R)不一定传递，这是一大不对称因素）</li>
<li>所以性质2导致s与t运算不可逆 $（st(R) 不一定= ts(R) 但 st(R) \subseteq ts(R) ） $</li>
<li>尝试证明<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="序关系"><a href="#序关系" class="headerlink" title="序关系"></a>序关系</h2><ul>
<li>序关系有偏序关系，严格偏序关系（拟序关系），全序关系，良序关系</li>
</ul>
<h3 id="序关系定义"><a href="#序关系定义" class="headerlink" title="序关系定义"></a>序关系定义</h3><ul>
<li>偏序：R满足自反，反对称，传递三个性质，则R是A上的偏序关系，用&lt; A , &lt;= &gt;表示偏序结构</li>
<li>严格偏序：是自反改为反自反的偏序，就是说一定要比出个高低。<ul>
<li>但我们发现由反自反与传递可以推出反对称（可以使用反证法，假设关系不是反对称，则一定能推出&lt; x , x &gt;的元素），所以我们定义只需反自反、传递就行。</li>
<li>严格偏序和偏序有如下关系：$&lt; = \leq - I_A $</li>
</ul>
</li>
<li>全序：若&lt; A , &lt;= &gt;是偏序结构<ul>
<li>$\forall x,y \in A \rightarrow x &lt;= y \vee y &lt;= x ,则称&lt; A , &lt;= &gt;全序结构或者链$（也就是说任意两元素都是可比的）</li>
</ul>
</li>
</ul>
<h3 id="覆盖与哈斯图"><a href="#覆盖与哈斯图" class="headerlink" title="覆盖与哈斯图"></a>覆盖与哈斯图</h3><ul>
<li>由于序关系是传递的，所以我们能够简化关系图，即若x &lt; y, y &lt; z, 则我再图中只画出这两条线，因为x，z之间的关系显而易见，然后偏序关系中的自反关系在图中省略，即不画自圈，就得到了哈斯图。而我们要描述两个元素之间的关系，就需要看它们之间是否夹着不上不下的元素，没有的话这两个元素看上去在我们的序关系中是相邻的，我们称之为覆盖。</li>
<li>覆盖：$y覆盖x \Leftrightarrow x &lt; y \wedge \neg \exists z(z \in A \wedge x &lt; z \wedge z &lt; y) $</li>
</ul>
<h3 id="偏序结构中的特殊元素"><a href="#偏序结构中的特殊元素" class="headerlink" title="偏序结构中的特殊元素"></a>偏序结构中的特殊元素</h3><ul>
<li>前提：$&lt; A, \leq&gt;是偏序结构，B \subseteq A $<ul>
<li>极大元：$b是B的极大元 \Leftrightarrow b \in B \wedge \forall x(x \in B \rightarrow x \leq b) $</li>
<li>最大元：$b是B的最大元 \Leftrightarrow b \in B \wedge \neg \exists x(x \in B \wedge x \leq b) $</li>
</ul>
</li>
<li>极大与最大的区别：极大是没比我大，最大是比啥都大，根源在于不是所有的元素之间都可比。</li>
<li>极小与最小同理。</li>
</ul>
<hr>
<ul>
<li>上界：$b是B的上界 \Leftrightarrow b \in A \wedge \forall x(x \in B \rightarrow x \leq b) $</li>
<li>最小上界：$b是B的最小上界 \Leftrightarrow b是B的上界 \wedge \forall x(x是B的上界 \rightarrow b \leq x) $</li>
<li>下界与最大下界同理。</li>
<li>一定要注意并不是所有元素之间都可以比较，所以可能上下界和最大最小元不存在</li>
</ul>
<h3 id="良序结构"><a href="#良序结构" class="headerlink" title="良序结构"></a>良序结构</h3><ul>
<li>定义：若一个偏序结构的每个非空子集都有<strong>最小元</strong>，则该结构为良序结构。</li>
<li>所以良序一定是全序，因为对于任意两个元素，我们都可以当作非空子集拎出来，然后它们俩必有一个最小元。<ul>
<li>但是全序并不一定是良序，因为可能存在一个无穷递降的序列，使得没有最小元。</li>
<li>所以我们可证：良序 $\Leftrightarrow $ 没有无穷递降序列的全序。</li>
</ul>
</li>
<li>又：全序关系中，任何非空子集的极小元与最小元等价，所以也可以表述上互换。</li>
</ul>
<h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><ul>
<li>等价关系满足：自反，对称，传递（模m同余的关系就是典型的等价关系）</li>
<li>由于传递性，我能用等价关系确定一个集合，叫等价类。<ul>
<li>A中与x有等价关系R的元素的集合，为x关于R的等价类，记作：$[x]_R $</li>
<li>$[x]_R = \{y | y \in A \wedge xRy \}$</li>
</ul>
</li>
<li>性质：等价关系与等价类满足下列性质<ul>
<li>$[x]_R = [y]_R \Leftrightarrow xRy $(传递性证)</li>
<li>$x,y \in A\wedge x\bar Ry \rightarrow [x]_R \cap [y]_R = \phi $（反证法）</li>
<li>$\cup_{x \in A}[x]_R = A $(全覆盖定理，$x \in [x]_R $可证)</li>
</ul>
</li>
<li>商集：A上关于R的所有等价类的集合，记作A/R</li>
<li>划分: $对于A，若有\pi \subseteq \rho(A), 且\pi 满足三个条件，则称\pi 为A的划分 $<ul>
<li>$\forall S \in \pi, S \neq \phi $</li>
<li>$\forall B,C \in \pi, 若B \neq C 则B \cap C = \phi $</li>
<li>$\cup \pi = A $</li>
<li>$\pi 中元素为划分块， \sharp \pi 称作$ <strong>秩</strong></li>
</ul>
</li>
<li>由上我们可以知道A上的每个等价关系唯一确定的商集就是一个划分</li>
<li>$由A上的划分\pi 我们令R_\pi = \{&lt; x,y&gt; | \exists S \in \pi (x,y \in S) \},我们可以唯一确定一个等价关系R_\pi，且A/R_\pi = \pi $</li>
</ul>
<blockquote>
<p>待完善。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>关系</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学图论</title>
    <url>/2023/02/08/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在写了在写了，鳖急憋急。。。</p>
<span id="more"></span>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li>图其实也就是点与关系的集合</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>图论的概念特多</li>
<li>无向图：$如果 \Psi: E \rightarrow \{\{v_1, v_2 \} | v_1 \in V, v_2 \in V \} $</li>
</ul>
<h2 id="图的运算"><a href="#图的运算" class="headerlink" title="图的运算"></a>图的运算</h2><h2 id="路径、回路、连通性"><a href="#路径、回路、连通性" class="headerlink" title="路径、回路、连通性"></a>路径、回路、连通性</h2><h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><h2 id="哈密顿回路"><a href="#哈密顿回路" class="headerlink" title="哈密顿回路"></a>哈密顿回路</h2><h2 id="图的矩阵表示"><a href="#图的矩阵表示" class="headerlink" title="图的矩阵表示"></a>图的矩阵表示</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2>]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>图论</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学函数</title>
    <url>/2023/02/08/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>蒟蒻博主缓考了离散，于是开始芝士总结与复习，进度（3/5）</p>
<span id="more"></span>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>函数是一种特殊的关系，这种关系满足单值性，即从X到Y，元素x不能劈叉<ul>
<li>$即二元关系f满足：若&lt; x, y_1&gt; \in f 且 &lt; x, y_2&gt; \in f 则y_1 = y_2 $</li>
<li>这样的f我们称为X到Y的<strong>部分函数</strong></li>
<li>x叫源像点，y是像点，可记为$y=f(x) $</li>
</ul>
</li>
<li>函数的定义域与值域的定义完全照搬关系的<ul>
<li>$若x \in dom(f), 则称f在x处有定义，记为：“f(x) \downarrow” $</li>
<li>$无定义记为：“f(x) \uparrow” $</li>
</ul>
</li>
<li>注意我们上述说的都是<strong>部分函数</strong>。<ul>
<li>我们把$dom(f) = X $的函数称为<strong>全函数</strong>，简称<strong>函数</strong></li>
<li>$dom(f) \subset X的函数称为严格部分函数 $</li>
<li>$ran(f) = Y $ ，称f为X到Y<strong>上</strong>的部分函数。</li>
<li>$ran(f) \subset Y $ ，称f为X到Y<strong>内</strong>的部分函数。</li>
<li>1-1部分函数：$当f(x_1)=f(x_2)时，都有x_1=x_2 $</li>
</ul>
</li>
<li>函数的限制：<ul>
<li>$若A \subseteq X，则f\cap(A\times X)是从A到Y的函数，称为f在A上的限制，记作f|_A$</li>
<li>$又称f为f|_A到X上的延拓 $</li>
</ul>
</li>
<li>部分函数f的像与源像（f是X到Y的部分函数，$A \subseteq X 且 B \subseteq Y $）：<ul>
<li>$f[A] = \{f(x)|x \in A \wedge f(x)\downarrow \} $</li>
<li>$f^{-1}[B] = \{x \in X | f(x) \in B \wedge f(x)\downarrow \} $</li>
<li>$ dom( f ) = f ^ { -1 } [Y] ; ran(f) = f[ X ] $<ul>
<li>实际上这里的f和我们上文中的f:X-&gt;Y已经发生了变化，变成了集合到集合的关系，但不影响理解。</li>
</ul>
</li>
</ul>
</li>
<li>常用定理（不太重要，但可以看看，熟悉函数的性质）：<ul>
<li>$A_1 \subseteq A_2 \subseteq X，则f[A_1] \subseteq f[A_2] \subseteq ran(f) (f^{-1}同理)$</li>
<li>缩放定理：<ul>
<li>$A \subseteq dom(f)，则A \subseteq f^{-1}[f[A] ] $</li>
<li>$B \subseteq ran(f)，则B = f[f^{-1}[B]] $</li>
<li>(有点不对称，原因是 $\sharp dom &gt; \sharp ran $)</li>
</ul>
</li>
<li>$若A \subseteq \rho (X), B \subseteq \rho (Y) $<ul>
<li>$f[\cup A] = \cup \{f[\alpha] | \alpha \in A \} $</li>
<li>$f[\cap A] \subseteq \cap \{f[\alpha] | \alpha \in A \}(A \neq \phi) $</li>
<li>$f^{-1}[\cup B] = \cup \{f^{-1}[\beta] | \beta \in B \} $</li>
<li>$f^{-1}[\cap B] = \cap \{f^{-1}[\beta] | \beta \in B \}(B \neq \phi) $(与第2条不对称)</li>
</ul>
</li>
<li>限制定理：<ul>
<li>$dom(f|_A) = A \cap domf $</li>
<li>$ran(f|_A) = f[A] $</li>
<li>$若A \subseteq domf，则f|_A是A的全函数 $</li>
</ul>
</li>
</ul>
</li>
<li>全函数集合：<ul>
<li>$Y^X = \{f | f: X \rightarrow Y\} $</li>
<li>$每个X中的元素都可以任意选择一个Y中的元素，所以\sharp(Y^X) = (\sharp Y)^{(\sharp X)} $</li>
</ul>
</li>
</ul>
<h2 id="函数的复合"><a href="#函数的复合" class="headerlink" title="函数的复合"></a>函数的复合</h2><ul>
<li>函数是一种特殊的关系，所以函数的复合与关系的复合是一样的，我们定义$f \cdot g $为X到Z的关系<ul>
<li>但是由于我们常用f(x)的方式来表示函数，所以我们把$f \cdot g $的复合关系表示为复合函数的话，写法为$g(f(x)) = (g \cdot f)(x) $</li>
</ul>
</li>
<li>定义域与值域讨论：f是X到Y的部分函数，g是Y到z的部分函数<ul>
<li>$dom(g \cdot f) = f^-1[dom g] (ran类似)$（关系怎么证这就怎么证）</li>
<li>$f与g都是全函数，则g \cdot f也是全函数 $（由上得）</li>
</ul>
</li>
<li>结合律照样满足（关系一样）</li>
<li>$若f:X\rightarrow X, 则我们可以定义f的n次幂，f^n$(关系可以由矩阵表示，联系方阵与矩阵的n次幂定义)</li>
</ul>
<h2 id="函数的性质"><a href="#函数的性质" class="headerlink" title="函数的性质"></a>函数的性质</h2><ul>
<li>三大性质：（注意前提是全函数）<ul>
<li>满射：$f是满射 \iff \forall y(y \in Y \rightarrow \exists x(x \in X \wedge y = f(x) ) ) $</li>
<li>单射：$f是单射 \iff \forall x_1 \forall x_2(x_1 \in X \wedge x_2 \in X \wedge f(x_1) = f(x_2) \rightarrow x_1 = x_2) $</li>
<li>满射 + 单射 = 双射</li>
</ul>
</li>
<li>$若f和g都是满/单/双射时，g\cdot f也是满/单/双射 $（按定义证）</li>
<li>左满右单定理：<ul>
<li>$若g\cdot f是满射，则g是满射 $</li>
<li>$若g\cdot f是单射，则f是单射 $（反证法）</li>
<li>$若g\cdot f是双射，则\dots $</li>
<li>可以意象化的理解</li>
</ul>
</li>
</ul>
<h2 id="逆函数"><a href="#逆函数" class="headerlink" title="逆函数"></a>逆函数</h2><ul>
<li><p>还是那句话，函数是一种特殊的关系，所以函数的复合和关系的复合内容基本一致，但是函数有他的特殊性，就是单值性。所以我们如果沿用关系的逆的定义，会很麻烦，因为这样一个函数反过来不一定满足单值性，所以我们这里函数的逆明显不同于关系的逆，而更加的相像与矩阵的逆，而且复合是矩阵乘，所以在接触函数的逆的时候我们可以时刻联系矩阵运算</p>
</li>
<li><p>我们定义了左逆右逆： $若f:X \rightarrow Y $</p>
<ul>
<li>$若有g:Y \rightarrow X，使得g \cdot f = I_x，则f左可逆，g为f的左逆 $（右逆同理）</li>
<li>若有g同时为左逆和右逆，则f可逆，g为f的逆</li>
<li>左逆右逆不一定存在，也不一定唯一</li>
</ul>
</li>
<li>左右可逆的条件：<ul>
<li>$左可逆 \iff 单射 $</li>
<li>$右可逆 \iff 满射 $</li>
<li>$可逆 \iff 双射 $</li>
<li>可以用左满右单定理证出一边，用单射满射的性质构造出g来证另一边</li>
<li>而我有一种新的理解，上文说到，我们可以时刻联系矩阵运算，满射的话X范围会比Y大，单射的话Y的范围会比X要大，对应的正是行数大于列数及列数大于行数的长条形矩阵（或说行满秩与列满秩），我们也可以构造出左边的逆与右边的逆（这里的逆矩阵也是长条形，当然只是类似），注意函数的左右是反过来的，所以矩阵的左乘和右乘的最后要在名称上称为右逆和左逆。（我这里不再细说，感兴趣欢迎来讨论）</li>
</ul>
</li>
<li>$若f可逆，则f的逆唯一，且f的逆关系f^{-1}即为f的逆函数 $<ul>
<li>唯一性证明：$g_1 = g_1 \cdot I_Y = g_1 \cdot (f \cdot g_2) = I_X \cdot g_2 = g_2 $</li>
<li>关于 $f^{-1} $是f的逆函数：证明不难，但是我们注意到，$f^{-1} $的矩阵表示为f的矩阵的转置，而不是矩阵的逆，这里主要是由于关系复合的乘法与真正的矩阵乘是有差别的，但是我们可以类比单位阵的意味，这里的矩阵可逆是正交的。</li>
</ul>
</li>
<li>可逆与复合的交换：$f可逆，g可逆，则g \cdot f可逆，且(g \cdot f )^{-1} = f^{-1} \cdot g^{-1} $<ul>
<li>证：$(g \cdot f) \cdot (f^{-1} \cdot g^{-1}) = I_X(左乘同理) $</li>
</ul>
</li>
</ul>
<h2 id="集合的特征函数"><a href="#集合的特征函数" class="headerlink" title="集合的特征函数"></a>集合的特征函数</h2><ul>
<li>特征函数全集映射到{0,1}上，原理很简单，但是可以简化很多逻辑表达式的计算问题，但是要真正派上大用场得等到下一节-基数。</li>
<li>定义：设U是全集，A是U的子集<ul>
<li>$定义A的特征函数\Psi_A:U\rightarrow \{0,1\} $<script type="math/tex; mode=display">
\Psi_A(x)=
\begin{cases}
1 \quad 若x \in A \\\\
0 \quad 若x \notin A
\end{cases}</script></li>
</ul>
</li>
<li>性质：<ul>
<li>$\forall x(\Psi_A(x) = 0) \iff A = \phi $</li>
<li>$A = U \iff \dots $</li>
<li>$\forall x(\Psi_A(x) \leq \Psi_B) \iff A \subseteq B $</li>
<li>$A = B \iff \dots $</li>
<li>$\Psi_{A \cap B} = \Psi_A \cdot \Psi_B $</li>
<li>$\Psi_{A \cup B} = \Psi_A + \Psi_B - \Psi_{A \cap B} $</li>
<li>$\Psi_{\sim A} = 1 - \Psi_A $</li>
<li>$\Psi_{A - B} = \Psi_{A \cap \sim B} = \dots $</li>
</ul>
</li>
<li>证明俩逻辑表达式相等可以转化为证明特征函数相等</li>
</ul>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学自然数归纳法与基数</title>
    <url>/2023/02/08/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>蒟蒻博主缓考了离散，于是开始芝士总结与复习，进度（4/5）</p>
<span id="more"></span>
<h1 id="自然数归纳法与基数"><a href="#自然数归纳法与基数" class="headerlink" title="自然数归纳法与基数"></a>自然数归纳法与基数</h1><h2 id="自然数"><a href="#自然数" class="headerlink" title="自然数"></a>自然数</h2><h3 id="自然数构造"><a href="#自然数构造" class="headerlink" title="自然数构造"></a>自然数构造</h3><ul>
<li><p>自然数依托于用集合论构造，各种性质用Peano公理推导，所以构造出的自然数需要满足Peano公理</p>
</li>
<li><p>集合的后继：$对于集合A，其后继集合定义为A^+ = A \cup \{A\}(所以每个集合的后继是唯一的) $</p>
<ul>
<li>所以我们知道后继集合的几点性质：<ul>
<li>$A \subseteq A^+(A的元素在A^+里)；A \in A^+ (A本身也在A^+里) $</li>
<li>$A^+ \neq \phi $</li>
</ul>
</li>
<li>例：<ul>
<li>$\phi^+ = \{\phi \} $</li>
<li>$\{\phi\}^+ = \{\phi, \{ \phi \} \} $</li>
</ul>
</li>
</ul>
</li>
<li><p>所以由上述性质：冯·诺依曼(Von Neumann)给出了他构造自然数系统&lt; N,+,·&gt;的方案</p>
<ul>
<li><script type="math/tex; mode=display">
    \begin{align*}
        &0 = \phi    \\
        &1 = 0^+ = \phi^+ = \{ 0 \}     \\
        &2 = 1^+ = \{\phi \}^+ = \{0,1\}     \\
        &3 = 2^+ = 2 \cup \{2\} = \{0,1,2 \}     \\
        &...     \\
        &n+1 = n^+ = \{0,1,2,...,n \}
    \end{align*}</script></li>
<li>我们可以采用集合论中学到的归纳定义法来定义自然数：<ul>
<li>$0 \in N (基础项) $</li>
<li>$若 n \in N , 则 n^+ \in N (归纳项) $</li>
<li>$只有有限次应用1与2得到的元素才是自然数 $</li>
</ul>
</li>
</ul>
</li>
<li><p>引理：$若n \in N, 则\cup n^+ = n $</p>
</li>
</ul>
<h3 id="Peano公理及运算性质"><a href="#Peano公理及运算性质" class="headerlink" title="Peano公理及运算性质"></a>Peano公理及运算性质</h3><ul>
<li>我们前面说构造的自然数需要满足Peano公理，Peano公理的内容如下：<ul>
<li>P1: $0 \in N $(归纳基础项)</li>
<li>P2: $若n \in N, 则n^+ \in N $(归纳项)</li>
<li>P3: $若n \in N, 则 n^+ \neq 0 $(没有以0为后继的项，0是初始项)</li>
<li>P4: $若n,m \in N \wedge n^+ = m^+, 则n = m $(后继的唯一性,可由上述引理得到)</li>
<li>P5: $满足P1与P2的极小化 $</li>
</ul>
</li>
<li><p>由Peano公理以及后继的性质我们可以知道作为集合的自然数的几点性质：</p>
<ul>
<li>传递性: $若n_1 \in n_2, n_2 \in n_3, 则 n_1 \in n_3 $</li>
<li>三岐性: $对于任意两个n_1, n_2 \in N, 满足(n_1 \in n_2) \vee (n_1 = n_2) \vee (n_2 \in n_1) $</li>
<li>良基性: $不存在一个自然数的无穷递降序列n_{1\sim}，使得n_{i+1} \in n_i $</li>
</ul>
</li>
<li><p>所以我们由Peano公理的三大性质可以知道，我们可以定义出自然数元素之间的关系，以及自然数的运算，我们称之为大/小于，加法，乘法。</p>
<ul>
<li>小于: $若m,n \in N 且 m \in n, 则我们称m小于n，记作m&lt;n $(很明显，小于关系是一个逆序关系)</li>
<li>由此我们也可以类推出小于等于关系，它是一个（全）偏序关系，由于良基性，它也会是一个良序关系。</li>
<li>加法: $m+0 = 0; m + n^+ = (m + n)^+ $</li>
<li>乘法: $m \cdot 0 = 0; m \cdot n^+ = m \cdot n + m $   (自己拿两个数加一加乘一乘就能理会其中的归纳意味)</li>
</ul>
</li>
</ul>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><ul>
<li>上文中Peano公理的极小化有几种表述的方法，详细见集合论一章的描述，其中有一种极小化方法如下：<ul>
<li>$若S \subseteq N 满足0 \in S且n \in S \rightarrow n^+ \in S(1/2条)，则S = N $</li>
</ul>
</li>
<li>这个极小化方法是数学归纳法的基础，下面是数学归纳法的叙述（第一归纳法）<ul>
<li>$设P(n)是自然数论域上的性质(或谓词)，若能证明1与2，则对所有n\in N,P(n)为真 $<ol>
<li>$P(0)为真 $</li>
<li>$对任何n \in N, P(n) \Rightarrow P(n^+) $</li>
</ol>
</li>
<li>可表述为：$P(0) \wedge (\forall n)(P(n) \rightarrow P(n+1)) \Rightarrow \forall n P(n) $</li>
<li>基础项也可从非0数k开始：<ul>
<li>$P(k) \wedge (\forall n)(n \geq k \wedge P(n) \rightarrow P(n+1)) \Rightarrow \forall n(n \geq k \rightarrow P(n)) $</li>
</ul>
</li>
</ul>
</li>
<li>我们可以从第一归纳法推出第二归纳法：<ul>
<li>$\forall n(\forall k(k&lt;n \rightarrow P(k)) \rightarrow P(n)) \Rightarrow \forall nP(n) $</li>
<li>上述归纳不需要单独列出P(0)条件，因为任取到n=0时，条件等价于P(0)<blockquote>
<p>…证明过程</p>
</blockquote>
</li>
</ul>
</li>
<li>二维归纳原理：暂略</li>
</ul>
<h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><h3 id="集合大小的度量与比较"><a href="#集合大小的度量与比较" class="headerlink" title="集合大小的度量与比较"></a>集合大小的度量与比较</h3><ul>
<li>比较两个集合的大小有两个方法：<ul>
<li>计数法：数出元素的个数，谁大谁多。</li>
<li>愚人比宝：每次各取其一，看谁先取完。</li>
<li>对于一个无限集，计数法失效，但我们怎么用第二个方法？可以在该集合与某个自然数之间建立一个双射。</li>
</ul>
</li>
<li>等势：若在两个集合之间存在一个双射，则称集合对等（或等势），记作 $A \sim B $<ul>
<li>我们易知等势关系具有自反对称传递性，是等价关系</li>
</ul>
</li>
<li>集合是有穷集 当且仅当 它与一个自然数等势，且唯一（由三岐性反证法证明），这个自然数被称为有穷集合的<span id="jishu"><strong>基数</strong></span>，记作 $\sharp A $<ul>
<li>而若集合是无穷极，就不能与一个自然数等势</li>
</ul>
</li>
<li>定义了有穷集合的基数，我们就可以定义出对应关系与基数大小了<ul>
<li>$显然，A \sim B \Rightarrow \sharp A = \sharp B $</li>
<li>$若存在A到B的单射，则也就是A等势的自然数与B的自然数之间存在单射，所以\sharp A \leq \sharp B $</li>
<li>$若\sharp A \leq \sharp B且\sharp A \neq \sharp B，则记为\sharp A &lt; \sharp B $</li>
<li>由自然数的三岐性可知，任何两个基数之间可以比较大小</li>
<li>基数相等是等价关系，小于等于是偏序关系</li>
</ul>
</li>
<li>小技巧：我们可以通过tan函数建立任何一个连续的开区间与实数R的双射等势关系<ul>
<li>正是如此，我们发现无穷集合可以与它本身的真子集等势（这是无穷集合的一固有性质）</li>
</ul>
</li>
</ul>
<h3 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h3><ul>
<li>由上述表述，我们可发现无穷集合与有限集合的一点根本差别：<ul>
<li>任何与自身真子集等势的集合都是无穷集合</li>
<li>所以任何有限集都不能与自身的真子集对等</li>
</ul>
</li>
<li>上述对于有限集的叙述叫做抽屉原理（鸽笼原理），通俗的说：<ul>
<li>你有n+1本书，但是只有个抽屉，你就建立不了一个n+1与n的双射，一定会有一个抽屉放了不止一本书。</li>
<li>形式抽象化的表示为：<ul>
<li>$把s(s\geq 1)个元素分成t组，必有一个组至少有\lceil s/t \rceil 个元素(\lceil \rceil 为向上取整的记号) $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="无穷集"><a href="#无穷集" class="headerlink" title="无穷集"></a>无穷集</h3><ul>
<li>上文中提到了<a href="#jishu">有穷集合的基数</a>的概念，我们拓展它，让它不再局限在元素个数这一个概念，对于无限集，我们也定义它的基数，只是规定特殊的记号。<ul>
<li>$我们令\sharp N = \aleph_0 $</li>
<li>对于上文中关于有穷集合基数的大小的性质，都可以推广到基数上</li>
</ul>
</li>
<li>基数的定义：$F是集合组，\sim 是F上的等势关系，关系\sim在F上的等价类称为基数 $<ul>
<li>$对于A \in F 我们本应将基数记为[A]_\sim ，但我们沿用上面的记号以达到统一概念的目的，记为\sharp A$</li>
</ul>
</li>
<li>可数无穷集合：与自然数等势的集合我们称为可数无穷集合，基数为  $\aleph _0 $<ul>
<li>可数集合 = 有穷集合 + 无穷可数集合，其余均是不可数集合</li>
</ul>
</li>
<li>定理：无穷集的三个等价条件<ul>
<li>A是无穷集</li>
<li>A有可数无穷的子集（证明：可以从出去已选元素的A中选择元素，因为A是无穷的，所以取之不尽，这样就构造出了一个可数无穷的子集）</li>
<li>A有真子集与它等势</li>
</ul>
</li>
<li>上文中我们提到了<a href="#jishu">单射</a>可以确定两个集合基数的大小，满射也同样可以<ul>
<li>$存在A到B的满射 \iff \sharp B \leq \sharp A $</li>
<li>证明：</li>
<li><script type="math/tex; mode=display">
    \begin{align*}
        \Rightarrow \\
        &若从A \rightarrow B有满射f，则f右可逆\\
        &存在g:B \rightarrow A，使得f \cdot g = I_B\\
        &I_B是双射，所以g是单射\\
        &\therefore \sharp B \leq \sharp A \\
        \Leftarrow \\
        &若\sharp B \leq \sharp A,则有单射g:B \rightarrow A\\
        &g左可逆，存在f:A \rightarrow B使得f \cdot g = I_B\\
        &I_B是双射,所以f是满射
    \end{align*}</script></li>
</ul>
</li>
<li>还有几个有趣的问题：<ul>
<li>$N\times N \sim N $</li>
<li>$N \sim Q $</li>
<li>$N \sim Z $<blockquote>
<p>…</p>
</blockquote>
</li>
</ul>
</li>
<li>实数集合不可数(证明：在(0,1)上构造一个无穷序列，然后利用规则，找出一个数不属于这个序列，推出矛盾，实数集合不可数)，下面我们讨论它的基数<ul>
<li>引理：对于每个集合A，皆有 $\sharp A &lt; \sharp \rho(A) $<ul>
<li>$首先，我们可以定义g(a) = \{a\}使得A\rightarrow \rho(A),显然g是单射，所以\sharp A \leq \sharp \rho(A) $</li>
<li>$然后通过反证法来证明\sharp A \neq \sharp \rho (A) $</li>
</ul>
</li>
<li>因为不可数，所以 $\sharp N \neq \sharp R $，我们定义 $\sharp R = \aleph $</li>
<li>我们可以证明：$\sharp \rho(N) = \sharp R $<ul>
<li>证明非常的精彩，利用集合的特征函数，与实数的二进制编码</li>
<li>任意给定一个实数，写出实数的二进制编码，对于编码上的每一位，为1则表示在对应的集合中</li>
<li>这样我们就得到了一个实数到一个自然数集合的双射</li>
</ul>
</li>
<li>所以 $\sharp R = \sharp \rho(N) &gt; \sharp N $，即 $\aleph &gt; \aleph_0 $</li>
</ul>
</li>
<li>有意思的问题：<ul>
<li>$\sharp (R \times R) = \aleph $  (思路：找一个特定的值域为R的二元连续函数)</li>
</ul>
</li>
</ul>
<blockquote>
<p>待完善。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>自然数</tag>
        <tag>数学归纳法</tag>
        <tag>基数</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学集合论</title>
    <url>/2022/09/06/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>也系边上老师的课边做的一些笔记以及自己的一些想法，但有时候可能会拖更，分享给大家，有不妥之处，敬请评论区指正。</p>
<span id="more"></span>
<h1 id="集合的基本概念及其运算"><a href="#集合的基本概念及其运算" class="headerlink" title="集合的基本概念及其运算"></a>集合的基本概念及其运算</h1><h2 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h2><ul>
<li>集合要有明确特征，不能是模糊概念，如：高个子学生</li>
<li>集合的表示方法：<ul>
<li>枚举法</li>
<li>抽象法：用谓词来概括，$S=\{x|P(x)\}$<ul>
<li>抽象描述不唯一。</li>
<li>不能取 $p(x)为x \notin x$ ，否则罗素悖论<blockquote>
<p>$T=\{x|x \notin x\},有\forall x,x \in T \Leftrightarrow x \notin x$<br>$假设这里的x就是T，那么就有T \in T \Leftrightarrow T \notin T$ <br><br>猫了个打盹（）</p>
</blockquote>
</li>
<li>$所以其实抽象原则有点危险，Cantor悖论，理发师悖论，说谎者悖论。$</li>
<li>$悖论产生的原因：自引用，自作用。$</li>
</ul>
</li>
<li>归纳定义：包含基本项、归纳项、以及最小化。（可以类比一下上学期公理系统的定义）<ul>
<li>基本项和归纳项不难理解，归纳项就是推演规则。<blockquote>
<p>这里我们来定义一个集合A<br>$非空集合S_0 \subseteq A (基本项)$ <br><br>$一组规则，\forall x \in A,x \stackrel{这一组规则}{\longrightarrow} y,y \in A (归纳项)$</p>
</blockquote>
</li>
<li>这里重点辨析一下极小化：<blockquote>
<p>保证A中每个元素都可通过有限次使用1或2来获得。<br>$如果集合 S \subseteq A 也满足 1和2，则 A \subseteq S$<br>$（如果集合 S \subseteq A 也满足 1和 2，则 S = A ）$ <br><br>最小化很必要，就是说如果只有1和2两句话，A中有其他不符合1、2规则的元素也可以满足，归纳定义法定义的集合就不唯一！！！<br>为什么叫极小化，就是说A中没有其他多余的元素，是通过1、2能得到的最小集合，清清爽爽。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合的相等与包含"><a href="#集合的相等与包含" class="headerlink" title="集合的相等与包含"></a>集合的相等与包含</h2><blockquote>
<p>相等和包含的定义在高中的时候就说过了，这里说点不一样的。</p>
</blockquote>
<ul>
<li>集合与元素的排列次序与元素重复出现的次数无关<blockquote>
<p>体现为{1,2,3}={3,1,2}<br>{a,b,c}={a,a,c,b,b,c}(这个也叫多重集)</p>
</blockquote>
</li>
<li>相等与包含的等价表示<blockquote>
<p>$A=B \Leftrightarrow \forall x(x \in A \leftrightarrow x \in B)$<br>$A \subseteq B \Leftrightarrow \forall x (x \in A \rightarrow x \in B)$<br>$A \subset B \Leftrightarrow A \subseteq B \wedge A \neq B \Leftrightarrow \forall x(x \in A \rightarrow x \in B) \wedge \exists x(x \in B \wedge x \notin A)$</p>
</blockquote>
</li>
<li>集合的元素可以是集合<blockquote>
<p>所以这里就有必要辨析一下 $ “\in” 和 “\subseteq” $ 的区别<br>例：A={1,2,{1,2,3}}<br>$\therefore 1 \in A$<br><br>$\{1,2\} \subseteq A$<br><br>$\{1,2,3\} \in A$<br><br>$\{1,\{1,2,3\}\} \subseteq A $<br><br>在这里，“1”，“2”，“{1，2，3}”是平级的。这里我们可以类比电脑的文件夹存储方式。</p>
</blockquote>
</li>
<li>还有一个关系，咱们可以看看。<blockquote>
<p>$ 设A，B，C都是集合，若 A \subseteq B 且 B \subseteq C,则 A \subseteq C $<br>$ 但是，若A \in B,B \in C,则A不一定\in C $<br>$ 例： A = \{ 1 \},B = \{ \{ 1 \} \} , C = \{ \{ \{ 1 \} \} \} (晕.jpg) $</p>
</blockquote>
</li>
</ul>
<h2 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h2><ul>
<li>集合A的全部子集构成的集合 称为A的 幂集，记作 $ \rho(A) $。<blockquote>
<p>$ \rho ( A ) = \{ X | X \subseteq A \} $<br>$ \therefore B \subseteq A \iff B \in \rho ( A ) $</p>
</blockquote>
</li>
<li>基数，有穷集合A中所含有元素的个数称为 A 的基数。记作#A。<blockquote>
<p>对于A中的每个元素在A的幂集元素中只有两种选择，(to be | not to be) ,所以只要A是有穷集合，则 $ \sharp \rho ( A ) = 2 ^ { \sharp A } $</p>
</blockquote>
</li>
</ul>
<h2 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h2><ul>
<li>$有\cup,\cap,-(差，也叫对称补),\sim(补，也称绝对补)，\oplus(叫对称差)$<ul>
<li>$为啥 \sim 叫绝对补捏,因为\sim A = U - A$<blockquote>
<p>$所以 x \notin A \iff x \in \sim A$</p>
</blockquote>
</li>
<li>$那为啥\oplus 叫对称差捏,因为A \oplus B = (A-B) \cup (B-A)$<blockquote>
<p>就是去除掉相同的部分，跟异或有点像有米有。</p>
</blockquote>
</li>
</ul>
</li>
<li>$还有俩特殊的\bigcup、\bigcap,推广到n个集合的情况$<ul>
<li>$记作:\bigcup_{i=1}^{n}A_i ,也可以写成无穷的形式: \bigcap_{i=1}^{\infty}A_i$</li>
</ul>
</li>
<li>集合族，集合的聚合：如果一个集合的所有元素都是集合，则称该集合为 集合族 或 集合的聚合。<ul>
<li>$ 标码集合的概念：A = \{A_{s1},A_{s2},\dots\} ,J=\{s1,s2,\dots\}$<blockquote>
<p>$则A可以简化写成：A=\{A_i|i \in J\},咱们把A叫加标集合，J叫标码集合$</p>
</blockquote>
</li>
<li>$聚合上的\bigcup,\bigcap运算也有点讲究，我们将其称为广义并、广义交，主要体现在\bigcap 上$<blockquote>
<p>$集合族A，A元素的并集可以表示为\bigcup A 或者 \bigcup_{i\in J}A_i$ <br><br>即有就留下。<br>$即：\bigcup A =\{x| \exists S(S \in A \vee x \in S)\}$<br>$特殊的来了，对于\bigcap 咱们要求A \neq \phi,命名同上$<br>$我们定义：\bigcap A= \{x| \forall S (S \in A \rightarrow x \in S)\},$<br>$\therefore 若A=\phi，则S\in A \rightarrow x \in S 永真，\bigcap A 为U。$<br>$这里的\bigcup A有取所有A的元素都有的元素就留下$</p>
<ul>
<li>我觉得在这个定义上，和运算上的 $ \times \div $ 有点像，但我基础不够说不出来有什么内部的联系，等我研究一下，有成果在评论区告诉大家</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>另外，由集合族定义牵扯的广义分配律，广义德摩根律大家也可以去看看形式，这里不赘述了</li>
<li>还有一有意思的原理：（集合恒等式的基本形式可以与逻辑等值式类比）<ul>
<li>对偶原理：在不含有 $ -和\oplus $ 的集合恒等式中，将 $ \cup 与\cap $ 互换，$ \phi 与 U $ 互换，得到的仍是集合恒等式（或者可以用逻辑上的对偶定理来理解，真值不变）。<blockquote>
<p>是不是很有趣，为啥会这样呢。这两个玩意都是布尔代数的特例，可以去了解一下<a href="https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0/525084">布尔代数</a></p>
</blockquote>
</li>
</ul>
</li>
<li>咱们学过范式，我们可以用 $\{ \neg , \vee , \wedge \}$ 这个完备集来表示所有的逻辑情况，在集合里我们也可以用把所有的其他运算符化成 $\{\sim , \cup , \cap \}$ 来简化运算。当然很多时候可以用元素分析，需要灵活应对。<blockquote>
<p>$ A - B = A \cap \sim B$<br>$ A \oplus B = (A-B) \cup (B-A)=(A \cap \sim B) \cup (B \cap \sim A)$</p>
</blockquote>
</li>
</ul>
<h2 id="有穷集的计数原理"><a href="#有穷集的计数原理" class="headerlink" title="有穷集的计数原理"></a>有穷集的计数原理</h2><ul>
<li>如题，有定理 $ \sharp (A \cup B) = \sharp A + \sharp B -\sharp (A \cap B)$</li>
<li>可以画Venn图辅助理解。</li>
</ul>
<h2 id="集合的归纳定义法"><a href="#集合的归纳定义法" class="headerlink" title="集合的归纳定义法"></a>集合的归纳定义法</h2><ul>
<li>在第一节<a href="#集合与元素">集合与元素</a>讲过基础的定义，其中我们说抽象定义有时会有点不清楚，所以我们学习更好的归纳定义。</li>
<li>其中需注意的极小化定义，一般表述为“只有有限次应用基础语句和归纳语句得到的元素才是该集合中的元素”</li>
</ul>
<h2 id="有序偶和笛卡尔乘积"><a href="#有序偶和笛卡尔乘积" class="headerlink" title="有序偶和笛卡尔乘积"></a>有序偶和笛卡尔乘积</h2><ul>
<li>有序偶：两个对象x、y，他们按规定的顺序构成的序列，称之为有序偶，记为 &lt; x , y &gt;。</li>
<li>其中x称为第一元，y称为第二元。</li>
<li>有序偶的集合表示：<blockquote>
<p>&lt; x , y &gt; = { { x } , {x , y}}</p>
<ul>
<li>这样表示的话，有序偶的有序性得以体现。</li>
</ul>
</blockquote>
</li>
<li>$ n元序偶定义为：&lt; x_1 , x_2 , x_3 , \dots , x_n &gt; = &lt; &lt; x_1 , x_2 , \dots x_{n-1}&gt;, x_n &gt; $<ul>
<li>尝试着写一下n元序偶的集合表示呗！</li>
</ul>
</li>
<li>笛卡尔乘积：<blockquote>
<p>$ A \times B = \{ &lt; x, y&gt; | x \in A \wedge y \in B\}$</p>
<ul>
<li>由于有序偶的有序性，所以笛卡尔积不符合交换律和结合律</li>
<li>$ \sharp (A \times B) = \sharp A \cdot \sharp B (A,B为任意有限集) $</li>
</ul>
</blockquote>
</li>
<li>运算性质：<blockquote>
<p>$ A \times (B \cup C) = (A \times B) \cup (A \times C)$<br><br>$ (A \cup B) \times C = (A \times C) \cup (B \times C)$</p>
<ul>
<li>类似的分配律性质对 $\cap , -$ 也适用 </li>
</ul>
</blockquote>
</li>
<li>n个集合的笛卡尔积推广，自己类推一下叭。</li>
</ul>
<blockquote>
<p>未完待续。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>离散数学（二）</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>离散数学2</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA-高代】空间解析几何讲课材料-ppt、视频、备课本等</title>
    <url>/2022/10/08/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E8%AE%B2%E8%AF%BE%E6%9D%90%E6%96%99-ppt%E3%80%81%E8%A7%86%E9%A2%91%E3%80%81%E5%A4%87%E8%AF%BE%E6%9C%AC%E7%AD%89/</url>
    <content><![CDATA[<p>朋辈辅导师第三周直播课-空间解析几何基础的备课资料，大家有需要自取。</p>
<span id="more"></span>
<p>资料在这-&gt;<a href="https://bhpan.buaa.edu.cn:443/link/03BA02043D71BD977500323FA290621A">空间解析几何</a><br>有效期限：2025-11-11 23:59</p>
<hr>
<p>分割线，下面是备课本</p>
<hr>
<h1 id="空间解析几何总结"><a href="#空间解析几何总结" class="headerlink" title="空间解析几何总结"></a>空间解析几何总结</h1><p>各位同学大家好，我是来自北航学业与发展支持中心的朋辈辅导师肖灿，今天带来的是工科高等代数空间解析几何基础的直播</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>这里的知识大多比较基础，只是高中知识的一点拓展，还有许多内容是高中就学过的。我想，对与能考上北航的同学们来说，这些知识不成什么问题，因此，过于基础的内容我就不讲了。</li>
</ul>
<h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><ul>
<li>共线与不共线其实就代表着你们后面要学的线性相关和线性无关。</li>
<li>不共面定理的延申：混合积，向量组的秩</li>
<li>坐标定义在后面的空间部分也要延伸，三个相互正交的单位向量就是三个线性无关的基底</li>
<li>叉乘的物理背景：力矩</li>
<li>注意叉乘的方向，所以我们知道，叉乘不满足交换律，我们把这个叫反交换律，但是它满足分配律和结合律。</li>
<li>可以用方向余弦来表示单位向量，所以理所应当的得到余弦公式<ul>
<li>其实就是单位向量在三坐标轴上的投影</li>
</ul>
</li>
</ul>
<h2 id="空间曲线"><a href="#空间曲线" class="headerlink" title="空间曲线"></a>空间曲线</h2><ul>
<li>在看参数方程是体现了一种维数的思想，空间曲线是一维的物体所以只有一个参数</li>
<li>拓展：空间曲面的参数方程：两个参数</li>
<li>由于方程H是由方程组消去 z 后得到的结果，因此当 x , y 和 z 满足方程组时，前两个数 x , y 必定满足方程H，这说明曲线C 上的所有点都在由方程H所表示的曲面上.</li>
</ul>
<hr>
<p>我们前面研究的都是空间曲线和空间曲面，我们接下来来研究两个特殊的东西。——平面与直线</p>
<h2 id="空间平面"><a href="#空间平面" class="headerlink" title="空间平面"></a>空间平面</h2><ul>
<li>参数方程和一般方程之中体现自由度和约束条件的关系<ul>
<li>在三维空间中去看待一个约束条件取得的效果就是降一维，这就是为什么我们说二维空间中的一个曲线方程在三维的空间中是一个曲面。这也是为什么我们在后面的大家现在在学的线性方程组的研究中会有解空间的维度和秩之间的关系的问题，注意，这种空间的思想需要在整个高代的学习过程中一直运用，大家一定一定要理解好。</li>
</ul>
</li>
<li>而点法式，一般式都很容易看出法向量来，所以这里就不多说啦</li>
</ul>
<h2 id="空间直线"><a href="#空间直线" class="headerlink" title="空间直线"></a>空间直线</h2><ul>
<li>空间直线的参数式是最好看最直观的，在一个点的一个方向上延申，我们可以通过它来转化</li>
<li>两面式转化成参数式不多说，点向式和参数式之间的相互转换也不多说（他们之间的相互转换就不多说了，大家要有需求的话发弹幕告诉我，人多的话我就讲讲。）</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>空间解析几何基础，是大家期中考的主要内容，好像占70%，所以我的讲课中会大量的引用期中题作为例题，让大家体会一下难度。但是大家不用担心，这些对于大家来说不成问题。</li>
<li>看，是不是不难，但是大家也别对工科高代这门课掉以轻心，毕竟是六学分的大课，以后可能都不会再有课比这课学分多了</li>
<li>想拿高分不难，但是如果你只拿一个比较低的分或者是中等分，那你会和别人拉开很大的差距。</li>
</ul>
]]></content>
      <categories>
        <category>北航信息类大一资料</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>大一</tag>
        <tag>高代</tag>
        <tag>资源</tag>
      </tags>
  </entry>
</search>
